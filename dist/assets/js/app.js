/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4);


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _whatInput = __webpack_require__(5);

var _whatInput2 = _interopRequireDefault(_whatInput);

var _jarallax = __webpack_require__(6);

var _foundationSites = __webpack_require__(14);

var _foundationSites2 = _interopRequireDefault(_foundationSites);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.$ = _jquery2.default;

// If you want to pick and choose which modules to include, comment out the above and uncomment
// the line below
//import './lib/foundation-explicit-pieces';


document.addEventListener("DOMContentLoaded", function () {
  // Handler when the DOM is fully loaded
  (0, _jquery2.default)(document).foundation();
  (0, _jarallax.jarallaxElement)();

  (0, _jarallax.jarallax)(document.querySelectorAll('.jarallax'), {
    speed: 0.5
  });

  document.getElementById('hamburger--js').addEventListener('click', function () {
    this.classList.toggle("is-active");
    document.querySelector('.menu-main-menu-container').classList.toggle('active');
  });
});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * what-input - A global utility for tracking the current input method (mouse, keyboard or touch).
 * @version v4.3.1
 * @link https://github.com/ten1seven/what-input
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("whatInput", [], factory);
	else if(typeof exports === 'object')
		exports["whatInput"] = factory();
	else
		root["whatInput"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
	  /*
	   * variables
	   */

	  // last used input type
	  var currentInput = 'initial';

	  // last used input intent
	  var currentIntent = null;

	  // cache document.documentElement
	  var doc = document.documentElement;

	  // form input types
	  var formInputs = ['input', 'select', 'textarea'];

	  var functionList = [];

	  // list of modifier keys commonly used with the mouse and
	  // can be safely ignored to prevent false keyboard detection
	  var ignoreMap = [16, // shift
	  17, // control
	  18, // alt
	  91, // Windows key / left Apple cmd
	  93 // Windows menu / right Apple cmd
	  ];

	  // list of keys for which we change intent even for form inputs
	  var changeIntentMap = [9 // tab
	  ];

	  // mapping of events to input types
	  var inputMap = {
	    keydown: 'keyboard',
	    keyup: 'keyboard',
	    mousedown: 'mouse',
	    mousemove: 'mouse',
	    MSPointerDown: 'pointer',
	    MSPointerMove: 'pointer',
	    pointerdown: 'pointer',
	    pointermove: 'pointer',
	    touchstart: 'touch'
	  };

	  // array of all used input types
	  var inputTypes = [];

	  // boolean: true if touch buffer is active
	  var isBuffering = false;

	  // boolean: true if the page is being scrolled
	  var isScrolling = false;

	  // store current mouse position
	  var mousePos = {
	    x: null,
	    y: null
	  };

	  // map of IE 10 pointer events
	  var pointerMap = {
	    2: 'touch',
	    3: 'touch', // treat pen like touch
	    4: 'mouse'
	  };

	  var supportsPassive = false;

	  try {
	    var opts = Object.defineProperty({}, 'passive', {
	      get: function get() {
	        supportsPassive = true;
	      }
	    });

	    window.addEventListener('test', null, opts);
	  } catch (e) {}

	  /*
	   * set up
	   */

	  var setUp = function setUp() {
	    // add correct mouse wheel event mapping to `inputMap`
	    inputMap[detectWheel()] = 'mouse';

	    addListeners();
	    setInput();
	  };

	  /*
	   * events
	   */

	  var addListeners = function addListeners() {
	    // `pointermove`, `MSPointerMove`, `mousemove` and mouse wheel event binding
	    // can only demonstrate potential, but not actual, interaction
	    // and are treated separately
	    var options = supportsPassive ? { passive: true } : false;

	    // pointer events (mouse, pen, touch)
	    if (window.PointerEvent) {
	      doc.addEventListener('pointerdown', updateInput);
	      doc.addEventListener('pointermove', setIntent);
	    } else if (window.MSPointerEvent) {
	      doc.addEventListener('MSPointerDown', updateInput);
	      doc.addEventListener('MSPointerMove', setIntent);
	    } else {
	      // mouse events
	      doc.addEventListener('mousedown', updateInput);
	      doc.addEventListener('mousemove', setIntent);

	      // touch events
	      if ('ontouchstart' in window) {
	        doc.addEventListener('touchstart', touchBuffer, options);
	        doc.addEventListener('touchend', touchBuffer);
	      }
	    }

	    // mouse wheel
	    doc.addEventListener(detectWheel(), setIntent, options);

	    // keyboard events
	    doc.addEventListener('keydown', updateInput);
	    doc.addEventListener('keyup', updateInput);
	  };

	  // checks conditions before updating new input
	  var updateInput = function updateInput(event) {
	    // only execute if the touch buffer timer isn't running
	    if (!isBuffering) {
	      var eventKey = event.which;
	      var value = inputMap[event.type];
	      if (value === 'pointer') value = pointerType(event);

	      if (currentInput !== value || currentIntent !== value) {
	        var activeElem = document.activeElement;
	        var activeInput = false;
	        var notFormInput = activeElem && activeElem.nodeName && formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1;

	        if (notFormInput || changeIntentMap.indexOf(eventKey) !== -1) {
	          activeInput = true;
	        }

	        if (value === 'touch' ||
	        // ignore mouse modifier keys
	        value === 'mouse' ||
	        // don't switch if the current element is a form input
	        value === 'keyboard' && eventKey && activeInput && ignoreMap.indexOf(eventKey) === -1) {
	          // set the current and catch-all variable
	          currentInput = currentIntent = value;

	          setInput();
	        }
	      }
	    }
	  };

	  // updates the doc and `inputTypes` array with new input
	  var setInput = function setInput() {
	    doc.setAttribute('data-whatinput', currentInput);
	    doc.setAttribute('data-whatintent', currentInput);

	    if (inputTypes.indexOf(currentInput) === -1) {
	      inputTypes.push(currentInput);
	      doc.className += ' whatinput-types-' + currentInput;
	    }

	    fireFunctions('input');
	  };

	  // updates input intent for `mousemove` and `pointermove`
	  var setIntent = function setIntent(event) {
	    // test to see if `mousemove` happened relative to the screen
	    // to detect scrolling versus mousemove
	    if (mousePos['x'] !== event.screenX || mousePos['y'] !== event.screenY) {
	      isScrolling = false;

	      mousePos['x'] = event.screenX;
	      mousePos['y'] = event.screenY;
	    } else {
	      isScrolling = true;
	    }

	    // only execute if the touch buffer timer isn't running
	    // or scrolling isn't happening
	    if (!isBuffering && !isScrolling) {
	      var value = inputMap[event.type];
	      if (value === 'pointer') value = pointerType(event);

	      if (currentIntent !== value) {
	        currentIntent = value;

	        doc.setAttribute('data-whatintent', currentIntent);

	        fireFunctions('intent');
	      }
	    }
	  };

	  // buffers touch events because they frequently also fire mouse events
	  var touchBuffer = function touchBuffer(event) {
	    if (event.type === 'touchstart') {
	      isBuffering = false;

	      // set the current input
	      updateInput(event);
	    } else {
	      isBuffering = true;
	    }
	  };

	  var fireFunctions = function fireFunctions(type) {
	    for (var i = 0, len = functionList.length; i < len; i++) {
	      if (functionList[i].type === type) {
	        functionList[i].fn.call(undefined, currentIntent);
	      }
	    }
	  };

	  /*
	   * utilities
	   */

	  var pointerType = function pointerType(event) {
	    if (typeof event.pointerType === 'number') {
	      return pointerMap[event.pointerType];
	    } else {
	      // treat pen like touch
	      return event.pointerType === 'pen' ? 'touch' : event.pointerType;
	    }
	  };

	  // detect version of mouse wheel event to use
	  // via https://developer.mozilla.org/en-US/docs/Web/Events/wheel
	  var detectWheel = function detectWheel() {
	    var wheelType = void 0;

	    // Modern browsers support "wheel"
	    if ('onwheel' in document.createElement('div')) {
	      wheelType = 'wheel';
	    } else {
	      // Webkit and IE support at least "mousewheel"
	      // or assume that remaining browsers are older Firefox
	      wheelType = document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';
	    }

	    return wheelType;
	  };

	  var objPos = function objPos(match) {
	    for (var i = 0, len = functionList.length; i < len; i++) {
	      if (functionList[i].fn === match) {
	        return i;
	      }
	    }
	  };

	  /*
	   * init
	   */

	  // don't start script unless browser cuts the mustard
	  // (also passes if polyfills are used)
	  if ('addEventListener' in window && Array.prototype.indexOf) {
	    setUp();
	  }

	  /*
	   * api
	   */

	  return {
	    // returns string: the current input type
	    // opt: 'loose'|'strict'
	    // 'strict' (default): returns the same value as the `data-whatinput` attribute
	    // 'loose': includes `data-whatintent` value if it's more current than `data-whatinput`
	    ask: function ask(opt) {
	      return opt === 'loose' ? currentIntent : currentInput;
	    },

	    // returns array: all the detected input types
	    types: function types() {
	      return inputTypes;
	    },

	    // overwrites ignored keys with provided array
	    ignoreKeys: function ignoreKeys(arr) {
	      ignoreMap = arr;
	    },

	    // attach functions to input and intent "events"
	    // funct: function to fire on change
	    // eventType: 'input'|'intent'
	    registerOnChange: function registerOnChange(fn, eventType) {
	      functionList.push({
	        fn: fn,
	        type: eventType || 'input'
	      });
	    },

	    unRegisterOnChange: function unRegisterOnChange(fn) {
	      var position = objPos(fn);

	      if (position) {
	        functionList.splice(position, 1);
	      }
	    }
	  };
	}();

/***/ }
/******/ ])
});
;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

const jarallax = __webpack_require__(7).default;
const jarallaxVideo = __webpack_require__(10).default;
const jarallaxElement = __webpack_require__(13).default;

module.exports = {
    jarallax,
    jarallaxElement() {
        return jarallaxElement(jarallax);
    },
    jarallaxVideo() {
        return jarallaxVideo(jarallax);
    },
};


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lite_ready__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lite_ready___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lite_ready__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rafl__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rafl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rafl__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_global__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_global___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_global__);




const isIE = navigator.userAgent.indexOf('MSIE ') > -1 || navigator.userAgent.indexOf('Trident/') > -1 || navigator.userAgent.indexOf('Edge/') > -1;

const supportTransform = (() => {
    const prefixes = 'transform WebkitTransform MozTransform'.split(' ');
    const div = document.createElement('div');
    for (let i = 0; i < prefixes.length; i++) {
        if (div && div.style[prefixes[i]] !== undefined) {
            return prefixes[i];
        }
    }
    return false;
})();

// Window data
let wndW;
let wndH;
let wndY;
let forceResizeParallax = false;
let forceScrollParallax = false;
function updateWndVars(e) {
    wndW = __WEBPACK_IMPORTED_MODULE_2_global__["window"].innerWidth || document.documentElement.clientWidth;
    wndH = __WEBPACK_IMPORTED_MODULE_2_global__["window"].innerHeight || document.documentElement.clientHeight;
    if (typeof e === 'object' && (e.type === 'load' || e.type === 'dom-loaded')) {
        forceResizeParallax = true;
    }
}
updateWndVars();
__WEBPACK_IMPORTED_MODULE_2_global__["window"].addEventListener('resize', updateWndVars);
__WEBPACK_IMPORTED_MODULE_2_global__["window"].addEventListener('orientationchange', updateWndVars);
__WEBPACK_IMPORTED_MODULE_2_global__["window"].addEventListener('load', updateWndVars);
__WEBPACK_IMPORTED_MODULE_0_lite_ready___default()(() => {
    updateWndVars({
        type: 'dom-loaded',
    });
});

// list with all jarallax instances
// need to render all in one scroll/resize event
const jarallaxList = [];

// Animate if changed window size or scrolled page
let oldPageData = false;
function updateParallax() {
    if (!jarallaxList.length) {
        return;
    }

    if (__WEBPACK_IMPORTED_MODULE_2_global__["window"].pageYOffset !== undefined) {
        wndY = __WEBPACK_IMPORTED_MODULE_2_global__["window"].pageYOffset;
    } else {
        wndY = (document.documentElement || document.body.parentNode || document.body).scrollTop;
    }

    const isResized = forceResizeParallax || !oldPageData || oldPageData.width !== wndW || oldPageData.height !== wndH;
    const isScrolled = forceScrollParallax || isResized || !oldPageData || oldPageData.y !== wndY;

    forceResizeParallax = false;
    forceScrollParallax = false;

    if (isResized || isScrolled) {
        jarallaxList.forEach((item) => {
            if (isResized) {
                item.onResize();
            }
            if (isScrolled) {
                item.onScroll();
            }
        });

        oldPageData = {
            width: wndW,
            height: wndH,
            y: wndY,
        };
    }

    __WEBPACK_IMPORTED_MODULE_1_rafl___default()(updateParallax);
}


// ResizeObserver
const resizeObserver = global.ResizeObserver ? new global.ResizeObserver((entry) => {
    if (entry && entry.length) {
        __WEBPACK_IMPORTED_MODULE_1_rafl___default()(() => {
            entry.forEach((item) => {
                if (item.target && item.target.jarallax) {
                    if (!forceResizeParallax) {
                        item.target.jarallax.onResize();
                    }
                    forceScrollParallax = true;
                }
            });
        });
    }
}) : false;


let instanceID = 0;

// Jarallax class
class Jarallax {
    constructor(item, userOptions) {
        const self = this;

        self.instanceID = instanceID++;

        self.$item = item;

        self.defaults = {
            type: 'scroll', // type of parallax: scroll, scale, opacity, scale-opacity, scroll-opacity
            speed: 0.5, // supported value from -1 to 2
            imgSrc: null,
            imgElement: '.jarallax-img',
            imgSize: 'cover',
            imgPosition: '50% 50%',
            imgRepeat: 'no-repeat', // supported only for background, not for <img> tag
            keepImg: false, // keep <img> tag in it's default place
            elementInViewport: null,
            zIndex: -100,
            disableParallax: false,
            disableVideo: false,
            automaticResize: true, // use ResizeObserver to recalculate position and size of parallax image

            // video
            videoSrc: null,
            videoStartTime: 0,
            videoEndTime: 0,
            videoVolume: 0,
            videoLoop: true,
            videoPlayOnlyVisible: true,

            // events
            onScroll: null, // function(calculations) {}
            onInit: null, // function() {}
            onDestroy: null, // function() {}
            onCoverImage: null, // function() {}
        };

        // DEPRECATED: old data-options
        const deprecatedDataAttribute = self.$item.getAttribute('data-jarallax');
        const oldDataOptions = JSON.parse(deprecatedDataAttribute || '{}');
        if (deprecatedDataAttribute) {
            // eslint-disable-next-line no-console
            console.warn('Detected usage of deprecated data-jarallax JSON options, you should use pure data-attribute options. See info here - https://github.com/nk-o/jarallax/issues/53');
        }

        // prepare data-options
        const dataOptions = self.$item.dataset || {};
        const pureDataOptions = {};
        Object.keys(dataOptions).forEach((key) => {
            const loweCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);
            if (loweCaseOption && typeof self.defaults[loweCaseOption] !== 'undefined') {
                pureDataOptions[loweCaseOption] = dataOptions[key];
            }
        });

        self.options = self.extend({}, self.defaults, oldDataOptions, pureDataOptions, userOptions);
        self.pureOptions = self.extend({}, self.options);

        // prepare 'true' and 'false' strings to boolean
        Object.keys(self.options).forEach((key) => {
            if (self.options[key] === 'true') {
                self.options[key] = true;
            } else if (self.options[key] === 'false') {
                self.options[key] = false;
            }
        });

        // fix speed option [-1.0, 2.0]
        self.options.speed = Math.min(2, Math.max(-1, parseFloat(self.options.speed)));

        // deprecated noAndroid and noIos options
        if (self.options.noAndroid || self.options.noIos) {
            // eslint-disable-next-line no-console
            console.warn('Detected usage of deprecated noAndroid or noIos options, you should use disableParallax option. See info here - https://github.com/nk-o/jarallax/#disable-on-mobile-devices');

            // prepare fallback if disableParallax option is not used
            if (!self.options.disableParallax) {
                if (self.options.noIos && self.options.noAndroid) {
                    self.options.disableParallax = /iPad|iPhone|iPod|Android/;
                } else if (self.options.noIos) {
                    self.options.disableParallax = /iPad|iPhone|iPod/;
                } else if (self.options.noAndroid) {
                    self.options.disableParallax = /Android/;
                }
            }
        }

        // prepare disableParallax callback
        if (typeof self.options.disableParallax === 'string') {
            self.options.disableParallax = new RegExp(self.options.disableParallax);
        }
        if (self.options.disableParallax instanceof RegExp) {
            const disableParallaxRegexp = self.options.disableParallax;
            self.options.disableParallax = () => disableParallaxRegexp.test(navigator.userAgent);
        }
        if (typeof self.options.disableParallax !== 'function') {
            self.options.disableParallax = () => false;
        }

        // prepare disableVideo callback
        if (typeof self.options.disableVideo === 'string') {
            self.options.disableVideo = new RegExp(self.options.disableVideo);
        }
        if (self.options.disableVideo instanceof RegExp) {
            const disableVideoRegexp = self.options.disableVideo;
            self.options.disableVideo = () => disableVideoRegexp.test(navigator.userAgent);
        }
        if (typeof self.options.disableVideo !== 'function') {
            self.options.disableVideo = () => false;
        }

        // custom element to check if parallax in viewport
        let elementInVP = self.options.elementInViewport;
        // get first item from array
        if (elementInVP && typeof elementInVP === 'object' && typeof elementInVP.length !== 'undefined') {
            [elementInVP] = elementInVP;
        }
        // check if dom element
        if (!(elementInVP instanceof Element)) {
            elementInVP = null;
        }
        self.options.elementInViewport = elementInVP;

        self.image = {
            src: self.options.imgSrc || null,
            $container: null,
            useImgTag: false,

            // position fixed is needed for the most of browsers because absolute position have glitches
            // on MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75
            // on mobile devices better scrolled with absolute position
            position: /iPad|iPhone|iPod|Android/.test(navigator.userAgent) ? 'absolute' : 'fixed',
        };

        if (self.initImg() && self.canInitParallax()) {
            self.init();
        }
    }

    // add styles to element
    css(el, styles) {
        if (typeof styles === 'string') {
            return __WEBPACK_IMPORTED_MODULE_2_global__["window"].getComputedStyle(el).getPropertyValue(styles);
        }

        // add transform property with vendor prefix
        if (styles.transform && supportTransform) {
            styles[supportTransform] = styles.transform;
        }

        Object.keys(styles).forEach((key) => {
            el.style[key] = styles[key];
        });
        return el;
    }

    // Extend like jQuery.extend
    extend(out) {
        out = out || {};
        Object.keys(arguments).forEach((i) => {
            if (!arguments[i]) {
                return;
            }
            Object.keys(arguments[i]).forEach((key) => {
                out[key] = arguments[i][key];
            });
        });
        return out;
    }

    // get window size and scroll position. Useful for extensions
    getWindowData() {
        return {
            width: wndW,
            height: wndH,
            y: wndY,
        };
    }

    // Jarallax functions
    initImg() {
        const self = this;

        // find image element
        let $imgElement = self.options.imgElement;
        if ($imgElement && typeof $imgElement === 'string') {
            $imgElement = self.$item.querySelector($imgElement);
        }
        // check if dom element
        if (!($imgElement instanceof Element)) {
            $imgElement = null;
        }

        if ($imgElement) {
            if (self.options.keepImg) {
                self.image.$item = $imgElement.cloneNode(true);
            } else {
                self.image.$item = $imgElement;
                self.image.$itemParent = $imgElement.parentNode;
            }
            self.image.useImgTag = true;
        }

        // true if there is img tag
        if (self.image.$item) {
            return true;
        }

        // get image src
        if (self.image.src === null) {
            self.image.src = self.css(self.$item, 'background-image').replace(/^url\(['"]?/g, '').replace(/['"]?\)$/g, '');
        }
        return !(!self.image.src || self.image.src === 'none');
    }

    canInitParallax() {
        return supportTransform && !this.options.disableParallax();
    }

    init() {
        const self = this;
        const containerStyles = {
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            overflow: 'hidden',
            pointerEvents: 'none',
        };
        let imageStyles = {};

        if (!self.options.keepImg) {
            // save default user styles
            const curStyle = self.$item.getAttribute('style');
            if (curStyle) {
                self.$item.setAttribute('data-jarallax-original-styles', curStyle);
            }
            if (self.image.useImgTag) {
                const curImgStyle = self.image.$item.getAttribute('style');
                if (curImgStyle) {
                    self.image.$item.setAttribute('data-jarallax-original-styles', curImgStyle);
                }
            }
        }

        // set relative position and z-index to the parent
        if (self.css(self.$item, 'position') === 'static') {
            self.css(self.$item, {
                position: 'relative',
            });
        }
        if (self.css(self.$item, 'z-index') === 'auto') {
            self.css(self.$item, {
                zIndex: 0,
            });
        }

        // container for parallax image
        self.image.$container = document.createElement('div');
        self.css(self.image.$container, containerStyles);
        self.css(self.image.$container, {
            'z-index': self.options.zIndex,
        });

        // fix for IE https://github.com/nk-o/jarallax/issues/110
        if (isIE) {
            self.css(self.image.$container, {
                opacity: 0.9999,
            });
        }

        self.image.$container.setAttribute('id', `jarallax-container-${self.instanceID}`);
        self.$item.appendChild(self.image.$container);

        // use img tag
        if (self.image.useImgTag) {
            imageStyles = self.extend({
                'object-fit': self.options.imgSize,
                'object-position': self.options.imgPosition,
                // support for plugin https://github.com/bfred-it/object-fit-images
                'font-family': `object-fit: ${self.options.imgSize}; object-position: ${self.options.imgPosition};`,
                'max-width': 'none',
            }, containerStyles, imageStyles);

        // use div with background image
        } else {
            self.image.$item = document.createElement('div');
            if (self.image.src) {
                imageStyles = self.extend({
                    'background-position': self.options.imgPosition,
                    'background-size': self.options.imgSize,
                    'background-repeat': self.options.imgRepeat,
                    'background-image': `url("${self.image.src}")`,
                }, containerStyles, imageStyles);
            }
        }

        if (self.options.type === 'opacity' || self.options.type === 'scale' || self.options.type === 'scale-opacity' || self.options.speed === 1) {
            self.image.position = 'absolute';
        }

        // check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)
        // discussion - https://github.com/nk-o/jarallax/issues/9
        if (self.image.position === 'fixed') {
            let parentWithTransform = 0;
            let $itemParents = self.$item;
            while ($itemParents !== null && $itemParents !== document && parentWithTransform === 0) {
                const parentTransform = self.css($itemParents, '-webkit-transform') || self.css($itemParents, '-moz-transform') || self.css($itemParents, 'transform');
                if (parentTransform && parentTransform !== 'none') {
                    parentWithTransform = 1;
                    self.image.position = 'absolute';
                }
                $itemParents = $itemParents.parentNode;
            }
        }

        // add position to parallax block
        imageStyles.position = self.image.position;

        // insert parallax image
        self.css(self.image.$item, imageStyles);
        self.image.$container.appendChild(self.image.$item);

        // set initial position and size
        self.onResize();
        self.onScroll(true);

        // ResizeObserver
        if (self.options.automaticResize && resizeObserver) {
            resizeObserver.observe(self.$item);
        }

        // call onInit event
        if (self.options.onInit) {
            self.options.onInit.call(self);
        }

        // remove default user background
        if (self.css(self.$item, 'background-image') !== 'none') {
            self.css(self.$item, {
                'background-image': 'none',
            });
        }

        self.addToParallaxList();
    }

    // add to parallax instances list
    addToParallaxList() {
        jarallaxList.push(this);

        if (jarallaxList.length === 1) {
            updateParallax();
        }
    }

    // remove from parallax instances list
    removeFromParallaxList() {
        const self = this;

        jarallaxList.forEach((item, key) => {
            if (item.instanceID === self.instanceID) {
                jarallaxList.splice(key, 1);
            }
        });
    }

    destroy() {
        const self = this;

        self.removeFromParallaxList();

        // return styles on container as before jarallax init
        const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');
        self.$item.removeAttribute('data-jarallax-original-styles');
        // null occurs if there is no style tag before jarallax init
        if (!originalStylesTag) {
            self.$item.removeAttribute('style');
        } else {
            self.$item.setAttribute('style', originalStylesTag);
        }

        if (self.image.useImgTag) {
            // return styles on img tag as before jarallax init
            const originalStylesImgTag = self.image.$item.getAttribute('data-jarallax-original-styles');
            self.image.$item.removeAttribute('data-jarallax-original-styles');
            // null occurs if there is no style tag before jarallax init
            if (!originalStylesImgTag) {
                self.image.$item.removeAttribute('style');
            } else {
                self.image.$item.setAttribute('style', originalStylesTag);
            }

            // move img tag to its default position
            if (self.image.$itemParent) {
                self.image.$itemParent.appendChild(self.image.$item);
            }
        }

        // remove additional dom elements
        if (self.$clipStyles) {
            self.$clipStyles.parentNode.removeChild(self.$clipStyles);
        }
        if (self.image.$container) {
            self.image.$container.parentNode.removeChild(self.image.$container);
        }

        // call onDestroy event
        if (self.options.onDestroy) {
            self.options.onDestroy.call(self);
        }

        // delete jarallax from item
        delete self.$item.jarallax;
    }

    // it will remove some image overlapping
    // overlapping occur due to an image position fixed inside absolute position element
    clipContainer() {
        // needed only when background in fixed position
        if (this.image.position !== 'fixed') {
            return;
        }

        const self = this;
        const rect = self.image.$container.getBoundingClientRect();
        const { width, height } = rect;

        if (!self.$clipStyles) {
            self.$clipStyles = document.createElement('style');
            self.$clipStyles.setAttribute('type', 'text/css');
            self.$clipStyles.setAttribute('id', `jarallax-clip-${self.instanceID}`);
            const head = document.head || document.getElementsByTagName('head')[0];
            head.appendChild(self.$clipStyles);
        }

        const styles = `#jarallax-container-${self.instanceID} {
           clip: rect(0 ${width}px ${height}px 0);
           clip: rect(0, ${width}px, ${height}px, 0);
        }`;

        // add clip styles inline (this method need for support IE8 and less browsers)
        if (self.$clipStyles.styleSheet) {
            self.$clipStyles.styleSheet.cssText = styles;
        } else {
            self.$clipStyles.innerHTML = styles;
        }
    }

    coverImage() {
        const self = this;

        const rect = self.image.$container.getBoundingClientRect();
        const contH = rect.height;
        const { speed } = self.options;
        const isScroll = self.options.type === 'scroll' || self.options.type === 'scroll-opacity';
        let scrollDist = 0;
        let resultH = contH;
        let resultMT = 0;

        // scroll parallax
        if (isScroll) {
            // scroll distance and height for image
            if (speed < 0) {
                scrollDist = speed * Math.max(contH, wndH);

                if (wndH < contH) {
                    scrollDist -= speed * (contH - wndH);
                }
            } else {
                scrollDist = speed * (contH + wndH);
            }

            // size for scroll parallax
            if (speed > 1) {
                resultH = Math.abs(scrollDist - wndH);
            } else if (speed < 0) {
                resultH = scrollDist / speed + Math.abs(scrollDist);
            } else {
                resultH += (wndH - contH) * (1 - speed);
            }

            scrollDist /= 2;
        }

        // store scroll distance
        self.parallaxScrollDistance = scrollDist;

        // vertical center
        if (isScroll) {
            resultMT = (wndH - resultH) / 2;
        } else {
            resultMT = (contH - resultH) / 2;
        }

        // apply result to item
        self.css(self.image.$item, {
            height: `${resultH}px`,
            marginTop: `${resultMT}px`,
            left: self.image.position === 'fixed' ? `${rect.left}px` : '0',
            width: `${rect.width}px`,
        });

        // call onCoverImage event
        if (self.options.onCoverImage) {
            self.options.onCoverImage.call(self);
        }

        // return some useful data. Used in the video cover function
        return {
            image: {
                height: resultH,
                marginTop: resultMT,
            },
            container: rect,
        };
    }

    isVisible() {
        return this.isElementInViewport || false;
    }

    onScroll(force) {
        const self = this;

        const rect = self.$item.getBoundingClientRect();
        const contT = rect.top;
        const contH = rect.height;
        const styles = {};

        // check if in viewport
        let viewportRect = rect;
        if (self.options.elementInViewport) {
            viewportRect = self.options.elementInViewport.getBoundingClientRect();
        }
        self.isElementInViewport = viewportRect.bottom >= 0
            && viewportRect.right >= 0
            && viewportRect.top <= wndH
            && viewportRect.left <= wndW;

        // stop calculations if item is not in viewport
        if (force ? false : !self.isElementInViewport) {
            return;
        }

        // calculate parallax helping variables
        const beforeTop = Math.max(0, contT);
        const beforeTopEnd = Math.max(0, contH + contT);
        const afterTop = Math.max(0, -contT);
        const beforeBottom = Math.max(0, contT + contH - wndH);
        const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));
        const afterBottom = Math.max(0, -contT + wndH - contH);
        const fromViewportCenter = 1 - 2 * (wndH - contT) / (wndH + contH);

        // calculate on how percent of section is visible
        let visiblePercent = 1;
        if (contH < wndH) {
            visiblePercent = 1 - (afterTop || beforeBottom) / contH;
        } else if (beforeTopEnd <= wndH) {
            visiblePercent = beforeTopEnd / wndH;
        } else if (beforeBottomEnd <= wndH) {
            visiblePercent = beforeBottomEnd / wndH;
        }

        // opacity
        if (self.options.type === 'opacity' || self.options.type === 'scale-opacity' || self.options.type === 'scroll-opacity') {
            styles.transform = 'translate3d(0,0,0)';
            styles.opacity = visiblePercent;
        }

        // scale
        if (self.options.type === 'scale' || self.options.type === 'scale-opacity') {
            let scale = 1;
            if (self.options.speed < 0) {
                scale -= self.options.speed * visiblePercent;
            } else {
                scale += self.options.speed * (1 - visiblePercent);
            }
            styles.transform = `scale(${scale}) translate3d(0,0,0)`;
        }

        // scroll
        if (self.options.type === 'scroll' || self.options.type === 'scroll-opacity') {
            let positionY = self.parallaxScrollDistance * fromViewportCenter;

            // fix if parallax block in absolute position
            if (self.image.position === 'absolute') {
                positionY -= contT;
            }

            styles.transform = `translate3d(0,${positionY}px,0)`;
        }

        self.css(self.image.$item, styles);

        // call onScroll event
        if (self.options.onScroll) {
            self.options.onScroll.call(self, {
                section: rect,

                beforeTop,
                beforeTopEnd,
                afterTop,
                beforeBottom,
                beforeBottomEnd,
                afterBottom,

                visiblePercent,
                fromViewportCenter,
            });
        }
    }

    onResize() {
        this.coverImage();
        this.clipContainer();
    }
}


// global definition
const plugin = function (items) {
    // check for dom element
    // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
    if (typeof HTMLElement === 'object' ? items instanceof HTMLElement : items && typeof items === 'object' && items !== null && items.nodeType === 1 && typeof items.nodeName === 'string') {
        items = [items];
    }

    const options = arguments[1];
    const args = Array.prototype.slice.call(arguments, 2);
    const len = items.length;
    let k = 0;
    let ret;

    for (k; k < len; k++) {
        if (typeof options === 'object' || typeof options === 'undefined') {
            if (!items[k].jarallax) {
                items[k].jarallax = new Jarallax(items[k], options);
            }
        } else if (items[k].jarallax) {
            // eslint-disable-next-line prefer-spread
            ret = items[k].jarallax[options].apply(items[k].jarallax, args);
        }
        if (typeof ret !== 'undefined') {
            return ret;
        }
    }

    return items;
};
plugin.constructor = Jarallax;

/* harmony default export */ __webpack_exports__["default"] = (plugin);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = function (callback) {

	if (document.readyState === 'complete' || document.readyState === 'interactive') {
		// Already ready or interactive, execute callback
		callback.call();
	}
	else if (document.attachEvent) {
		// Old browsers
		document.attachEvent('onreadystatechange', function () {
			if (document.readyState === 'interactive')
				callback.call();
		});
	}
	else if (document.addEventListener) {
		// Modern browsers
		document.addEventListener('DOMContentLoaded', callback);
	}
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(0)

/**
 * `requestAnimationFrame()`
 */

var request = global.requestAnimationFrame
  || global.webkitRequestAnimationFrame
  || global.mozRequestAnimationFrame
  || fallback

var prev = +new Date
function fallback (fn) {
  var curr = +new Date
  var ms = Math.max(0, 16 - (curr - prev))
  var req = setTimeout(fn, ms)
  return prev = curr, req
}

/**
 * `cancelAnimationFrame()`
 */

var cancel = global.cancelAnimationFrame
  || global.webkitCancelAnimationFrame
  || global.mozCancelAnimationFrame
  || clearTimeout

if (Function.prototype.bind) {
  request = request.bind(global)
  cancel = cancel.bind(global)
}

exports = module.exports = request
exports.cancel = cancel


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = jarallaxVideo;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_video_worker__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_video_worker___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_video_worker__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_global__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_global___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_global__);



function jarallaxVideo(jarallax = __WEBPACK_IMPORTED_MODULE_1_global___default.a.jarallax) {
    if (typeof jarallax === 'undefined') {
        return;
    }

    const Jarallax = jarallax.constructor;

    // append video after init Jarallax
    const defInit = Jarallax.prototype.init;
    Jarallax.prototype.init = function () {
        const self = this;

        defInit.apply(self);

        if (self.video && !self.options.disableVideo()) {
            self.video.getVideo((video) => {
                const $parent = video.parentNode;
                self.css(video, {
                    position: self.image.position,
                    top: '0px',
                    left: '0px',
                    right: '0px',
                    bottom: '0px',
                    width: '100%',
                    height: '100%',
                    maxWidth: 'none',
                    maxHeight: 'none',
                    margin: 0,
                    zIndex: -1,
                });
                self.$video = video;
                self.image.$container.appendChild(video);

                // remove parent video element (created by VideoWorker)
                $parent.parentNode.removeChild($parent);
            });
        }
    };

    // cover video
    const defCoverImage = Jarallax.prototype.coverImage;
    Jarallax.prototype.coverImage = function () {
        const self = this;
        const imageData = defCoverImage.apply(self);
        const node = self.image.$item ? self.image.$item.nodeName : false;

        if (imageData && self.video && node && (node === 'IFRAME' || node === 'VIDEO')) {
            let h = imageData.image.height;
            let w = h * self.image.width / self.image.height;
            let ml = (imageData.container.width - w) / 2;
            let mt = imageData.image.marginTop;

            if (imageData.container.width > w) {
                w = imageData.container.width;
                h = w * self.image.height / self.image.width;
                ml = 0;
                mt += (imageData.image.height - h) / 2;
            }

            // add video height over than need to hide controls
            if (node === 'IFRAME') {
                h += 400;
                mt -= 200;
            }

            self.css(self.$video, {
                width: `${w}px`,
                marginLeft: `${ml}px`,
                height: `${h}px`,
                marginTop: `${mt}px`,
            });
        }

        return imageData;
    };

    // init video
    const defInitImg = Jarallax.prototype.initImg;
    Jarallax.prototype.initImg = function () {
        const self = this;
        const defaultResult = defInitImg.apply(self);

        if (!self.options.videoSrc) {
            self.options.videoSrc = self.$item.getAttribute('data-jarallax-video') || null;
        }

        if (self.options.videoSrc) {
            self.defaultInitImgResult = defaultResult;
            return true;
        }

        return defaultResult;
    };

    const defCanInitParallax = Jarallax.prototype.canInitParallax;
    Jarallax.prototype.canInitParallax = function () {
        const self = this;
        const defaultResult = defCanInitParallax.apply(self);

        if (!self.options.videoSrc) {
            return defaultResult;
        }

        const video = new __WEBPACK_IMPORTED_MODULE_0_video_worker___default.a(self.options.videoSrc, {
            autoplay: true,
            loop: self.options.videoLoop,
            showContols: false,
            startTime: self.options.videoStartTime || 0,
            endTime: self.options.videoEndTime || 0,
            mute: self.options.videoVolume ? 0 : 1,
            volume: self.options.videoVolume || 0,
        });

        if (video.isValid()) {
            // if parallax will not be inited, we can add thumbnail on background.
            if (!defaultResult) {
                if (!self.defaultInitImgResult) {
                    video.getImageURL((url) => {
                        // save default user styles
                        const curStyle = self.$item.getAttribute('style');
                        if (curStyle) {
                            self.$item.setAttribute('data-jarallax-original-styles', curStyle);
                        }

                        // set new background
                        self.css(self.$item, {
                            'background-image': `url("${url}")`,
                            'background-position': 'center',
                            'background-size': 'cover',
                        });
                    });
                }

                // init video
            } else {
                video.on('ready', () => {
                    if (self.options.videoPlayOnlyVisible) {
                        const oldOnScroll = self.onScroll;
                        self.onScroll = function () {
                            oldOnScroll.apply(self);
                            if (self.options.videoLoop || (!self.options.videoLoop && !self.videoEnded)) {
                                if (self.isVisible()) {
                                    video.play();
                                } else {
                                    video.pause();
                                }
                            }
                        };
                    } else {
                        video.play();
                    }
                });

                video.on('started', () => {
                    self.image.$default_item = self.image.$item;
                    self.image.$item = self.$video;

                    // set video width and height
                    self.image.width = self.video.videoWidth || 1280;
                    self.image.height = self.video.videoHeight || 720;
                    self.coverImage();
                    self.clipContainer();
                    self.onScroll();

                    // hide image
                    if (self.image.$default_item) {
                        self.image.$default_item.style.display = 'none';
                    }
                });

                video.on('ended', () => {
                    self.videoEnded = true;

                    if (!self.options.videoLoop) {
                        // show image if Loop disabled
                        if (self.image.$default_item) {
                            self.image.$item = self.image.$default_item;
                            self.image.$item.style.display = 'block';

                            // set image width and height
                            self.coverImage();
                            self.clipContainer();
                            self.onScroll();
                        }
                    }
                });

                self.video = video;

                // set image if not exists
                if (!self.defaultInitImgResult) {
                    if (video.type !== 'local') {
                        video.getImageURL((url) => {
                            self.image.src = url;
                            self.init();
                        });

                        return false;
                    }

                    // set empty image on local video if not defined
                    self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                    return true;
                }
            }
        }

        return defaultResult;
    };

    // Destroy video parallax
    const defDestroy = Jarallax.prototype.destroy;
    Jarallax.prototype.destroy = function () {
        const self = this;

        if (self.image.$default_item) {
            self.image.$item = self.image.$default_item;
            delete self.image.$default_item;
        }

        defDestroy.apply(self);
    };
}


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(12);


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
// Deferred
// thanks http://stackoverflow.com/questions/18096715/implement-deferred-object-without-using-jquery
function Deferred() {
    this._done = [];
    this._fail = [];
}
Deferred.prototype = {
    execute(list, args) {
        let i = list.length;
        args = Array.prototype.slice.call(args);
        while (i--) {
            list[i].apply(null, args);
        }
    },
    resolve() {
        this.execute(this._done, arguments);
    },
    reject() {
        this.execute(this._fail, arguments);
    },
    done(callback) {
        this._done.push(callback);
    },
    fail(callback) {
        this._fail.push(callback);
    },
};

let ID = 0;
let YoutubeAPIadded = 0;
let VimeoAPIadded = 0;
let loadingYoutubePlayer = 0;
let loadingVimeoPlayer = 0;
const loadingYoutubeDefer = new Deferred();
const loadingVimeoDefer = new Deferred();

class VideoWorker {
    constructor(url, options) {
        const self = this;

        self.url = url;

        self.options_default = {
            autoplay: false,
            loop: false,
            mute: false,
            volume: 100,
            showContols: true,

            // start / end video time in seconds
            startTime: 0,
            endTime: 0,
        };

        self.options = self.extend({}, self.options_default, options);

        // check URL
        self.videoID = self.parseURL(url);

        // init
        if (self.videoID) {
            self.ID = ID++;
            self.loadAPI();
            self.init();
        }
    }

    // Extend like jQuery.extend
    extend(out) {
        out = out || {};
        Object.keys(arguments).forEach((i) => {
            if (!arguments[i]) {
                return;
            }
            Object.keys(arguments[i]).forEach((key) => {
                out[key] = arguments[i][key];
            });
        });
        return out;
    }

    parseURL(url) {
        // parse youtube ID
        function getYoutubeID(ytUrl) {
            // eslint-disable-next-line no-useless-escape
            const regExp = /.*(?:youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#\&\?]*).*/;
            const match = ytUrl.match(regExp);
            return match && match[1].length === 11 ? match[1] : false;
        }

        // parse vimeo ID
        function getVimeoID(vmUrl) {
            // eslint-disable-next-line no-useless-escape
            const regExp = /https?:\/\/(?:www\.|player\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^\/]*)\/videos\/|album\/(\d+)\/video\/|video\/|)(\d+)(?:$|\/|\?)/;
            const match = vmUrl.match(regExp);
            return match && match[3] ? match[3] : false;
        }

        // parse local string
        function getLocalVideos(locUrl) {
            // eslint-disable-next-line no-useless-escape
            const videoFormats = locUrl.split(/,(?=mp4\:|webm\:|ogv\:|ogg\:)/);
            const result = {};
            let ready = 0;
            videoFormats.forEach((val) => {
                // eslint-disable-next-line no-useless-escape
                const match = val.match(/^(mp4|webm|ogv|ogg)\:(.*)/);
                if (match && match[1] && match[2]) {
                    // eslint-disable-next-line prefer-destructuring
                    result[match[1] === 'ogv' ? 'ogg' : match[1]] = match[2];
                    ready = 1;
                }
            });
            return ready ? result : false;
        }

        const Youtube = getYoutubeID(url);
        const Vimeo = getVimeoID(url);
        const Local = getLocalVideos(url);

        if (Youtube) {
            this.type = 'youtube';
            return Youtube;
        } else if (Vimeo) {
            this.type = 'vimeo';
            return Vimeo;
        } else if (Local) {
            this.type = 'local';
            return Local;
        }

        return false;
    }

    isValid() {
        return !!this.videoID;
    }

    // events
    on(name, callback) {
        this.userEventsList = this.userEventsList || [];

        // add new callback in events list
        (this.userEventsList[name] || (this.userEventsList[name] = [])).push(callback);
    }
    off(name, callback) {
        if (!this.userEventsList || !this.userEventsList[name]) {
            return;
        }

        if (!callback) {
            delete this.userEventsList[name];
        } else {
            this.userEventsList[name].forEach((val, key) => {
                if (val === callback) {
                    this.userEventsList[name][key] = false;
                }
            });
        }
    }
    fire(name) {
        const args = [].slice.call(arguments, 1);
        if (this.userEventsList && typeof this.userEventsList[name] !== 'undefined') {
            this.userEventsList[name].forEach((val) => {
                // call with all arguments
                if (val) {
                    val.apply(this, args);
                }
            });
        }
    }

    play(start) {
        const self = this;
        if (!self.player) {
            return;
        }

        if (self.type === 'youtube' && self.player.playVideo) {
            if (typeof start !== 'undefined') {
                self.player.seekTo(start || 0);
            }
            if (YT.PlayerState.PLAYING !== self.player.getPlayerState()) {
                self.player.playVideo();
            }
        }

        if (self.type === 'vimeo') {
            if (typeof start !== 'undefined') {
                self.player.setCurrentTime(start);
            }
            self.player.getPaused().then((paused) => {
                if (paused) {
                    self.player.play();
                }
            });
        }

        if (self.type === 'local') {
            if (typeof start !== 'undefined') {
                self.player.currentTime = start;
            }
            if (self.player.paused) {
                self.player.play();
            }
        }
    }

    pause() {
        const self = this;
        if (!self.player) {
            return;
        }

        if (self.type === 'youtube' && self.player.pauseVideo) {
            if (YT.PlayerState.PLAYING === self.player.getPlayerState()) {
                self.player.pauseVideo();
            }
        }

        if (self.type === 'vimeo') {
            self.player.getPaused().then((paused) => {
                if (!paused) {
                    self.player.pause();
                }
            });
        }

        if (self.type === 'local') {
            if (!self.player.paused) {
                self.player.pause();
            }
        }
    }

    mute() {
        const self = this;
        if (!self.player) {
            return;
        }

        if (self.type === 'youtube' && self.player.mute) {
            self.player.mute();
        }

        if (self.type === 'vimeo' && self.player.setVolume) {
            self.player.setVolume(0);
        }

        if (self.type === 'local') {
            self.$video.muted = true;
        }
    }

    unmute() {
        const self = this;
        if (!self.player) {
            return;
        }

        if (self.type === 'youtube' && self.player.mute) {
            self.player.unMute();
        }

        if (self.type === 'vimeo' && self.player.setVolume) {
            self.player.setVolume(self.options.volume);
        }

        if (self.type === 'local') {
            self.$video.muted = false;
        }
    }

    setVolume(volume = false) {
        const self = this;
        if (!self.player || !volume) {
            return;
        }

        if (self.type === 'youtube' && self.player.setVolume) {
            self.player.setVolume(volume);
        }

        if (self.type === 'vimeo' && self.player.setVolume) {
            self.player.setVolume(volume);
        }

        if (self.type === 'local') {
            self.$video.volume = volume / 100;
        }
    }

    getVolume(callback) {
        const self = this;
        if (!self.player) {
            callback(false);
            return;
        }

        if (self.type === 'youtube' && self.player.getVolume) {
            callback(self.player.getVolume());
        }

        if (self.type === 'vimeo' && self.player.getVolume) {
            self.player.getVolume().then((volume) => {
                callback(volume);
            });
        }

        if (self.type === 'local') {
            callback(self.$video.volume * 100);
        }
    }

    getMuted(callback) {
        const self = this;
        if (!self.player) {
            callback(null);
            return;
        }

        if (self.type === 'youtube' && self.player.isMuted) {
            callback(self.player.isMuted());
        }

        if (self.type === 'vimeo' && self.player.getVolume) {
            self.player.getVolume().then((volume) => {
                callback(!!volume);
            });
        }

        if (self.type === 'local') {
            callback(self.$video.muted);
        }
    }

    getImageURL(callback) {
        const self = this;

        if (self.videoImage) {
            callback(self.videoImage);
            return;
        }

        if (self.type === 'youtube') {
            const availableSizes = [
                'maxresdefault',
                'sddefault',
                'hqdefault',
                '0',
            ];
            let step = 0;

            const tempImg = new Image();
            tempImg.onload = function () {
                // if no thumbnail, youtube add their own image with width = 120px
                if ((this.naturalWidth || this.width) !== 120 || step === availableSizes.length - 1) {
                    // ok
                    self.videoImage = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;
                    callback(self.videoImage);
                } else {
                    // try another size
                    step++;
                    this.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;
                }
            };
            tempImg.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;
        }

        if (self.type === 'vimeo') {
            let request = new XMLHttpRequest();
            request.open('GET', `https://vimeo.com/api/v2/video/${self.videoID}.json`, true);
            request.onreadystatechange = function () {
                if (this.readyState === 4) {
                    if (this.status >= 200 && this.status < 400) {
                        // Success!
                        const response = JSON.parse(this.responseText);
                        self.videoImage = response[0].thumbnail_large;
                        callback(self.videoImage);
                    } else {
                        // Error :(
                    }
                }
            };
            request.send();
            request = null;
        }
    }

    // fallback to the old version.
    getIframe(callback) {
        this.getVideo(callback);
    }

    getVideo(callback) {
        const self = this;

        // return generated video block
        if (self.$video) {
            callback(self.$video);
            return;
        }

        // generate new video block
        self.onAPIready(() => {
            let hiddenDiv;
            if (!self.$video) {
                hiddenDiv = document.createElement('div');
                hiddenDiv.style.display = 'none';
            }

            // Youtube
            if (self.type === 'youtube') {
                self.playerOptions = {};
                self.playerOptions.videoId = self.videoID;
                self.playerOptions.playerVars = {
                    autohide: 1,
                    rel: 0,
                    autoplay: 0,
                    // autoplay enable on mobile devices
                    playsinline: 1,
                };

                // hide controls
                if (!self.options.showContols) {
                    self.playerOptions.playerVars.iv_load_policy = 3;
                    self.playerOptions.playerVars.modestbranding = 1;
                    self.playerOptions.playerVars.controls = 0;
                    self.playerOptions.playerVars.showinfo = 0;
                    self.playerOptions.playerVars.disablekb = 1;
                }

                // events
                let ytStarted;
                let ytProgressInterval;
                self.playerOptions.events = {
                    onReady(e) {
                        // mute
                        if (self.options.mute) {
                            e.target.mute();
                        } else if (self.options.volume) {
                            e.target.setVolume(self.options.volume);
                        }

                        // autoplay
                        if (self.options.autoplay) {
                            self.play(self.options.startTime);
                        }
                        self.fire('ready', e);

                        // For seamless loops, set the endTime to 0.1 seconds less than the video's duration
                        // https://github.com/nk-o/video-worker/issues/2
                        if (self.options.loop && !self.options.endTime) {
                            const secondsOffset = 0.1;
                            self.options.endTime = self.player.getDuration() - secondsOffset;
                        }

                        // volumechange
                        setInterval(() => {
                            self.getVolume((volume) => {
                                if (self.options.volume !== volume) {
                                    self.options.volume = volume;
                                    self.fire('volumechange', e);
                                }
                            });
                        }, 150);
                    },
                    onStateChange(e) {
                        // loop
                        if (self.options.loop && e.data === YT.PlayerState.ENDED) {
                            self.play(self.options.startTime);
                        }
                        if (!ytStarted && e.data === YT.PlayerState.PLAYING) {
                            ytStarted = 1;
                            self.fire('started', e);
                        }
                        if (e.data === YT.PlayerState.PLAYING) {
                            self.fire('play', e);
                        }
                        if (e.data === YT.PlayerState.PAUSED) {
                            self.fire('pause', e);
                        }
                        if (e.data === YT.PlayerState.ENDED) {
                            self.fire('ended', e);
                        }

                        // progress check
                        if (e.data === YT.PlayerState.PLAYING) {
                            ytProgressInterval = setInterval(() => {
                                self.fire('timeupdate', e);

                                // check for end of video and play again or stop
                                if (self.options.endTime && self.player.getCurrentTime() >= self.options.endTime) {
                                    if (self.options.loop) {
                                        self.play(self.options.startTime);
                                    } else {
                                        self.pause();
                                    }
                                }
                            }, 150);
                        } else {
                            clearInterval(ytProgressInterval);
                        }
                    },
                };

                const firstInit = !self.$video;
                if (firstInit) {
                    const div = document.createElement('div');
                    div.setAttribute('id', self.playerID);
                    hiddenDiv.appendChild(div);
                    document.body.appendChild(hiddenDiv);
                }
                self.player = self.player || new window.YT.Player(self.playerID, self.playerOptions);
                if (firstInit) {
                    self.$video = document.getElementById(self.playerID);

                    // get video width and height
                    self.videoWidth = parseInt(self.$video.getAttribute('width'), 10) || 1280;
                    self.videoHeight = parseInt(self.$video.getAttribute('height'), 10) || 720;
                }
            }

            // Vimeo
            if (self.type === 'vimeo') {
                self.playerOptions = {
                    id: self.videoID,
                    autopause: 0,
                    transparent: 0,
                    autoplay: self.options.autoplay ? 1 : 0,
                    loop: self.options.loop ? 1 : 0,
                    muted: self.options.mute ? 1 : 0,
                };

                if (self.options.volume) {
                    self.playerOptions.volume = self.options.volume;
                }

                // hide controls
                if (!self.options.showContols) {
                    self.playerOptions.badge = 0;
                    self.playerOptions.byline = 0;
                    self.playerOptions.portrait = 0;
                    self.playerOptions.title = 0;
                }


                if (!self.$video) {
                    let playerOptionsString = '';
                    Object.keys(self.playerOptions).forEach((key) => {
                        if (playerOptionsString !== '') {
                            playerOptionsString += '&';
                        }
                        playerOptionsString += `${key}=${encodeURIComponent(self.playerOptions[key])}`;
                    });

                    // we need to create iframe manually because when we create it using API
                    // js events won't triggers after iframe moved to another place
                    self.$video = document.createElement('iframe');
                    self.$video.setAttribute('id', self.playerID);
                    self.$video.setAttribute('src', `https://player.vimeo.com/video/${self.videoID}?${playerOptionsString}`);
                    self.$video.setAttribute('frameborder', '0');
                    self.$video.setAttribute('mozallowfullscreen', '');
                    self.$video.setAttribute('allowfullscreen', '');

                    hiddenDiv.appendChild(self.$video);
                    document.body.appendChild(hiddenDiv);
                }
                self.player = self.player || new Vimeo.Player(self.$video, self.playerOptions);

                // set current time for autoplay
                if (self.options.startTime && self.options.autoplay) {
                    self.player.setCurrentTime(self.options.startTime);
                }

                // get video width and height
                self.player.getVideoWidth().then((width) => {
                    self.videoWidth = width || 1280;
                });
                self.player.getVideoHeight().then((height) => {
                    self.videoHeight = height || 720;
                });

                // events
                let vmStarted;
                self.player.on('timeupdate', (e) => {
                    if (!vmStarted) {
                        self.fire('started', e);
                        vmStarted = 1;
                    }

                    self.fire('timeupdate', e);

                    // check for end of video and play again or stop
                    if (self.options.endTime) {
                        if (self.options.endTime && e.seconds >= self.options.endTime) {
                            if (self.options.loop) {
                                self.play(self.options.startTime);
                            } else {
                                self.pause();
                            }
                        }
                    }
                });
                self.player.on('play', (e) => {
                    self.fire('play', e);

                    // check for the start time and start with it
                    if (self.options.startTime && e.seconds === 0) {
                        self.play(self.options.startTime);
                    }
                });
                self.player.on('pause', (e) => {
                    self.fire('pause', e);
                });
                self.player.on('ended', (e) => {
                    self.fire('ended', e);
                });
                self.player.on('loaded', (e) => {
                    self.fire('ready', e);
                });
                self.player.on('volumechange', (e) => {
                    self.fire('volumechange', e);
                });
            }

            // Local
            function addSourceToLocal(element, src, type) {
                const source = document.createElement('source');
                source.src = src;
                source.type = type;
                element.appendChild(source);
            }
            if (self.type === 'local') {
                if (!self.$video) {
                    self.$video = document.createElement('video');

                    // show controls
                    if (self.options.showContols) {
                        self.$video.controls = true;
                    }

                    // mute
                    if (self.options.mute) {
                        self.$video.muted = true;
                    } else if (self.$video.volume) {
                        self.$video.volume = self.options.volume / 100;
                    }

                    // loop
                    if (self.options.loop) {
                        self.$video.loop = true;
                    }

                    // autoplay enable on mobile devices
                    self.$video.setAttribute('playsinline', '');
                    self.$video.setAttribute('webkit-playsinline', '');

                    self.$video.setAttribute('id', self.playerID);
                    hiddenDiv.appendChild(self.$video);
                    document.body.appendChild(hiddenDiv);

                    Object.keys(self.videoID).forEach((key) => {
                        addSourceToLocal(self.$video, self.videoID[key], `video/${key}`);
                    });
                }

                self.player = self.player || self.$video;

                let locStarted;
                self.player.addEventListener('playing', (e) => {
                    if (!locStarted) {
                        self.fire('started', e);
                    }
                    locStarted = 1;
                });
                self.player.addEventListener('timeupdate', function (e) {
                    self.fire('timeupdate', e);

                    // check for end of video and play again or stop
                    if (self.options.endTime) {
                        if (self.options.endTime && this.currentTime >= self.options.endTime) {
                            if (self.options.loop) {
                                self.play(self.options.startTime);
                            } else {
                                self.pause();
                            }
                        }
                    }
                });
                self.player.addEventListener('play', (e) => {
                    self.fire('play', e);
                });
                self.player.addEventListener('pause', (e) => {
                    self.fire('pause', e);
                });
                self.player.addEventListener('ended', (e) => {
                    self.fire('ended', e);
                });
                self.player.addEventListener('loadedmetadata', function () {
                    // get video width and height
                    self.videoWidth = this.videoWidth || 1280;
                    self.videoHeight = this.videoHeight || 720;

                    self.fire('ready');

                    // autoplay
                    if (self.options.autoplay) {
                        self.play(self.options.startTime);
                    }
                });
                self.player.addEventListener('volumechange', (e) => {
                    self.getVolume((volume) => {
                        self.options.volume = volume;
                    });
                    self.fire('volumechange', e);
                });
            }
            callback(self.$video);
        });
    }

    init() {
        const self = this;

        self.playerID = `VideoWorker-${self.ID}`;
    }

    loadAPI() {
        const self = this;

        if (YoutubeAPIadded && VimeoAPIadded) {
            return;
        }

        let src = '';

        // load Youtube API
        if (self.type === 'youtube' && !YoutubeAPIadded) {
            YoutubeAPIadded = 1;
            src = 'https://www.youtube.com/iframe_api';
        }

        // load Vimeo API
        if (self.type === 'vimeo' && !VimeoAPIadded) {
            VimeoAPIadded = 1;
            src = 'https://player.vimeo.com/api/player.js';
        }

        if (!src) {
            return;
        }

        // add script in head section
        let tag = document.createElement('script');
        let head = document.getElementsByTagName('head')[0];
        tag.src = src;

        head.appendChild(tag);

        head = null;
        tag = null;
    }

    onAPIready(callback) {
        const self = this;

        // Youtube
        if (self.type === 'youtube') {
            // Listen for global YT player callback
            if ((typeof YT === 'undefined' || YT.loaded === 0) && !loadingYoutubePlayer) {
                // Prevents Ready event from being called twice
                loadingYoutubePlayer = 1;

                // Creates deferred so, other players know when to wait.
                window.onYouTubeIframeAPIReady = function () {
                    window.onYouTubeIframeAPIReady = null;
                    loadingYoutubeDefer.resolve('done');
                    callback();
                };
            } else if (typeof YT === 'object' && YT.loaded === 1) {
                callback();
            } else {
                loadingYoutubeDefer.done(() => {
                    callback();
                });
            }
        }

        // Vimeo
        if (self.type === 'vimeo') {
            if (typeof Vimeo === 'undefined' && !loadingVimeoPlayer) {
                loadingVimeoPlayer = 1;
                const vimeoInterval = setInterval(() => {
                    if (typeof Vimeo !== 'undefined') {
                        clearInterval(vimeoInterval);
                        loadingVimeoDefer.resolve('done');
                        callback();
                    }
                }, 20);
            } else if (typeof Vimeo !== 'undefined') {
                callback();
            } else {
                loadingVimeoDefer.done(() => {
                    callback();
                });
            }
        }

        // Local
        if (self.type === 'local') {
            callback();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["default"] = VideoWorker;



/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = jarallaxElement;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_global__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_global___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_global__);
/* eslint no-case-declarations: "off" */


function jarallaxElement(jarallax = __WEBPACK_IMPORTED_MODULE_0_global___default.a.jarallax) {
    if (typeof jarallax === 'undefined') {
        return;
    }

    const Jarallax = jarallax.constructor;

    // redefine default methods
    [
        'initImg',
        'canInitParallax',
        'init',
        'destroy',
        'clipContainer',
        'coverImage',
        'isVisible',
        'onScroll',
        'onResize',
    ].forEach((key) => {
        const def = Jarallax.prototype[key];
        Jarallax.prototype[key] = function () {
            const self = this;
            const args = arguments || [];

            if (key === 'initImg' && self.$item.getAttribute('data-jarallax-element') !== null) {
                self.options.type = 'element';
                self.pureOptions.speed = self.$item.getAttribute('data-jarallax-element') || self.pureOptions.speed;
            }
            if (self.options.type !== 'element') {
                return def.apply(self, args);
            }

            self.pureOptions.threshold = self.$item.getAttribute('data-threshold') || '';

            switch (key) {
            case 'init':
                const speedArr = self.pureOptions.speed.split(' ');
                self.options.speed = self.pureOptions.speed || 0;
                self.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;
                self.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;

                const thresholdArr = self.pureOptions.threshold.split(' ');
                self.options.thresholdY = thresholdArr[0] ? parseFloat(thresholdArr[0]) : null;
                self.options.thresholdX = thresholdArr[1] ? parseFloat(thresholdArr[1]) : null;
                break;
            case 'onResize':
                const defTransform = self.css(self.$item, 'transform');
                self.css(self.$item, { transform: '' });
                const rect = self.$item.getBoundingClientRect();
                self.itemData = {
                    width: rect.width,
                    height: rect.height,
                    y: rect.top + self.getWindowData().y,
                    x: rect.left,
                };
                self.css(self.$item, { transform: defTransform });
                break;
            case 'onScroll':
                const wnd = self.getWindowData();
                const centerPercent = (wnd.y + wnd.height / 2 - self.itemData.y - self.itemData.height / 2) / (wnd.height / 2);
                const moveY = centerPercent * self.options.speedY;
                const moveX = centerPercent * self.options.speedX;
                let my = moveY;
                let mx = moveX;
                if (self.options.thresholdY !== null && moveY > self.options.thresholdY) my = 0;
                if (self.options.thresholdX !== null && moveX > self.options.thresholdX) mx = 0;
                self.css(self.$item, { transform: `translate3d(${mx}px,${my}px,0)` });
                break;
            case 'initImg':
            case 'isVisible':
            case 'clipContainer':
            case 'coverImage':
                return true;
            // no default
            }
            return def.apply(self, args);
        };
    });
}


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Foundation = exports.ResponsiveAccordionTabs = exports.Tooltip = exports.Toggler = exports.Tabs = exports.Sticky = exports.SmoothScroll = exports.Slider = exports.Reveal = exports.ResponsiveToggle = exports.ResponsiveMenu = exports.Orbit = exports.OffCanvas = exports.Magellan = exports.Interchange = exports.Equalizer = exports.DropdownMenu = exports.Dropdown = exports.Drilldown = exports.AccordionMenu = exports.Accordion = exports.Abide = exports.Triggers = exports.Touch = exports.Timer = exports.Nest = exports.Move = exports.Motion = exports.MediaQuery = exports.Keyboard = exports.onImagesLoaded = exports.Box = exports.Core = exports.CoreUtils = undefined;

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

/**
 * Returns a boolean for RTL support
 */

function rtl() {
  return (0, _jquery2.default)('html').attr('dir') === 'rtl';
}
/**
 * returns a random base-36 uid with namespacing
 * @function
 * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
 * @param {String} namespace - name of plugin to be incorporated in uid, optional.
 * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
 * @returns {String} - unique id
 */

function GetYoDigits(length, namespace) {
  length = length || 6;
  return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? "-".concat(namespace) : '');
}
/**
 * Escape a string so it can be used as a regexp pattern
 * @function
 * @see https://stackoverflow.com/a/9310752/4317384
 *
 * @param {String} str - string to escape.
 * @returns {String} - escaped string
 */

function RegExpEscape(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

function transitionend($elem) {
  var transitions = {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'otransitionend'
  };
  var elem = document.createElement('div'),
      end;

  for (var t in transitions) {
    if (typeof elem.style[t] !== 'undefined') {
      end = transitions[t];
    }
  }

  if (end) {
    return end;
  } else {
    end = setTimeout(function () {
      $elem.triggerHandler('transitionend', [$elem]);
    }, 1);
    return 'transitionend';
  }
}
/**
 * Return an event type to listen for window load.
 *
 * If `$elem` is passed, an event will be triggered on `$elem`. If window is already loaded, the event will still be triggered.
 * If `handler` is passed, attach it to the event on `$elem`.
 * Calling `onLoad` without handler allows you to get the event type that will be triggered before attaching the handler by yourself.
 * @function
 *
 * @param {Object} [] $elem - jQuery element on which the event will be triggered if passed.
 * @param {Function} [] handler - function to attach to the event.
 * @returns {String} - event type that should or will be triggered.
 */

function onLoad($elem, handler) {
  var didLoad = document.readyState === 'complete';
  var eventType = (didLoad ? '_didLoad' : 'load') + '.zf.util.onLoad';

  var cb = function cb() {
    return $elem.triggerHandler(eventType);
  };

  if ($elem) {
    if (handler) $elem.one(eventType, handler);
    if (didLoad) setTimeout(cb);else (0, _jquery2.default)(window).one('load', cb);
  }

  return eventType;
}
/**
 * Retuns an handler for the `mouseleave` that ignore disappeared mouses.
 *
 * If the mouse "disappeared" from the document (like when going on a browser UI element, See https://git.io/zf-11410),
 * the event is ignored.
 * - If the `ignoreLeaveWindow` is `true`, the event is ignored when the user actually left the window
 *   (like by switching to an other window with [Alt]+[Tab]).
 * - If the `ignoreReappear` is `true`, the event will be ignored when the mouse will reappear later on the document
 *   outside of the element it left.
 *
 * @function
 *
 * @param {Function} [] handler - handler for the filtered `mouseleave` event to watch.
 * @param {Object} [] options - object of options:
 * - {Boolean} [false] ignoreLeaveWindow - also ignore when the user switched windows.
 * - {Boolean} [false] ignoreReappear - also ignore when the mouse reappeared outside of the element it left.
 * @returns {Function} - filtered handler to use to listen on the `mouseleave` event.
 */

function ignoreMousedisappear(handler) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$ignoreLeaveWindo = _ref.ignoreLeaveWindow,
      ignoreLeaveWindow = _ref$ignoreLeaveWindo === void 0 ? false : _ref$ignoreLeaveWindo,
      _ref$ignoreReappear = _ref.ignoreReappear,
      ignoreReappear = _ref$ignoreReappear === void 0 ? false : _ref$ignoreReappear;

  return function leaveEventHandler(eLeave) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    var callback = handler.bind.apply(handler, [this, eLeave].concat(rest)); // The mouse left: call the given callback if the mouse entered elsewhere

    if (eLeave.relatedTarget !== null) {
      return callback();
    } // Otherwise, check if the mouse actually left the window.
    // In firefox if the user switched between windows, the window sill have the focus by the time
    // the event is triggered. We have to debounce the event to test this case.


    setTimeout(function leaveEventDebouncer() {
      if (!ignoreLeaveWindow && document.hasFocus && !document.hasFocus()) {
        return callback();
      } // Otherwise, wait for the mouse to reeapear outside of the element,


      if (!ignoreReappear) {
        (0, _jquery2.default)(document).one('mouseenter', function reenterEventHandler(eReenter) {
          if (!(0, _jquery2.default)(eLeave.currentTarget).has(eReenter.target).length) {
            // Fill where the mouse finally entered.
            eLeave.relatedTarget = eReenter.target;
            callback();
          }
        });
      }
    }, 0);
  };
}

var foundation_core_utils = /*#__PURE__*/Object.freeze({
  rtl: rtl,
  GetYoDigits: GetYoDigits,
  RegExpEscape: RegExpEscape,
  transitionend: transitionend,
  onLoad: onLoad,
  ignoreMousedisappear: ignoreMousedisappear
});

// Authors & copyright(c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. MIT license

/* eslint-disable */

window.matchMedia || (window.matchMedia = function () {

  var styleMedia = window.styleMedia || window.media; // For those that don't support matchMedium

  if (!styleMedia) {
    var style = document.createElement('style'),
        script = document.getElementsByTagName('script')[0],
        info = null;
    style.type = 'text/css';
    style.id = 'matchmediajs-test';

    if (!script) {
      document.head.appendChild(style);
    } else {
      script.parentNode.insertBefore(style, script);
    } // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers


    info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;
    styleMedia = {
      matchMedium: function matchMedium(media) {
        var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }'; // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers

        if (style.styleSheet) {
          style.styleSheet.cssText = text;
        } else {
          style.textContent = text;
        } // Test if media query is true or false


        return info.width === '1px';
      }
    };
  }

  return function (media) {
    return {
      matches: styleMedia.matchMedium(media || 'all'),
      media: media || 'all'
    };
  };
}());
/* eslint-enable */

var MediaQuery = {
  queries: [],
  current: '',

  /**
   * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
   * @function
   * @private
   */
  _init: function _init() {
    var self = this;
    var $meta = (0, _jquery2.default)('meta.foundation-mq');

    if (!$meta.length) {
      (0, _jquery2.default)('<meta class="foundation-mq">').appendTo(document.head);
    }

    var extractedStyles = (0, _jquery2.default)('.foundation-mq').css('font-family');
    var namedQueries;
    namedQueries = parseStyleToObject(extractedStyles);

    for (var key in namedQueries) {
      if (namedQueries.hasOwnProperty(key)) {
        self.queries.push({
          name: key,
          value: "only screen and (min-width: ".concat(namedQueries[key], ")")
        });
      }
    }

    this.current = this._getCurrentSize();

    this._watcher();
  },

  /**
   * Checks if the screen is at least as wide as a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to check.
   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
   */
  atLeast: function atLeast(size) {
    var query = this.get(size);

    if (query) {
      return window.matchMedia(query).matches;
    }

    return false;
  },

  /**
   * Checks if the screen matches to a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to check, either 'small only' or 'small'. Omitting 'only' falls back to using atLeast() method.
   * @returns {Boolean} `true` if the breakpoint matches, `false` if it does not.
   */
  is: function is(size) {
    size = size.trim().split(' ');

    if (size.length > 1 && size[1] === 'only') {
      if (size[0] === this._getCurrentSize()) return true;
    } else {
      return this.atLeast(size[0]);
    }

    return false;
  },

  /**
   * Gets the media query of a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to get.
   * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
   */
  get: function get(size) {
    for (var i in this.queries) {
      if (this.queries.hasOwnProperty(i)) {
        var query = this.queries[i];
        if (size === query.name) return query.value;
      }
    }

    return null;
  },

  /**
   * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
   * @function
   * @private
   * @returns {String} Name of the current breakpoint.
   */
  _getCurrentSize: function _getCurrentSize() {
    var matched;

    for (var i = 0; i < this.queries.length; i++) {
      var query = this.queries[i];

      if (window.matchMedia(query.value).matches) {
        matched = query;
      }
    }

    if (_typeof(matched) === 'object') {
      return matched.name;
    } else {
      return matched;
    }
  },

  /**
   * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
   * @function
   * @private
   */
  _watcher: function _watcher() {
    var _this = this;

    (0, _jquery2.default)(window).off('resize.zf.mediaquery').on('resize.zf.mediaquery', function () {
      var newSize = _this._getCurrentSize(),
          currentSize = _this.current;

      if (newSize !== currentSize) {
        // Change the current media query
        _this.current = newSize; // Broadcast the media query change on the window

        (0, _jquery2.default)(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);
      }
    });
  }
}; // Thank you: https://github.com/sindresorhus/query-string

function parseStyleToObject(str) {
  var styleObject = {};

  if (typeof str !== 'string') {
    return styleObject;
  }

  str = str.trim().slice(1, -1); // browsers re-quote string style values

  if (!str) {
    return styleObject;
  }

  styleObject = str.split('&').reduce(function (ret, param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = parts[0];
    var val = parts[1];
    key = decodeURIComponent(key); // missing `=` should be `null`:
    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters

    val = typeof val === 'undefined' ? null : decodeURIComponent(val);

    if (!ret.hasOwnProperty(key)) {
      ret[key] = val;
    } else if (Array.isArray(ret[key])) {
      ret[key].push(val);
    } else {
      ret[key] = [ret[key], val];
    }

    return ret;
  }, {});
  return styleObject;
}

var FOUNDATION_VERSION = '6.5.1'; // Global Foundation object
// This is attached to the window, or used as a module for AMD/Browserify

var Foundation = {
  version: FOUNDATION_VERSION,

  /**
   * Stores initialized plugins.
   */
  _plugins: {},

  /**
   * Stores generated unique ids for plugin instances
   */
  _uuids: [],

  /**
   * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
   * @param {Object} plugin - The constructor of the plugin.
   */
  plugin: function plugin(_plugin, name) {
    // Object key to use when adding to global Foundation object
    // Examples: Foundation.Reveal, Foundation.OffCanvas
    var className = name || functionName(_plugin); // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
    // Examples: data-reveal, data-off-canvas

    var attrName = hyphenate(className); // Add to the Foundation object and the plugins list (for reflowing)

    this._plugins[attrName] = this[className] = _plugin;
  },

  /**
   * @function
   * Populates the _uuids array with pointers to each individual plugin instance.
   * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.
   * Also fires the initialization event for each plugin, consolidating repetitive code.
   * @param {Object} plugin - an instance of a plugin, usually `this` in context.
   * @param {String} name - the name of the plugin, passed as a camelCased string.
   * @fires Plugin#init
   */
  registerPlugin: function registerPlugin(plugin, name) {
    var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();
    plugin.uuid = GetYoDigits(6, pluginName);

    if (!plugin.$element.attr("data-".concat(pluginName))) {
      plugin.$element.attr("data-".concat(pluginName), plugin.uuid);
    }

    if (!plugin.$element.data('zfPlugin')) {
      plugin.$element.data('zfPlugin', plugin);
    }
    /**
     * Fires when the plugin has initialized.
     * @event Plugin#init
     */

    plugin.$element.trigger("init.zf.".concat(pluginName));

    this._uuids.push(plugin.uuid);

    return;
  },

  /**
   * @function
   * Removes the plugins uuid from the _uuids array.
   * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.
   * Also fires the destroyed event for the plugin, consolidating repetitive code.
   * @param {Object} plugin - an instance of a plugin, usually `this` in context.
   * @fires Plugin#destroyed
   */
  unregisterPlugin: function unregisterPlugin(plugin) {
    var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));

    this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);

    plugin.$element.removeAttr("data-".concat(pluginName)).removeData('zfPlugin')
    /**
     * Fires when the plugin has been destroyed.
     * @event Plugin#destroyed
     */
    .trigger("destroyed.zf.".concat(pluginName));

    for (var prop in plugin) {
      plugin[prop] = null; //clean up script to prep for garbage collection.
    }

    return;
  },

  /**
   * @function
   * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
   * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
   * @default If no argument is passed, reflow all currently active plugins.
   */
  reInit: function reInit(plugins) {
    var isJQ = plugins instanceof _jquery2.default;

    try {
      if (isJQ) {
        plugins.each(function () {
          (0, _jquery2.default)(this).data('zfPlugin')._init();
        });
      } else {
        var type = _typeof(plugins),
            _this = this,
            fns = {
          'object': function object(plgs) {
            plgs.forEach(function (p) {
              p = hyphenate(p);
              (0, _jquery2.default)('[data-' + p + ']').foundation('_init');
            });
          },
          'string': function string() {
            plugins = hyphenate(plugins);
            (0, _jquery2.default)('[data-' + plugins + ']').foundation('_init');
          },
          'undefined': function undefined() {
            this['object'](Object.keys(_this._plugins));
          }
        };

        fns[type](plugins);
      }
    } catch (err) {
      console.error(err);
    } finally {
      return plugins;
    }
  },

  /**
   * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
   * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
   * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
   */
  reflow: function reflow(elem, plugins) {
    // If plugins is undefined, just grab everything
    if (typeof plugins === 'undefined') {
      plugins = Object.keys(this._plugins);
    } // If plugins is a string, convert it to an array with one item
    else if (typeof plugins === 'string') {
        plugins = [plugins];
      }

    var _this = this; // Iterate through each plugin


    _jquery2.default.each(plugins, function (i, name) {
      // Get the current plugin
      var plugin = _this._plugins[name]; // Localize the search to all elements inside elem, as well as elem itself, unless elem === document

      var $elem = (0, _jquery2.default)(elem).find('[data-' + name + ']').addBack('[data-' + name + ']'); // For each plugin found, initialize it

      $elem.each(function () {
        var $el = (0, _jquery2.default)(this),
            opts = {}; // Don't double-dip on plugins

        if ($el.data('zfPlugin')) {
          console.warn("Tried to initialize " + name + " on an element that already has a Foundation plugin.");
          return;
        }

        if ($el.attr('data-options')) {
          var thing = $el.attr('data-options').split(';').forEach(function (e, i) {
            var opt = e.split(':').map(function (el) {
              return el.trim();
            });
            if (opt[0]) opts[opt[0]] = parseValue(opt[1]);
          });
        }

        try {
          $el.data('zfPlugin', new plugin((0, _jquery2.default)(this), opts));
        } catch (er) {
          console.error(er);
        } finally {
          return;
        }
      });
    });
  },
  getFnName: functionName,
  addToJquery: function addToJquery($$$1) {
    // TODO: consider not making this a jQuery function
    // TODO: need way to reflow vs. re-initialize

    /**
     * The Foundation jQuery method.
     * @param {String|Array} method - An action to perform on the current jQuery object.
     */
    var foundation = function foundation(method) {
      var type = _typeof(method),
          $noJS = $$$1('.no-js');

      if ($noJS.length) {
        $noJS.removeClass('no-js');
      }

      if (type === 'undefined') {
        //needs to initialize the Foundation object, or an individual plugin.
        MediaQuery._init();

        Foundation.reflow(this);
      } else if (type === 'string') {
        //an individual method to invoke on a plugin or group of plugins
        var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary

        var plugClass = this.data('zfPlugin'); //determine the class of plugin

        if (typeof plugClass !== 'undefined' && typeof plugClass[method] !== 'undefined') {
          //make sure both the class and method exist
          if (this.length === 1) {
            //if there's only one, call it directly.
            plugClass[method].apply(plugClass, args);
          } else {
            this.each(function (i, el) {
              //otherwise loop through the jQuery collection and invoke the method on each
              plugClass[method].apply($$$1(el).data('zfPlugin'), args);
            });
          }
        } else {
          //error for no class or no method
          throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
        }
      } else {
        //error for invalid argument type
        throw new TypeError("We're sorry, ".concat(type, " is not a valid parameter. You must use a string representing the method you wish to invoke."));
      }

      return this;
    };

    $$$1.fn.foundation = foundation;
    return $$$1;
  }
};
Foundation.util = {
  /**
   * Function for applying a debounce effect to a function call.
   * @function
   * @param {Function} func - Function to be called at end of timeout.
   * @param {Number} delay - Time in ms to delay the call of `func`.
   * @returns function
   */
  throttle: function throttle(func, delay) {
    var timer = null;
    return function () {
      var context = this,
          args = arguments;

      if (timer === null) {
        timer = setTimeout(function () {
          func.apply(context, args);
          timer = null;
        }, delay);
      }
    };
  }
};
window.Foundation = Foundation; // Polyfill for requestAnimationFrame

(function () {
  if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {
    return new Date().getTime();
  };
  var vendors = ['webkit', 'moz'];

  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
    var vp = vendors[i];
    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
  }

  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
    var lastTime = 0;

    window.requestAnimationFrame = function (callback) {
      var now = Date.now();
      var nextTime = Math.max(lastTime + 16, now);
      return setTimeout(function () {
        callback(lastTime = nextTime);
      }, nextTime - now);
    };

    window.cancelAnimationFrame = clearTimeout;
  }
  /**
   * Polyfill for performance.now, required by rAF
   */

  if (!window.performance || !window.performance.now) {
    window.performance = {
      start: Date.now(),
      now: function now() {
        return Date.now() - this.start;
      }
    };
  }
})();

if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function fNOP() {},
        fBound = function fBound() {
      return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
    };

    if (this.prototype) {
      // native functions don't have a prototype
      fNOP.prototype = this.prototype;
    }

    fBound.prototype = new fNOP();
    return fBound;
  };
} // Polyfill to get the name of a function in IE9


function functionName(fn) {
  if (typeof Function.prototype.name === 'undefined') {
    var funcNameRegex = /function\s([^(]{1,})\(/;
    var results = funcNameRegex.exec(fn.toString());
    return results && results.length > 1 ? results[1].trim() : "";
  } else if (typeof fn.prototype === 'undefined') {
    return fn.constructor.name;
  } else {
    return fn.prototype.constructor.name;
  }
}

function parseValue(str) {
  if ('true' === str) return true;else if ('false' === str) return false;else if (!isNaN(str * 1)) return parseFloat(str);
  return str;
} // Convert PascalCase to kebab-case
// Thank you: http://stackoverflow.com/a/8955580


function hyphenate(str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

var Box = {
  ImNotTouchingYou: ImNotTouchingYou,
  OverlapArea: OverlapArea,
  GetDimensions: GetDimensions,
  GetOffsets: GetOffsets,
  GetExplicitOffsets: GetExplicitOffsets
  /**
   * Compares the dimensions of an element to a container and determines collision events with container.
   * @function
   * @param {jQuery} element - jQuery object to test for collisions.
   * @param {jQuery} parent - jQuery object to use as bounding container.
   * @param {Boolean} lrOnly - set to true to check left and right values only.
   * @param {Boolean} tbOnly - set to true to check top and bottom values only.
   * @default if no parent object passed, detects collisions with `window`.
   * @returns {Boolean} - true if collision free, false if a collision in any direction.
   */

};

function ImNotTouchingYou(element, parent, lrOnly, tbOnly, ignoreBottom) {
  return OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) === 0;
}

function OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) {
  var eleDims = GetDimensions(element),
      topOver,
      bottomOver,
      leftOver,
      rightOver;

  if (parent) {
    var parDims = GetDimensions(parent);
    bottomOver = parDims.height + parDims.offset.top - (eleDims.offset.top + eleDims.height);
    topOver = eleDims.offset.top - parDims.offset.top;
    leftOver = eleDims.offset.left - parDims.offset.left;
    rightOver = parDims.width + parDims.offset.left - (eleDims.offset.left + eleDims.width);
  } else {
    bottomOver = eleDims.windowDims.height + eleDims.windowDims.offset.top - (eleDims.offset.top + eleDims.height);
    topOver = eleDims.offset.top - eleDims.windowDims.offset.top;
    leftOver = eleDims.offset.left - eleDims.windowDims.offset.left;
    rightOver = eleDims.windowDims.width - (eleDims.offset.left + eleDims.width);
  }

  bottomOver = ignoreBottom ? 0 : Math.min(bottomOver, 0);
  topOver = Math.min(topOver, 0);
  leftOver = Math.min(leftOver, 0);
  rightOver = Math.min(rightOver, 0);

  if (lrOnly) {
    return leftOver + rightOver;
  }

  if (tbOnly) {
    return topOver + bottomOver;
  } // use sum of squares b/c we care about overlap area.


  return Math.sqrt(topOver * topOver + bottomOver * bottomOver + leftOver * leftOver + rightOver * rightOver);
}
/**
 * Uses native methods to return an object of dimension values.
 * @function
 * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
 * @returns {Object} - nested object of integer pixel values
 * TODO - if element is window, return only those values.
 */

function GetDimensions(elem) {
  elem = elem.length ? elem[0] : elem;

  if (elem === window || elem === document) {
    throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
  }

  var rect = elem.getBoundingClientRect(),
      parRect = elem.parentNode.getBoundingClientRect(),
      winRect = document.body.getBoundingClientRect(),
      winY = window.pageYOffset,
      winX = window.pageXOffset;
  return {
    width: rect.width,
    height: rect.height,
    offset: {
      top: rect.top + winY,
      left: rect.left + winX
    },
    parentDims: {
      width: parRect.width,
      height: parRect.height,
      offset: {
        top: parRect.top + winY,
        left: parRect.left + winX
      }
    },
    windowDims: {
      width: winRect.width,
      height: winRect.height,
      offset: {
        top: winY,
        left: winX
      }
    }
  };
}
/**
 * Returns an object of top and left integer pixel values for dynamically rendered elements,
 * such as: Tooltip, Reveal, and Dropdown. Maintained for backwards compatibility, and where
 * you don't know alignment, but generally from
 * 6.4 forward you should use GetExplicitOffsets, as GetOffsets conflates position and alignment.
 * @function
 * @param {jQuery} element - jQuery object for the element being positioned.
 * @param {jQuery} anchor - jQuery object for the element's anchor point.
 * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
 * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
 * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
 * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
 * TODO alter/rewrite to work with `em` values as well/instead of pixels
 */

function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {
  console.log("NOTE: GetOffsets is deprecated in favor of GetExplicitOffsets and will be removed in 6.5");

  switch (position) {
    case 'top':
      return rtl() ? GetExplicitOffsets(element, anchor, 'top', 'left', vOffset, hOffset, isOverflow) : GetExplicitOffsets(element, anchor, 'top', 'right', vOffset, hOffset, isOverflow);

    case 'bottom':
      return rtl() ? GetExplicitOffsets(element, anchor, 'bottom', 'left', vOffset, hOffset, isOverflow) : GetExplicitOffsets(element, anchor, 'bottom', 'right', vOffset, hOffset, isOverflow);

    case 'center top':
      return GetExplicitOffsets(element, anchor, 'top', 'center', vOffset, hOffset, isOverflow);

    case 'center bottom':
      return GetExplicitOffsets(element, anchor, 'bottom', 'center', vOffset, hOffset, isOverflow);

    case 'center left':
      return GetExplicitOffsets(element, anchor, 'left', 'center', vOffset, hOffset, isOverflow);

    case 'center right':
      return GetExplicitOffsets(element, anchor, 'right', 'center', vOffset, hOffset, isOverflow);

    case 'left bottom':
      return GetExplicitOffsets(element, anchor, 'bottom', 'left', vOffset, hOffset, isOverflow);

    case 'right bottom':
      return GetExplicitOffsets(element, anchor, 'bottom', 'right', vOffset, hOffset, isOverflow);
    // Backwards compatibility... this along with the reveal and reveal full
    // classes are the only ones that didn't reference anchor

    case 'center':
      return {
        left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2 + hOffset,
        top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - ($eleDims.height / 2 + vOffset)
      };

    case 'reveal':
      return {
        left: ($eleDims.windowDims.width - $eleDims.width) / 2 + hOffset,
        top: $eleDims.windowDims.offset.top + vOffset
      };

    case 'reveal full':
      return {
        left: $eleDims.windowDims.offset.left,
        top: $eleDims.windowDims.offset.top
      };
      break;

    default:
      return {
        left: rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width - hOffset : $anchorDims.offset.left + hOffset,
        top: $anchorDims.offset.top + $anchorDims.height + vOffset
      };
  }
}

function GetExplicitOffsets(element, anchor, position, alignment, vOffset, hOffset, isOverflow) {
  var $eleDims = GetDimensions(element),
      $anchorDims = anchor ? GetDimensions(anchor) : null;
  var topVal, leftVal; // set position related attribute

  switch (position) {
    case 'top':
      topVal = $anchorDims.offset.top - ($eleDims.height + vOffset);
      break;

    case 'bottom':
      topVal = $anchorDims.offset.top + $anchorDims.height + vOffset;
      break;

    case 'left':
      leftVal = $anchorDims.offset.left - ($eleDims.width + hOffset);
      break;

    case 'right':
      leftVal = $anchorDims.offset.left + $anchorDims.width + hOffset;
      break;
  } // set alignment related attribute


  switch (position) {
    case 'top':
    case 'bottom':
      switch (alignment) {
        case 'left':
          leftVal = $anchorDims.offset.left + hOffset;
          break;

        case 'right':
          leftVal = $anchorDims.offset.left - $eleDims.width + $anchorDims.width - hOffset;
          break;

        case 'center':
          leftVal = isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2 + hOffset;
          break;
      }

      break;

    case 'right':
    case 'left':
      switch (alignment) {
        case 'bottom':
          topVal = $anchorDims.offset.top - vOffset + $anchorDims.height - $eleDims.height;
          break;

        case 'top':
          topVal = $anchorDims.offset.top + vOffset;
          break;

        case 'center':
          topVal = $anchorDims.offset.top + vOffset + $anchorDims.height / 2 - $eleDims.height / 2;
          break;
      }

      break;
  }

  return {
    top: topVal,
    left: leftVal
  };
}

/**
 * Runs a callback function when images are fully loaded.
 * @param {Object} images - Image(s) to check if loaded.
 * @param {Func} callback - Function to execute when image is fully loaded.
 */

function onImagesLoaded(images, callback) {
  var unloaded = images.length;

  if (unloaded === 0) {
    callback();
  }

  images.each(function () {
    // Check if image is loaded
    if (this.complete && typeof this.naturalWidth !== 'undefined') {
      singleImageLoaded();
    } else {
      // If the above check failed, simulate loading on detached element.
      var image = new Image(); // Still count image as loaded if it finalizes with an error.

      var events = "load.zf.images error.zf.images";
      (0, _jquery2.default)(image).one(events, function me(event) {
        // Unbind the event listeners. We're using 'one' but only one of the two events will have fired.
        (0, _jquery2.default)(this).off(events, me);
        singleImageLoaded();
      });
      image.src = (0, _jquery2.default)(this).attr('src');
    }
  });

  function singleImageLoaded() {
    unloaded--;

    if (unloaded === 0) {
      callback();
    }
  }
}

/*******************************************
 *                                         *
 * This util was created by Marius Olbertz *
 * Please thank Marius on GitHub /owlbertz *
 * or the web http://www.mariusolbertz.de/ *
 *                                         *
 ******************************************/
var keyCodes = {
  9: 'TAB',
  13: 'ENTER',
  27: 'ESCAPE',
  32: 'SPACE',
  35: 'END',
  36: 'HOME',
  37: 'ARROW_LEFT',
  38: 'ARROW_UP',
  39: 'ARROW_RIGHT',
  40: 'ARROW_DOWN'
};
var commands = {}; // Functions pulled out to be referenceable from internals

function findFocusable($element) {
  if (!$element) {
    return false;
  }

  return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {
    if (!(0, _jquery2.default)(this).is(':visible') || (0, _jquery2.default)(this).attr('tabindex') < 0) {
      return false;
    } //only have visible elements and those that have a tabindex greater or equal 0


    return true;
  });
}

function parseKey(event) {
  var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase(); // Remove un-printable characters, e.g. for `fromCharCode` calls for CTRL only events

  key = key.replace(/\W+/, '');
  if (event.shiftKey) key = "SHIFT_".concat(key);
  if (event.ctrlKey) key = "CTRL_".concat(key);
  if (event.altKey) key = "ALT_".concat(key); // Remove trailing underscore, in case only modifiers were used (e.g. only `CTRL_ALT`)

  key = key.replace(/_$/, '');
  return key;
}

var Keyboard = {
  keys: getKeyCodes(keyCodes),

  /**
   * Parses the (keyboard) event and returns a String that represents its key
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   * @param {Event} event - the event generated by the event handler
   * @return String key - String that represents the key pressed
   */
  parseKey: parseKey,

  /**
   * Handles the given (keyboard) event
   * @param {Event} event - the event generated by the event handler
   * @param {String} component - Foundation component's name, e.g. Slider or Reveal
   * @param {Objects} functions - collection of functions that are to be executed
   */
  handleKey: function handleKey(event, component, functions) {
    var commandList = commands[component],
        keyCode = this.parseKey(event),
        cmds,
        command,
        fn;
    if (!commandList) return console.warn('Component not defined!');

    if (typeof commandList.ltr === 'undefined') {
      // this component does not differentiate between ltr and rtl
      cmds = commandList; // use plain list
    } else {
      // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
      if (rtl()) cmds = _jquery2.default.extend({}, commandList.ltr, commandList.rtl);else cmds = _jquery2.default.extend({}, commandList.rtl, commandList.ltr);
    }

    command = cmds[keyCode];
    fn = functions[command];

    if (fn && typeof fn === 'function') {
      // execute function  if exists
      var returnValue = fn.apply();

      if (functions.handled || typeof functions.handled === 'function') {
        // execute function when event was handled
        functions.handled(returnValue);
      }
    } else {
      if (functions.unhandled || typeof functions.unhandled === 'function') {
        // execute function when event was not handled
        functions.unhandled();
      }
    }
  },

  /**
   * Finds all focusable elements within the given `$element`
   * @param {jQuery} $element - jQuery object to search within
   * @return {jQuery} $focusable - all focusable elements within `$element`
   */
  findFocusable: findFocusable,

  /**
   * Returns the component name name
   * @param {Object} component - Foundation component, e.g. Slider or Reveal
   * @return String componentName
   */
  register: function register(componentName, cmds) {
    commands[componentName] = cmds;
  },
  // TODO9438: These references to Keyboard need to not require global. Will 'this' work in this context?
  //

  /**
   * Traps the focus in the given element.
   * @param  {jQuery} $element  jQuery object to trap the foucs into.
   */
  trapFocus: function trapFocus($element) {
    var $focusable = findFocusable($element),
        $firstFocusable = $focusable.eq(0),
        $lastFocusable = $focusable.eq(-1);
    $element.on('keydown.zf.trapfocus', function (event) {
      if (event.target === $lastFocusable[0] && parseKey(event) === 'TAB') {
        event.preventDefault();
        $firstFocusable.focus();
      } else if (event.target === $firstFocusable[0] && parseKey(event) === 'SHIFT_TAB') {
        event.preventDefault();
        $lastFocusable.focus();
      }
    });
  },

  /**
   * Releases the trapped focus from the given element.
   * @param  {jQuery} $element  jQuery object to release the focus for.
   */
  releaseFocus: function releaseFocus($element) {
    $element.off('keydown.zf.trapfocus');
  }
};
/*
 * Constants for easier comparing.
 * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
 */

function getKeyCodes(kcs) {
  var k = {};

  for (var kc in kcs) {
    k[kcs[kc]] = kcs[kc];
  }

  return k;
}

/**
 * Motion module.
 * @module foundation.motion
 */

var initClasses = ['mui-enter', 'mui-leave'];
var activeClasses = ['mui-enter-active', 'mui-leave-active'];
var Motion = {
  animateIn: function animateIn(element, animation, cb) {
    animate(true, element, animation, cb);
  },
  animateOut: function animateOut(element, animation, cb) {
    animate(false, element, animation, cb);
  }
};

function Move(duration, elem, fn) {
  var anim,
      prog,
      start = null; // console.log('called');

  if (duration === 0) {
    fn.apply(elem);
    elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
    return;
  }

  function move(ts) {
    if (!start) start = ts; // console.log(start, ts);

    prog = ts - start;
    fn.apply(elem);

    if (prog < duration) {
      anim = window.requestAnimationFrame(move, elem);
    } else {
      window.cancelAnimationFrame(anim);
      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
    }
  }

  anim = window.requestAnimationFrame(move);
}
/**
 * Animates an element in or out using a CSS transition class.
 * @function
 * @private
 * @param {Boolean} isIn - Defines if the animation is in or out.
 * @param {Object} element - jQuery or HTML object to animate.
 * @param {String} animation - CSS class to use.
 * @param {Function} cb - Callback to run when animation is finished.
 */

function animate(isIn, element, animation, cb) {
  element = (0, _jquery2.default)(element).eq(0);
  if (!element.length) return;
  var initClass = isIn ? initClasses[0] : initClasses[1];
  var activeClass = isIn ? activeClasses[0] : activeClasses[1]; // Set up the animation

  reset();
  element.addClass(animation).css('transition', 'none');
  requestAnimationFrame(function () {
    element.addClass(initClass);
    if (isIn) element.show();
  }); // Start the animation

  requestAnimationFrame(function () {
    element[0].offsetWidth;
    element.css('transition', '').addClass(activeClass);
  }); // Clean up the animation when it finishes

  element.one(transitionend(element), finish); // Hides the element (for out animations), resets the element, and runs a callback

  function finish() {
    if (!isIn) element.hide();
    reset();
    if (cb) cb.apply(element);
  } // Resets transitions and removes motion-specific classes


  function reset() {
    element[0].style.transitionDuration = 0;
    element.removeClass("".concat(initClass, " ").concat(activeClass, " ").concat(animation));
  }
}

var Nest = {
  Feather: function Feather(menu) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'zf';
    menu.attr('role', 'menubar');
    var items = menu.find('li').attr({
      'role': 'menuitem'
    }),
        subMenuClass = "is-".concat(type, "-submenu"),
        subItemClass = "".concat(subMenuClass, "-item"),
        hasSubClass = "is-".concat(type, "-submenu-parent"),
        applyAria = type !== 'accordion'; // Accordions handle their own ARIA attriutes.

    items.each(function () {
      var $item = (0, _jquery2.default)(this),
          $sub = $item.children('ul');

      if ($sub.length) {
        $item.addClass(hasSubClass);
        $sub.addClass("submenu ".concat(subMenuClass)).attr({
          'data-submenu': ''
        });

        if (applyAria) {
          $item.attr({
            'aria-haspopup': true,
            'aria-label': $item.children('a:first').text()
          }); // Note:  Drilldowns behave differently in how they hide, and so need
          // additional attributes.  We should look if this possibly over-generalized
          // utility (Nest) is appropriate when we rework menus in 6.4

          if (type === 'drilldown') {
            $item.attr({
              'aria-expanded': false
            });
          }
        }

        $sub.addClass("submenu ".concat(subMenuClass)).attr({
          'data-submenu': '',
          'role': 'menubar'
        });

        if (type === 'drilldown') {
          $sub.attr({
            'aria-hidden': true
          });
        }
      }

      if ($item.parent('[data-submenu]').length) {
        $item.addClass("is-submenu-item ".concat(subItemClass));
      }
    });
    return;
  },
  Burn: function Burn(menu, type) {
    var //items = menu.find('li'),
    subMenuClass = "is-".concat(type, "-submenu"),
        subItemClass = "".concat(subMenuClass, "-item"),
        hasSubClass = "is-".concat(type, "-submenu-parent");
    menu.find('>li, > li > ul, .menu, .menu > li, [data-submenu] > li').removeClass("".concat(subMenuClass, " ").concat(subItemClass, " ").concat(hasSubClass, " is-submenu-item submenu is-active")).removeAttr('data-submenu').css('display', '');
  }
};

function Timer(elem, options, cb) {
  var _this = this,
      duration = options.duration,

  //options is an object for easily adding features later.
  nameSpace = Object.keys(elem.data())[0] || 'timer',
      remain = -1,
      start,
      timer;

  this.isPaused = false;

  this.restart = function () {
    remain = -1;
    clearTimeout(timer);
    this.start();
  };

  this.start = function () {
    this.isPaused = false; // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.

    clearTimeout(timer);
    remain = remain <= 0 ? duration : remain;
    elem.data('paused', false);
    start = Date.now();
    timer = setTimeout(function () {
      if (options.infinite) {
        _this.restart(); //rerun the timer.
      }

      if (cb && typeof cb === 'function') {
        cb();
      }
    }, remain);
    elem.trigger("timerstart.zf.".concat(nameSpace));
  };

  this.pause = function () {
    this.isPaused = true; //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.

    clearTimeout(timer);
    elem.data('paused', true);
    var end = Date.now();
    remain = remain - (end - start);
    elem.trigger("timerpaused.zf.".concat(nameSpace));
  };
}

var Touch = {};
var startPosX,
    startPosY,
    startTime,
    elapsedTime,
    startEvent,
    isMoving = false,
    didMoved = false;

function onTouchEnd(e) {
  this.removeEventListener('touchmove', onTouchMove);
  this.removeEventListener('touchend', onTouchEnd); // If the touch did not move, consider it as a "tap"

  if (!didMoved) {
    var tapEvent = _jquery2.default.Event('tap', startEvent || e);
    (0, _jquery2.default)(this).trigger(tapEvent);
  }

  startEvent = null;
  isMoving = false;
  didMoved = false;
}

function onTouchMove(e) {
  if (_jquery2.default.spotSwipe.preventDefault) {
    e.preventDefault();
  }

  if (isMoving) {
    var x = e.touches[0].pageX;
    var y = e.touches[0].pageY;
    var dx = startPosX - x;
    var dir;
    didMoved = true;
    elapsedTime = new Date().getTime() - startTime;

    if (Math.abs(dx) >= _jquery2.default.spotSwipe.moveThreshold && elapsedTime <= _jquery2.default.spotSwipe.timeThreshold) {
      dir = dx > 0 ? 'left' : 'right';
    } // else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
    //   dir = dy > 0 ? 'down' : 'up';
    // }


    if (dir) {
      e.preventDefault();
      onTouchEnd.apply(this, arguments);
      (0, _jquery2.default)(this).trigger(_jquery2.default.Event('swipe', e), dir).trigger(_jquery2.default.Event("swipe".concat(dir), e));
    }
  }
}

function onTouchStart(e) {
  if (e.touches.length == 1) {
    startPosX = e.touches[0].pageX;
    startPosY = e.touches[0].pageY;
    startEvent = e;
    isMoving = true;
    didMoved = false;
    startTime = new Date().getTime();
    this.addEventListener('touchmove', onTouchMove, false);
    this.addEventListener('touchend', onTouchEnd, false);
  }
}

function init() {
  this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);
}

var SpotSwipe =
/*#__PURE__*/
function () {
  function SpotSwipe($$$1) {
    _classCallCheck(this, SpotSwipe);

    this.version = '1.0.0';
    this.enabled = 'ontouchstart' in document.documentElement;
    this.preventDefault = false;
    this.moveThreshold = 75;
    this.timeThreshold = 200;
    this.$ = $$$1;

    this._init();
  }

  _createClass(SpotSwipe, [{
    key: "_init",
    value: function _init() {
      var $$$1 = this.$;
      $$$1.event.special.swipe = {
        setup: init
      };
      $$$1.event.special.tap = {
        setup: init
      };
      $$$1.each(['left', 'up', 'down', 'right'], function () {
        $$$1.event.special["swipe".concat(this)] = {
          setup: function setup() {
            $$$1(this).on('swipe', $$$1.noop);
          }
        };
      });
    }
  }]);

  return SpotSwipe;
}();
/****************************************************
 * As far as I can tell, both setupSpotSwipe and    *
 * setupTouchHandler should be idempotent,          *
 * because they directly replace functions &        *
 * values, and do not add event handlers directly.  *
 ****************************************************/

Touch.setupSpotSwipe = function ($$$1) {
  $$$1.spotSwipe = new SpotSwipe($$$1);
};
/****************************************************
 * Method for adding pseudo drag events to elements *
 ***************************************************/

Touch.setupTouchHandler = function ($$$1) {
  $$$1.fn.addTouch = function () {
    this.each(function (i, el) {
      $$$1(el).bind('touchstart touchmove touchend touchcancel', function (event) {
        //we pass the original event object because the jQuery event
        //object is normalized to w3c specs and does not provide the TouchList
        handleTouch(event);
      });
    });

    var handleTouch = function handleTouch(event) {
      var touches = event.changedTouches,
          first = touches[0],
          eventTypes = {
        touchstart: 'mousedown',
        touchmove: 'mousemove',
        touchend: 'mouseup'
      },
          type = eventTypes[event.type],
          simulatedEvent;

      if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {
        simulatedEvent = new window.MouseEvent(type, {
          'bubbles': true,
          'cancelable': true,
          'screenX': first.screenX,
          'screenY': first.screenY,
          'clientX': first.clientX,
          'clientY': first.clientY
        });
      } else {
        simulatedEvent = document.createEvent('MouseEvent');
        simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0
        /*left*/
        , null);
      }

      first.target.dispatchEvent(simulatedEvent);
    };
  };
};

Touch.init = function ($$$1) {
  if (typeof $$$1.spotSwipe === 'undefined') {
    Touch.setupSpotSwipe($$$1);
    Touch.setupTouchHandler($$$1);
  }
};

var MutationObserver = function () {
  var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];

  for (var i = 0; i < prefixes.length; i++) {
    if ("".concat(prefixes[i], "MutationObserver") in window) {
      return window["".concat(prefixes[i], "MutationObserver")];
    }
  }

  return false;
}();

var triggers = function triggers(el, type) {
  el.data(type).split(' ').forEach(function (id) {
    (0, _jquery2.default)("#".concat(id))[type === 'close' ? 'trigger' : 'triggerHandler']("".concat(type, ".zf.trigger"), [el]);
  });
};

var Triggers = {
  Listeners: {
    Basic: {},
    Global: {}
  },
  Initializers: {}
};
Triggers.Listeners.Basic = {
  openListener: function openListener() {
    triggers((0, _jquery2.default)(this), 'open');
  },
  closeListener: function closeListener() {
    var id = (0, _jquery2.default)(this).data('close');

    if (id) {
      triggers((0, _jquery2.default)(this), 'close');
    } else {
      (0, _jquery2.default)(this).trigger('close.zf.trigger');
    }
  },
  toggleListener: function toggleListener() {
    var id = (0, _jquery2.default)(this).data('toggle');

    if (id) {
      triggers((0, _jquery2.default)(this), 'toggle');
    } else {
      (0, _jquery2.default)(this).trigger('toggle.zf.trigger');
    }
  },
  closeableListener: function closeableListener(e) {
    e.stopPropagation();
    var animation = (0, _jquery2.default)(this).data('closable');

    if (animation !== '') {
      Motion.animateOut((0, _jquery2.default)(this), animation, function () {
        (0, _jquery2.default)(this).trigger('closed.zf');
      });
    } else {
      (0, _jquery2.default)(this).fadeOut().trigger('closed.zf');
    }
  },
  toggleFocusListener: function toggleFocusListener() {
    var id = (0, _jquery2.default)(this).data('toggle-focus');
    (0, _jquery2.default)("#".concat(id)).triggerHandler('toggle.zf.trigger', [(0, _jquery2.default)(this)]);
  }
}; // Elements with [data-open] will reveal a plugin that supports it when clicked.

Triggers.Initializers.addOpenListener = function ($elem) {
  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.openListener);
  $elem.on('click.zf.trigger', '[data-open]', Triggers.Listeners.Basic.openListener);
}; // Elements with [data-close] will close a plugin that supports it when clicked.
// If used without a value on [data-close], the event will bubble, allowing it to close a parent component.


Triggers.Initializers.addCloseListener = function ($elem) {
  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.closeListener);
  $elem.on('click.zf.trigger', '[data-close]', Triggers.Listeners.Basic.closeListener);
}; // Elements with [data-toggle] will toggle a plugin that supports it when clicked.


Triggers.Initializers.addToggleListener = function ($elem) {
  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.toggleListener);
  $elem.on('click.zf.trigger', '[data-toggle]', Triggers.Listeners.Basic.toggleListener);
}; // Elements with [data-closable] will respond to close.zf.trigger events.


Triggers.Initializers.addCloseableListener = function ($elem) {
  $elem.off('close.zf.trigger', Triggers.Listeners.Basic.closeableListener);
  $elem.on('close.zf.trigger', '[data-closeable], [data-closable]', Triggers.Listeners.Basic.closeableListener);
}; // Elements with [data-toggle-focus] will respond to coming in and out of focus


Triggers.Initializers.addToggleFocusListener = function ($elem) {
  $elem.off('focus.zf.trigger blur.zf.trigger', Triggers.Listeners.Basic.toggleFocusListener);
  $elem.on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', Triggers.Listeners.Basic.toggleFocusListener);
}; // More Global/complex listeners and triggers


Triggers.Listeners.Global = {
  resizeListener: function resizeListener($nodes) {
    if (!MutationObserver) {
      //fallback for IE 9
      $nodes.each(function () {
        (0, _jquery2.default)(this).triggerHandler('resizeme.zf.trigger');
      });
    } //trigger all listening elements and signal a resize event


    $nodes.attr('data-events', "resize");
  },
  scrollListener: function scrollListener($nodes) {
    if (!MutationObserver) {
      //fallback for IE 9
      $nodes.each(function () {
        (0, _jquery2.default)(this).triggerHandler('scrollme.zf.trigger');
      });
    } //trigger all listening elements and signal a scroll event


    $nodes.attr('data-events', "scroll");
  },
  closeMeListener: function closeMeListener(e, pluginId) {
    var plugin = e.namespace.split('.')[0];
    var plugins = (0, _jquery2.default)("[data-".concat(plugin, "]")).not("[data-yeti-box=\"".concat(pluginId, "\"]"));
    plugins.each(function () {
      var _this = (0, _jquery2.default)(this);

      _this.triggerHandler('close.zf.trigger', [_this]);
    });
  } // Global, parses whole document.

};

Triggers.Initializers.addClosemeListener = function (pluginName) {
  var yetiBoxes = (0, _jquery2.default)('[data-yeti-box]'),
      plugNames = ['dropdown', 'tooltip', 'reveal'];

  if (pluginName) {
    if (typeof pluginName === 'string') {
      plugNames.push(pluginName);
    } else if (_typeof(pluginName) === 'object' && typeof pluginName[0] === 'string') ;else {
      console.error('Plugin names must be strings');
    }
  }

  if (yetiBoxes.length) {
    var listeners = plugNames.map(function (name) {
      return "closeme.zf.".concat(name);
    }).join(' ');
    (0, _jquery2.default)(window).off(listeners).on(listeners, Triggers.Listeners.Global.closeMeListener);
  }
};

function debounceGlobalListener(debounce, trigger, listener) {
  var timer,
      args = Array.prototype.slice.call(arguments, 3);
  (0, _jquery2.default)(window).off(trigger).on(trigger, function (e) {
    if (timer) {
      clearTimeout(timer);
    }

    timer = setTimeout(function () {
      listener.apply(null, args);
    }, debounce || 10); //default time to emit scroll event
  });
}

Triggers.Initializers.addResizeListener = function (debounce) {
  var $nodes = (0, _jquery2.default)('[data-resize]');

  if ($nodes.length) {
    debounceGlobalListener(debounce, 'resize.zf.trigger', Triggers.Listeners.Global.resizeListener, $nodes);
  }
};

Triggers.Initializers.addScrollListener = function (debounce) {
  var $nodes = (0, _jquery2.default)('[data-scroll]');

  if ($nodes.length) {
    debounceGlobalListener(debounce, 'scroll.zf.trigger', Triggers.Listeners.Global.scrollListener, $nodes);
  }
};

Triggers.Initializers.addMutationEventsListener = function ($elem) {
  if (!MutationObserver) {
    return false;
  }

  var $nodes = $elem.find('[data-resize], [data-scroll], [data-mutate]'); //element callback

  var listeningElementsMutation = function listeningElementsMutation(mutationRecordsList) {
    var $target = (0, _jquery2.default)(mutationRecordsList[0].target); //trigger the event handler for the element depending on type

    switch (mutationRecordsList[0].type) {
      case "attributes":
        if ($target.attr("data-events") === "scroll" && mutationRecordsList[0].attributeName === "data-events") {
          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
        }

        if ($target.attr("data-events") === "resize" && mutationRecordsList[0].attributeName === "data-events") {
          $target.triggerHandler('resizeme.zf.trigger', [$target]);
        }

        if (mutationRecordsList[0].attributeName === "style") {
          $target.closest("[data-mutate]").attr("data-events", "mutate");
          $target.closest("[data-mutate]").triggerHandler('mutateme.zf.trigger', [$target.closest("[data-mutate]")]);
        }

        break;

      case "childList":
        $target.closest("[data-mutate]").attr("data-events", "mutate");
        $target.closest("[data-mutate]").triggerHandler('mutateme.zf.trigger', [$target.closest("[data-mutate]")]);
        break;

      default:
        return false;
      //nothing
    }
  };

  if ($nodes.length) {
    //for each element that needs to listen for resizing, scrolling, or mutation add a single observer
    for (var i = 0; i <= $nodes.length - 1; i++) {
      var elementObserver = new MutationObserver(listeningElementsMutation);
      elementObserver.observe($nodes[i], {
        attributes: true,
        childList: true,
        characterData: false,
        subtree: true,
        attributeFilter: ["data-events", "style"]
      });
    }
  }
};

Triggers.Initializers.addSimpleListeners = function () {
  var $document = (0, _jquery2.default)(document);
  Triggers.Initializers.addOpenListener($document);
  Triggers.Initializers.addCloseListener($document);
  Triggers.Initializers.addToggleListener($document);
  Triggers.Initializers.addCloseableListener($document);
  Triggers.Initializers.addToggleFocusListener($document);
};

Triggers.Initializers.addGlobalListeners = function () {
  var $document = (0, _jquery2.default)(document);
  Triggers.Initializers.addMutationEventsListener($document);
  Triggers.Initializers.addResizeListener();
  Triggers.Initializers.addScrollListener();
  Triggers.Initializers.addClosemeListener();
};

Triggers.init = function ($$$1, Foundation) {
  onLoad($$$1(window), function () {
    if ($$$1.triggersInitialized !== true) {
      Triggers.Initializers.addSimpleListeners();
      Triggers.Initializers.addGlobalListeners();
      $$$1.triggersInitialized = true;
    }
  });

  if (Foundation) {
    Foundation.Triggers = Triggers; // Legacy included to be backwards compatible for now.

    Foundation.IHearYou = Triggers.Initializers.addGlobalListeners;
  }
};

// {function} _setup (replaces previous constructor),
// {function} _destroy (replaces previous destroy)

var Plugin =
/*#__PURE__*/
function () {
  function Plugin(element, options) {
    _classCallCheck(this, Plugin);

    this._setup(element, options);

    var pluginName = getPluginName(this);
    this.uuid = GetYoDigits(6, pluginName);

    if (!this.$element.attr("data-".concat(pluginName))) {
      this.$element.attr("data-".concat(pluginName), this.uuid);
    }

    if (!this.$element.data('zfPlugin')) {
      this.$element.data('zfPlugin', this);
    }
    /**
     * Fires when the plugin has initialized.
     * @event Plugin#init
     */

    this.$element.trigger("init.zf.".concat(pluginName));
  }

  _createClass(Plugin, [{
    key: "destroy",
    value: function destroy() {
      this._destroy();

      var pluginName = getPluginName(this);
      this.$element.removeAttr("data-".concat(pluginName)).removeData('zfPlugin')
      /**
       * Fires when the plugin has been destroyed.
       * @event Plugin#destroyed
       */
      .trigger("destroyed.zf.".concat(pluginName));

      for (var prop in this) {
        this[prop] = null; //clean up script to prep for garbage collection.
      }
    }
  }]);

  return Plugin;
}(); // Convert PascalCase to kebab-case
// Thank you: http://stackoverflow.com/a/8955580


function hyphenate$1(str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

function getPluginName(obj) {
  if (typeof obj.constructor.name !== 'undefined') {
    return hyphenate$1(obj.constructor.name);
  } else {
    return hyphenate$1(obj.className);
  }
}

/**
 * Abide module.
 * @module foundation.abide
 */

var Abide =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Abide, _Plugin);

  function Abide() {
    _classCallCheck(this, Abide);

    return _possibleConstructorReturn(this, _getPrototypeOf(Abide).apply(this, arguments));
  }

  _createClass(Abide, [{
    key: "_setup",

    /**
     * Creates a new instance of Abide.
     * @class
     * @name Abide
     * @fires Abide#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.$element = element;
      this.options = _jquery2.default.extend(true, {}, Abide.defaults, this.$element.data(), options);
      this.className = 'Abide'; // ie9 back compat

      this._init();
    }
    /**
     * Initializes the Abide plugin and calls functions to get Abide functioning on load.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      this.$inputs = _jquery2.default.merge( // Consider as input to validate:
      this.$element.find('input').not('[type=submit]'), // * all input fields expect submit
      this.$element.find('textarea, select') // * all textareas and select fields
      );
      var $globalErrors = this.$element.find('[data-abide-error]'); // Add a11y attributes to all fields

      if (this.options.a11yAttributes) {
        this.$inputs.each(function (i, input) {
          return _this2.addA11yAttributes((0, _jquery2.default)(input));
        });
        $globalErrors.each(function (i, error) {
          return _this2.addGlobalErrorA11yAttributes((0, _jquery2.default)(error));
        });
      }

      this._events();
    }
    /**
     * Initializes events for Abide.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this3 = this;

      this.$element.off('.abide').on('reset.zf.abide', function () {
        _this3.resetForm();
      }).on('submit.zf.abide', function () {
        return _this3.validateForm();
      });

      if (this.options.validateOn === 'fieldChange') {
        this.$inputs.off('change.zf.abide').on('change.zf.abide', function (e) {
          _this3.validateInput((0, _jquery2.default)(e.target));
        });
      }

      if (this.options.liveValidate) {
        this.$inputs.off('input.zf.abide').on('input.zf.abide', function (e) {
          _this3.validateInput((0, _jquery2.default)(e.target));
        });
      }

      if (this.options.validateOnBlur) {
        this.$inputs.off('blur.zf.abide').on('blur.zf.abide', function (e) {
          _this3.validateInput((0, _jquery2.default)(e.target));
        });
      }
    }
    /**
     * Calls necessary functions to update Abide upon DOM change
     * @private
     */

  }, {
    key: "_reflow",
    value: function _reflow() {
      this._init();
    }
    /**
     * Checks whether or not a form element has the required attribute and if it's checked or not
     * @param {Object} element - jQuery object to check for required attribute
     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
     */

  }, {
    key: "requiredCheck",
    value: function requiredCheck($el) {
      if (!$el.attr('required')) return true;
      var isGood = true;

      switch ($el[0].type) {
        case 'checkbox':
          isGood = $el[0].checked;
          break;

        case 'select':
        case 'select-one':
        case 'select-multiple':
          var opt = $el.find('option:selected');
          if (!opt.length || !opt.val()) isGood = false;
          break;

        default:
          if (!$el.val() || !$el.val().length) isGood = false;
      }

      return isGood;
    }
    /**
     * Get:
     * - Based on $el, the first element(s) corresponding to `formErrorSelector` in this order:
     *   1. The element's direct sibling('s).
     *   2. The element's parent's children.
     * - Element(s) with the attribute `[data-form-error-for]` set with the element's id.
     *
     * This allows for multiple form errors per input, though if none are found, no form errors will be shown.
     *
     * @param {Object} $el - jQuery object to use as reference to find the form error selector.
     * @returns {Object} jQuery object with the selector.
     */

  }, {
    key: "findFormError",
    value: function findFormError($el) {
      var id = $el[0].id;
      var $error = $el.siblings(this.options.formErrorSelector);

      if (!$error.length) {
        $error = $el.parent().find(this.options.formErrorSelector);
      }

      if (id) {
        $error = $error.add(this.$element.find("[data-form-error-for=\"".concat(id, "\"]")));
      }

      return $error;
    }
    /**
     * Get the first element in this order:
     * 2. The <label> with the attribute `[for="someInputId"]`
     * 3. The `.closest()` <label>
     *
     * @param {Object} $el - jQuery object to check for required attribute
     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
     */

  }, {
    key: "findLabel",
    value: function findLabel($el) {
      var id = $el[0].id;
      var $label = this.$element.find("label[for=\"".concat(id, "\"]"));

      if (!$label.length) {
        return $el.closest('label');
      }

      return $label;
    }
    /**
     * Get the set of labels associated with a set of radio els in this order
     * 2. The <label> with the attribute `[for="someInputId"]`
     * 3. The `.closest()` <label>
     *
     * @param {Object} $el - jQuery object to check for required attribute
     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
     */

  }, {
    key: "findRadioLabels",
    value: function findRadioLabels($els) {
      var _this4 = this;

      var labels = $els.map(function (i, el) {
        var id = el.id;

        var $label = _this4.$element.find("label[for=\"".concat(id, "\"]"));

        if (!$label.length) {
          $label = (0, _jquery2.default)(el).closest('label');
        }

        return $label[0];
      });
      return (0, _jquery2.default)(labels);
    }
    /**
     * Adds the CSS error class as specified by the Abide settings to the label, input, and the form
     * @param {Object} $el - jQuery object to add the class to
     */

  }, {
    key: "addErrorClasses",
    value: function addErrorClasses($el) {
      var $label = this.findLabel($el);
      var $formError = this.findFormError($el);

      if ($label.length) {
        $label.addClass(this.options.labelErrorClass);
      }

      if ($formError.length) {
        $formError.addClass(this.options.formErrorClass);
      }

      $el.addClass(this.options.inputErrorClass).attr({
        'data-invalid': '',
        'aria-invalid': true
      });
    }
    /**
     * Adds [for] and [role=alert] attributes to all form error targetting $el,
     * and [aria-describedby] attribute to $el toward the first form error.
     * @param {Object} $el - jQuery object
     */

  }, {
    key: "addA11yAttributes",
    value: function addA11yAttributes($el) {
      var $errors = this.findFormError($el);
      var $labels = $errors.filter('label');
      var $error = $errors.first();
      if (!$errors.length) return; // Set [aria-describedby] on the input toward the first form error if it is not set

      if (typeof $el.attr('aria-describedby') === 'undefined') {
        // Get the first error ID or create one
        var errorId = $error.attr('id');

        if (typeof errorId === 'undefined') {
          errorId = GetYoDigits(6, 'abide-error');
          $error.attr('id', errorId);
        }
        $el.attr('aria-describedby', errorId);
      }

      if ($labels.filter('[for]').length < $labels.length) {
        // Get the input ID or create one
        var elemId = $el.attr('id');

        if (typeof elemId === 'undefined') {
          elemId = GetYoDigits(6, 'abide-input');
          $el.attr('id', elemId);
        }

        $labels.each(function (i, label) {
          var $label = (0, _jquery2.default)(label);
          if (typeof $label.attr('for') === 'undefined') $label.attr('for', elemId);
        });
      } // For each error targeting $el, set [role=alert] if it is not set.


      $errors.each(function (i, label) {
        var $label = (0, _jquery2.default)(label);
        if (typeof $label.attr('role') === 'undefined') $label.attr('role', 'alert');
      }).end();
    }
    /**
     * Adds [aria-live] attribute to the given global form error $el.
     * @param {Object} $el - jQuery object to add the attribute to
     */

  }, {
    key: "addGlobalErrorA11yAttributes",
    value: function addGlobalErrorA11yAttributes($el) {
      if (typeof $el.attr('aria-live') === 'undefined') $el.attr('aria-live', this.options.a11yErrorLevel);
    }
    /**
     * Remove CSS error classes etc from an entire radio button group
     * @param {String} groupName - A string that specifies the name of a radio button group
     *
     */

  }, {
    key: "removeRadioErrorClasses",
    value: function removeRadioErrorClasses(groupName) {
      var $els = this.$element.find(":radio[name=\"".concat(groupName, "\"]"));
      var $labels = this.findRadioLabels($els);
      var $formErrors = this.findFormError($els);

      if ($labels.length) {
        $labels.removeClass(this.options.labelErrorClass);
      }

      if ($formErrors.length) {
        $formErrors.removeClass(this.options.formErrorClass);
      }

      $els.removeClass(this.options.inputErrorClass).attr({
        'data-invalid': null,
        'aria-invalid': null
      });
    }
    /**
     * Removes CSS error class as specified by the Abide settings from the label, input, and the form
     * @param {Object} $el - jQuery object to remove the class from
     */

  }, {
    key: "removeErrorClasses",
    value: function removeErrorClasses($el) {
      // radios need to clear all of the els
      if ($el[0].type == 'radio') {
        return this.removeRadioErrorClasses($el.attr('name'));
      }

      var $label = this.findLabel($el);
      var $formError = this.findFormError($el);

      if ($label.length) {
        $label.removeClass(this.options.labelErrorClass);
      }

      if ($formError.length) {
        $formError.removeClass(this.options.formErrorClass);
      }

      $el.removeClass(this.options.inputErrorClass).attr({
        'data-invalid': null,
        'aria-invalid': null
      });
    }
    /**
     * Goes through a form to find inputs and proceeds to validate them in ways specific to their type.
     * Ignores inputs with data-abide-ignore, type="hidden" or disabled attributes set
     * @fires Abide#invalid
     * @fires Abide#valid
     * @param {Object} element - jQuery object to validate, should be an HTML input
     * @returns {Boolean} goodToGo - If the input is valid or not.
     */

  }, {
    key: "validateInput",
    value: function validateInput($el) {
      var clearRequire = this.requiredCheck($el),
          validated = false,
          customValidator = true,
          validator = $el.attr('data-validator'),
          equalTo = true; // don't validate ignored inputs or hidden inputs or disabled inputs

      if ($el.is('[data-abide-ignore]') || $el.is('[type="hidden"]') || $el.is('[disabled]')) {
        return true;
      }

      switch ($el[0].type) {
        case 'radio':
          validated = this.validateRadio($el.attr('name'));
          break;

        case 'checkbox':
          validated = clearRequire;
          break;

        case 'select':
        case 'select-one':
        case 'select-multiple':
          validated = clearRequire;
          break;

        default:
          validated = this.validateText($el);
      }

      if (validator) {
        customValidator = this.matchValidation($el, validator, $el.attr('required'));
      }

      if ($el.attr('data-equalto')) {
        equalTo = this.options.validators.equalTo($el);
      }

      var goodToGo = [clearRequire, validated, customValidator, equalTo].indexOf(false) === -1;
      var message = (goodToGo ? 'valid' : 'invalid') + '.zf.abide';

      if (goodToGo) {
        // Re-validate inputs that depend on this one with equalto
        var dependentElements = this.$element.find("[data-equalto=\"".concat($el.attr('id'), "\"]"));

        if (dependentElements.length) {
          var _this = this;

          dependentElements.each(function () {
            if ((0, _jquery2.default)(this).val()) {
              _this.validateInput((0, _jquery2.default)(this));
            }
          });
        }
      }

      this[goodToGo ? 'removeErrorClasses' : 'addErrorClasses']($el);
      /**
       * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`
       * Trigger includes the DOM element of the input.
       * @event Abide#valid
       * @event Abide#invalid
       */

      $el.trigger(message, [$el]);
      return goodToGo;
    }
    /**
     * Goes through a form and if there are any invalid inputs, it will display the form error element
     * @returns {Boolean} noError - true if no errors were detected...
     * @fires Abide#formvalid
     * @fires Abide#forminvalid
     */

  }, {
    key: "validateForm",
    value: function validateForm() {
      var _this5 = this;

      var acc = [];

      var _this = this;

      this.$inputs.each(function () {
        acc.push(_this.validateInput((0, _jquery2.default)(this)));
      });
      var noError = acc.indexOf(false) === -1;
      this.$element.find('[data-abide-error]').each(function (i, elem) {
        var $elem = (0, _jquery2.default)(elem); // Ensure a11y attributes are set

        if (_this5.options.a11yAttributes) _this5.addGlobalErrorA11yAttributes($elem); // Show or hide the error

        $elem.css('display', noError ? 'none' : 'block');
      });
      /**
       * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.
       * Trigger includes the element of the form.
       * @event Abide#formvalid
       * @event Abide#forminvalid
       */

      this.$element.trigger((noError ? 'formvalid' : 'forminvalid') + '.zf.abide', [this.$element]);
      return noError;
    }
    /**
     * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.
     * @param {Object} $el - jQuery object to validate, should be a text input HTML element
     * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns
     * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified
     */

  }, {
    key: "validateText",
    value: function validateText($el, pattern) {
      // A pattern can be passed to this function, or it will be infered from the input's "pattern" attribute, or it's "type" attribute
      pattern = pattern || $el.attr('pattern') || $el.attr('type');
      var inputText = $el.val();
      var valid = false;

      if (inputText.length) {
        // If the pattern attribute on the element is in Abide's list of patterns, then test that regexp
        if (this.options.patterns.hasOwnProperty(pattern)) {
          valid = this.options.patterns[pattern].test(inputText);
        } // If the pattern name isn't also the type attribute of the field, then test it as a regexp
        else if (pattern !== $el.attr('type')) {
            valid = new RegExp(pattern).test(inputText);
          } else {
            valid = true;
          }
      } // An empty field is valid if it's not required
      else if (!$el.prop('required')) {
          valid = true;
        }

      return valid;
    }
    /**
     * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.
     * @param {String} groupName - A string that specifies the name of a radio button group
     * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)
     */

  }, {
    key: "validateRadio",
    value: function validateRadio(groupName) {
      // If at least one radio in the group has the `required` attribute, the group is considered required
      // Per W3C spec, all radio buttons in a group should have `required`, but we're being nice
      var $group = this.$element.find(":radio[name=\"".concat(groupName, "\"]"));
      var valid = false,
          required = false; // For the group to be required, at least one radio needs to be required

      $group.each(function (i, e) {
        if ((0, _jquery2.default)(e).attr('required')) {
          required = true;
        }
      });
      if (!required) valid = true;

      if (!valid) {
        // For the group to be valid, at least one radio needs to be checked
        $group.each(function (i, e) {
          if ((0, _jquery2.default)(e).prop('checked')) {
            valid = true;
          }
        });
      }
      return valid;
    }
    /**
     * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator="foo bar baz"` in a space separated listed.
     * @param {Object} $el - jQuery input element.
     * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.
     * @param {Boolean} required - self explanatory?
     * @returns {Boolean} - true if validations passed.
     */

  }, {
    key: "matchValidation",
    value: function matchValidation($el, validators, required) {
      var _this6 = this;

      required = required ? true : false;
      var clear = validators.split(' ').map(function (v) {
        return _this6.options.validators[v]($el, required, $el.parent());
      });
      return clear.indexOf(false) === -1;
    }
    /**
     * Resets form inputs and styles
     * @fires Abide#formreset
     */

  }, {
    key: "resetForm",
    value: function resetForm() {
      var $form = this.$element,
          opts = this.options;
      (0, _jquery2.default)(".".concat(opts.labelErrorClass), $form).not('small').removeClass(opts.labelErrorClass);
      (0, _jquery2.default)(".".concat(opts.inputErrorClass), $form).not('small').removeClass(opts.inputErrorClass);
      (0, _jquery2.default)("".concat(opts.formErrorSelector, ".").concat(opts.formErrorClass)).removeClass(opts.formErrorClass);
      $form.find('[data-abide-error]').css('display', 'none');
      (0, _jquery2.default)(':input', $form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').attr({
        'data-invalid': null,
        'aria-invalid': null
      });
      (0, _jquery2.default)(':input:radio', $form).not('[data-abide-ignore]').prop('checked', false).attr({
        'data-invalid': null,
        'aria-invalid': null
      });
      (0, _jquery2.default)(':input:checkbox', $form).not('[data-abide-ignore]').prop('checked', false).attr({
        'data-invalid': null,
        'aria-invalid': null
      });
      /**
       * Fires when the form has been reset.
       * @event Abide#formreset
       */

      $form.trigger('formreset.zf.abide', [$form]);
    }
    /**
     * Destroys an instance of Abide.
     * Removes error styles and classes from elements, without resetting their values.
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      var _this = this;

      this.$element.off('.abide').find('[data-abide-error]').css('display', 'none');
      this.$inputs.off('.abide').each(function () {
        _this.removeErrorClasses((0, _jquery2.default)(this));
      });
    }
  }]);

  return Abide;
}(Plugin);
/**
 * Default settings for plugin
 */

Abide.defaults = {
  /**
   * The default event to validate inputs. Checkboxes and radios validate immediately.
   * Remove or change this value for manual validation.
   * @option
   * @type {?string}
   * @default 'fieldChange'
   */
  validateOn: 'fieldChange',

  /**
   * Class to be applied to input labels on failed validation.
   * @option
   * @type {string}
   * @default 'is-invalid-label'
   */
  labelErrorClass: 'is-invalid-label',

  /**
   * Class to be applied to inputs on failed validation.
   * @option
   * @type {string}
   * @default 'is-invalid-input'
   */
  inputErrorClass: 'is-invalid-input',

  /**
   * Class selector to use to target Form Errors for show/hide.
   * @option
   * @type {string}
   * @default '.form-error'
   */
  formErrorSelector: '.form-error',

  /**
   * Class added to Form Errors on failed validation.
   * @option
   * @type {string}
   * @default 'is-visible'
   */
  formErrorClass: 'is-visible',

  /**
   * If true, automatically insert when possible:
   * - `[aria-describedby]` on fields
   * - `[role=alert]` on form errors and `[for]` on form error labels
   * - `[aria-live]` on global errors `[data-abide-error]` (see option `a11yErrorLevel`).
   * @option
   * @type {boolean}
   * @default true
   */
  a11yAttributes: true,

  /**
   * [aria-live] attribute value to be applied on global errors `[data-abide-error]`.
   * Options are: 'assertive', 'polite' and 'off'/null
   * @option
   * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions
   * @type {string}
   * @default 'assertive'
   */
  a11yErrorLevel: 'assertive',

  /**
   * Set to true to validate text inputs on any value change.
   * @option
   * @type {boolean}
   * @default false
   */
  liveValidate: false,

  /**
   * Set to true to validate inputs on blur.
   * @option
   * @type {boolean}
   * @default false
   */
  validateOnBlur: false,
  patterns: {
    alpha: /^[a-zA-Z]+$/,
    alpha_numeric: /^[a-zA-Z0-9]+$/,
    integer: /^[-+]?\d+$/,
    number: /^[-+]?\d*(?:[\.\,]\d+)?$/,
    // amex, visa, diners
    card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(?:222[1-9]|2[3-6][0-9]{2}|27[0-1][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
    cvv: /^([0-9]){3,4}$/,
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address
    email: /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,
    // From CommonRegexJS (@talyssonoc)
    // https://github.com/talyssonoc/CommonRegexJS/blob/e2901b9f57222bc14069dc8f0598d5f412555411/lib/commonregex.js#L76
    // For more restrictive URL Regexs, see https://mathiasbynens.be/demo/url-regex.
    url: /^((?:(https?|ftps?|file|ssh|sftp):\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))*\))+(?:\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\'".,<>?\xab\xbb\u201c\u201d\u2018\u2019]))$/,
    // abc.de
    domain: /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,
    datetime: /^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,
    // YYYY-MM-DD
    date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,
    // HH:MM:SS
    time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,
    dateISO: /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
    // MM/DD/YYYY
    month_day_year: /^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,
    // DD/MM/YYYY
    day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,
    // #FFF or #FFFFFF
    color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,
    // Domain || URL
    website: {
      test: function test(text) {
        return Abide.defaults.patterns['domain'].test(text) || Abide.defaults.patterns['url'].test(text);
      }
    }
  },

  /**
   * Optional validation functions to be used. `equalTo` being the only default included function.
   * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:
   * el : The jQuery element to validate.
   * required : Boolean value of the required attribute be present or not.
   * parent : The direct parent of the input.
   * @option
   */
  validators: {
    equalTo: function equalTo(el, required, parent) {
      return (0, _jquery2.default)("#".concat(el.attr('data-equalto'))).val() === el.val();
    }
  }
};

/**
 * Accordion module.
 * @module foundation.accordion
 * @requires foundation.util.keyboard
 */

var Accordion =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Accordion, _Plugin);

  function Accordion() {
    _classCallCheck(this, Accordion);

    return _possibleConstructorReturn(this, _getPrototypeOf(Accordion).apply(this, arguments));
  }

  _createClass(Accordion, [{
    key: "_setup",

    /**
     * Creates a new instance of an accordion.
     * @class
     * @name Accordion
     * @fires Accordion#init
     * @param {jQuery} element - jQuery object to make into an accordion.
     * @param {Object} options - a plain object with settings to override the default options.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Accordion.defaults, this.$element.data(), options);
      this.className = 'Accordion'; // ie9 back compat

      this._init();

      Keyboard.register('Accordion', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ARROW_DOWN': 'next',
        'ARROW_UP': 'previous'
      });
    }
    /**
     * Initializes the accordion by animating the preset active pane(s).
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      this._isInitializing = true;
      this.$element.attr('role', 'tablist');
      this.$tabs = this.$element.children('[data-accordion-item]');
      this.$tabs.each(function (idx, el) {
        var $el = (0, _jquery2.default)(el),
            $content = $el.children('[data-tab-content]'),
            id = $content[0].id || GetYoDigits(6, 'accordion'),
            linkId = el.id ? "".concat(el.id, "-label") : "".concat(id, "-label");
        $el.find('a:first').attr({
          'aria-controls': id,
          'role': 'tab',
          'id': linkId,
          'aria-expanded': false,
          'aria-selected': false
        });
        $content.attr({
          'role': 'tabpanel',
          'aria-labelledby': linkId,
          'aria-hidden': true,
          'id': id
        });
      });
      var $initActive = this.$element.find('.is-active').children('[data-tab-content]');

      if ($initActive.length) {
        // Save up the initial hash to return to it later when going back in history
        this._initialAnchor = $initActive.prev('a').attr('href');

        this._openSingleTab($initActive);
      }

      this._checkDeepLink = function () {
        var anchor = window.location.hash;

        if (!anchor.length) {
          // If we are still initializing and there is no anchor, then there is nothing to do
          if (_this2._isInitializing) return; // Otherwise, move to the initial anchor

          if (_this2._initialAnchor) anchor = _this2._initialAnchor;
        }

        var $anchor = anchor && (0, _jquery2.default)(anchor);

        var $link = anchor && _this2.$element.find("[href$=\"".concat(anchor, "\"]")); // Whether the anchor element that has been found is part of this element


        var isOwnAnchor = !!($anchor.length && $link.length); // If there is an anchor for the hash, open it (if not already active)

        if ($anchor && $link && $link.length) {
          if (!$link.parent('[data-accordion-item]').hasClass('is-active')) {
            _this2._openSingleTab($anchor);
          }
        } // Otherwise, close everything
        else {
            _this2._closeAllTabs();
          }

        if (isOwnAnchor) {
          // Roll up a little to show the titles
          if (_this2.options.deepLinkSmudge) {
            onLoad((0, _jquery2.default)(window), function () {
              var offset = _this2.$element.offset();

              (0, _jquery2.default)('html, body').animate({
                scrollTop: offset.top
              }, _this2.options.deepLinkSmudgeDelay);
            });
          }
          /**
           * Fires when the plugin has deeplinked at pageload
           * @event Accordion#deeplink
           */

          _this2.$element.trigger('deeplink.zf.accordion', [$link, $anchor]);
        }
      }; //use browser to open a tab, if it exists in this tabset


      if (this.options.deepLink) {
        this._checkDeepLink();
      }

      this._events();

      this._isInitializing = false;
    }
    /**
     * Adds event handlers for items within the accordion.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      this.$tabs.each(function () {
        var $elem = (0, _jquery2.default)(this);
        var $tabContent = $elem.children('[data-tab-content]');

        if ($tabContent.length) {
          $elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion', function (e) {
            e.preventDefault();

            _this.toggle($tabContent);
          }).on('keydown.zf.accordion', function (e) {
            Keyboard.handleKey(e, 'Accordion', {
              toggle: function toggle() {
                _this.toggle($tabContent);
              },
              next: function next() {
                var $a = $elem.next().find('a').focus();

                if (!_this.options.multiExpand) {
                  $a.trigger('click.zf.accordion');
                }
              },
              previous: function previous() {
                var $a = $elem.prev().find('a').focus();

                if (!_this.options.multiExpand) {
                  $a.trigger('click.zf.accordion');
                }
              },
              handled: function handled() {
                e.preventDefault();
                e.stopPropagation();
              }
            });
          });
        }
      });

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).on('hashchange', this._checkDeepLink);
      }
    }
    /**
     * Toggles the selected content pane's open/close state.
     * @param {jQuery} $target - jQuery object of the pane to toggle (`.accordion-content`).
     * @function
     */

  }, {
    key: "toggle",
    value: function toggle($target) {
      if ($target.closest('[data-accordion]').is('[disabled]')) {
        console.info('Cannot toggle an accordion that is disabled.');
        return;
      }

      if ($target.parent().hasClass('is-active')) {
        this.up($target);
      } else {
        this.down($target);
      } //either replace or update browser history


      if (this.options.deepLink) {
        var anchor = $target.prev('a').attr('href');

        if (this.options.updateHistory) {
          history.pushState({}, '', anchor);
        } else {
          history.replaceState({}, '', anchor);
        }
      }
    }
    /**
     * Opens the accordion tab defined by `$target`.
     * @param {jQuery} $target - Accordion pane to open (`.accordion-content`).
     * @fires Accordion#down
     * @function
     */

  }, {
    key: "down",
    value: function down($target) {
      if ($target.closest('[data-accordion]').is('[disabled]')) {
        console.info('Cannot call down on an accordion that is disabled.');
        return;
      }

      if (this.options.multiExpand) this._openTab($target);else this._openSingleTab($target);
    }
    /**
     * Closes the tab defined by `$target`.
     * It may be ignored if the Accordion options don't allow it.
     *
     * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).
     * @fires Accordion#up
     * @function
     */

  }, {
    key: "up",
    value: function up($target) {
      if (this.$element.is('[disabled]')) {
        console.info('Cannot call up on an accordion that is disabled.');
        return;
      } // Don't close the item if it is already closed


      var $targetItem = $target.parent();
      if (!$targetItem.hasClass('is-active')) return; // Don't close the item if there is no other active item (unless with `allowAllClosed`)

      var $othersItems = $targetItem.siblings();
      if (!this.options.allowAllClosed && !$othersItems.hasClass('is-active')) return;

      this._closeTab($target);
    }
    /**
     * Make the tab defined by `$target` the only opened tab, closing all others tabs.
     * @param {jQuery} $target - Accordion tab to open (`.accordion-content`).
     * @function
     * @private
     */

  }, {
    key: "_openSingleTab",
    value: function _openSingleTab($target) {
      // Close all the others active tabs.
      var $activeContents = this.$element.children('.is-active').children('[data-tab-content]');

      if ($activeContents.length) {
        this._closeTab($activeContents.not($target));
      } // Then open the target.


      this._openTab($target);
    }
    /**
     * Opens the tab defined by `$target`.
     * @param {jQuery} $target - Accordion tab to open (`.accordion-content`).
     * @fires Accordion#down
     * @function
     * @private
     */

  }, {
    key: "_openTab",
    value: function _openTab($target) {
      var _this3 = this;

      var $targetItem = $target.parent();
      var targetContentId = $target.attr('aria-labelledby');
      $target.attr('aria-hidden', false);
      $targetItem.addClass('is-active');
      (0, _jquery2.default)("#".concat(targetContentId)).attr({
        'aria-expanded': true,
        'aria-selected': true
      });
      $target.slideDown(this.options.slideSpeed, function () {
        /**
         * Fires when the tab is done opening.
         * @event Accordion#down
         */
        _this3.$element.trigger('down.zf.accordion', [$target]);
      });
    }
    /**
     * Closes the tab defined by `$target`.
     * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).
     * @fires Accordion#up
     * @function
     * @private
     */

  }, {
    key: "_closeTab",
    value: function _closeTab($target) {
      var _this4 = this;

      var $targetItem = $target.parent();
      var targetContentId = $target.attr('aria-labelledby');
      $target.attr('aria-hidden', true);
      $targetItem.removeClass('is-active');
      (0, _jquery2.default)("#".concat(targetContentId)).attr({
        'aria-expanded': false,
        'aria-selected': false
      });
      $target.slideUp(this.options.slideSpeed, function () {
        /**
         * Fires when the tab is done collapsing up.
         * @event Accordion#up
         */
        _this4.$element.trigger('up.zf.accordion', [$target]);
      });
    }
    /**
     * Closes all active tabs
     * @fires Accordion#up
     * @function
     * @private
     */

  }, {
    key: "_closeAllTabs",
    value: function _closeAllTabs() {
      var $activeTabs = this.$element.children('.is-active').children('[data-tab-content]');

      if ($activeTabs.length) {
        this._closeTab($activeTabs);
      }
    }
    /**
     * Destroys an instance of an accordion.
     * @fires Accordion#destroyed
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display', '');
      this.$element.find('a').off('.zf.accordion');

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).off('hashchange', this._checkDeepLink);
      }
    }
  }]);

  return Accordion;
}(Plugin);

Accordion.defaults = {
  /**
   * Amount of time to animate the opening of an accordion pane.
   * @option
   * @type {number}
   * @default 250
   */
  slideSpeed: 250,

  /**
   * Allow the accordion to have multiple open panes.
   * @option
   * @type {boolean}
   * @default false
   */
  multiExpand: false,

  /**
   * Allow the accordion to close all panes.
   * @option
   * @type {boolean}
   * @default false
   */
  allowAllClosed: false,

  /**
   * Link the location hash to the open pane.
   * Set the location hash when the opened pane changes, and open and scroll to the corresponding pane when the location changes.
   * @option
   * @type {boolean}
   * @default false
   */
  deepLink: false,

  /**
   * If `deepLink` is enabled, adjust the deep link scroll to make sure the top of the accordion panel is visible
   * @option
   * @type {boolean}
   * @default false
   */
  deepLinkSmudge: false,

  /**
   * If `deepLinkSmudge` is enabled, animation time (ms) for the deep link adjustment
   * @option
   * @type {number}
   * @default 300
   */
  deepLinkSmudgeDelay: 300,

  /**
   * If `deepLink` is enabled, update the browser history with the open accordion
   * @option
   * @type {boolean}
   * @default false
   */
  updateHistory: false
};

/**
 * AccordionMenu module.
 * @module foundation.accordionMenu
 * @requires foundation.util.keyboard
 * @requires foundation.util.nest
 */

var AccordionMenu =
/*#__PURE__*/
function (_Plugin) {
  _inherits(AccordionMenu, _Plugin);

  function AccordionMenu() {
    _classCallCheck(this, AccordionMenu);

    return _possibleConstructorReturn(this, _getPrototypeOf(AccordionMenu).apply(this, arguments));
  }

  _createClass(AccordionMenu, [{
    key: "_setup",

    /**
     * Creates a new instance of an accordion menu.
     * @class
     * @name AccordionMenu
     * @fires AccordionMenu#init
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, AccordionMenu.defaults, this.$element.data(), options);
      this.className = 'AccordionMenu'; // ie9 back compat

      this._init();

      Keyboard.register('AccordionMenu', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ARROW_RIGHT': 'open',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'close',
        'ESCAPE': 'closeAll'
      });
    }
    /**
     * Initializes the accordion menu by hiding all nested menus.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      Nest.Feather(this.$element, 'accordion');

      var _this = this;

      this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');

      this.$element.attr({
        'role': 'tree',
        'aria-multiselectable': this.options.multiOpen
      });
      this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');
      this.$menuLinks.each(function () {
        var linkId = this.id || GetYoDigits(6, 'acc-menu-link'),
            $elem = (0, _jquery2.default)(this),
            $sub = $elem.children('[data-submenu]'),
            subId = $sub[0].id || GetYoDigits(6, 'acc-menu'),
            isActive = $sub.hasClass('is-active');

        if (_this.options.parentLink) {
          var $anchor = $elem.children('a');
          $anchor.clone().prependTo($sub).wrap('<li data-is-parent-link class="is-submenu-parent-item is-submenu-item is-accordion-submenu-item"></li>');
        }

        if (_this.options.submenuToggle) {
          $elem.addClass('has-submenu-toggle');
          $elem.children('a').after('<button id="' + linkId + '" class="submenu-toggle" aria-controls="' + subId + '" aria-expanded="' + isActive + '" title="' + _this.options.submenuToggleText + '"><span class="submenu-toggle-text">' + _this.options.submenuToggleText + '</span></button>');
        } else {
          $elem.attr({
            'aria-controls': subId,
            'aria-expanded': isActive,
            'id': linkId
          });
        }

        $sub.attr({
          'aria-labelledby': linkId,
          'aria-hidden': !isActive,
          'role': 'group',
          'id': subId
        });
      });
      this.$element.find('li').attr({
        'role': 'treeitem'
      });
      var initPanes = this.$element.find('.is-active');

      if (initPanes.length) {
        var _this = this;

        initPanes.each(function () {
          _this.down((0, _jquery2.default)(this));
        });
      }

      this._events();
    }
    /**
     * Adds event handlers for items within the menu.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      this.$element.find('li').each(function () {
        var $submenu = (0, _jquery2.default)(this).children('[data-submenu]');

        if ($submenu.length) {
          if (_this.options.submenuToggle) {
            (0, _jquery2.default)(this).children('.submenu-toggle').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {
              _this.toggle($submenu);
            });
          } else {
            (0, _jquery2.default)(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {
              e.preventDefault();

              _this.toggle($submenu);
            });
          }
        }
      }).on('keydown.zf.accordionmenu', function (e) {
        var $element = (0, _jquery2.default)(this),
            $elements = $element.parent('ul').children('li'),
            $prevElement,
            $nextElement,
            $target = $element.children('[data-submenu]');
        $elements.each(function (i) {
          if ((0, _jquery2.default)(this).is($element)) {
            $prevElement = $elements.eq(Math.max(0, i - 1)).find('a').first();
            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1)).find('a').first();

            if ((0, _jquery2.default)(this).children('[data-submenu]:visible').length) {
              // has open sub menu
              $nextElement = $element.find('li:first-child').find('a').first();
            }

            if ((0, _jquery2.default)(this).is(':first-child')) {
              // is first element of sub menu
              $prevElement = $element.parents('li').first().find('a').first();
            } else if ($prevElement.parents('li').first().children('[data-submenu]:visible').length) {
              // if previous element has open sub menu
              $prevElement = $prevElement.parents('li').find('li:last-child').find('a').first();
            }

            if ((0, _jquery2.default)(this).is(':last-child')) {
              // is last element of sub menu
              $nextElement = $element.parents('li').first().next('li').find('a').first();
            }

            return;
          }
        });
        Keyboard.handleKey(e, 'AccordionMenu', {
          open: function open() {
            if ($target.is(':hidden')) {
              _this.down($target);

              $target.find('li').first().find('a').first().focus();
            }
          },
          close: function close() {
            if ($target.length && !$target.is(':hidden')) {
              // close active sub of this item
              _this.up($target);
            } else if ($element.parent('[data-submenu]').length) {
              // close currently open sub
              _this.up($element.parent('[data-submenu]'));

              $element.parents('li').first().find('a').first().focus();
            }
          },
          up: function up() {
            $prevElement.focus();
            return true;
          },
          down: function down() {
            $nextElement.focus();
            return true;
          },
          toggle: function toggle() {
            if (_this.options.submenuToggle) {
              return false;
            }

            if ($element.children('[data-submenu]').length) {
              _this.toggle($element.children('[data-submenu]'));

              return true;
            }
          },
          closeAll: function closeAll() {
            _this.hideAll();
          },
          handled: function handled(preventDefault) {
            if (preventDefault) {
              e.preventDefault();
            }

            e.stopImmediatePropagation();
          }
        });
      }); //.attr('tabindex', 0);
    }
    /**
     * Closes all panes of the menu.
     * @function
     */

  }, {
    key: "hideAll",
    value: function hideAll() {
      this.up(this.$element.find('[data-submenu]'));
    }
    /**
     * Opens all panes of the menu.
     * @function
     */

  }, {
    key: "showAll",
    value: function showAll() {
      this.down(this.$element.find('[data-submenu]'));
    }
    /**
     * Toggles the open/close state of a submenu.
     * @function
     * @param {jQuery} $target - the submenu to toggle
     */

  }, {
    key: "toggle",
    value: function toggle($target) {
      if (!$target.is(':animated')) {
        if (!$target.is(':hidden')) {
          this.up($target);
        } else {
          this.down($target);
        }
      }
    }
    /**
     * Opens the sub-menu defined by `$target`.
     * @param {jQuery} $target - Sub-menu to open.
     * @fires AccordionMenu#down
     */

  }, {
    key: "down",
    value: function down($target) {
      var _this2 = this;

      if (!this.options.multiOpen) {
        this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element).add($target)));
      }

      $target.addClass('is-active').attr({
        'aria-hidden': false
      });

      if (this.options.submenuToggle) {
        $target.prev('.submenu-toggle').attr({
          'aria-expanded': true
        });
      } else {
        $target.parent('.is-accordion-submenu-parent').attr({
          'aria-expanded': true
        });
      }

      $target.slideDown(this.options.slideSpeed, function () {
        /**
         * Fires when the menu is done opening.
         * @event AccordionMenu#down
         */
        _this2.$element.trigger('down.zf.accordionMenu', [$target]);
      });
    }
    /**
     * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.
     * @param {jQuery} $target - Sub-menu to close.
     * @fires AccordionMenu#up
     */

  }, {
    key: "up",
    value: function up($target) {
      var _this3 = this;

      var $submenus = $target.find('[data-submenu]');
      var $allmenus = $target.add($submenus);
      $submenus.slideUp(0);
      $allmenus.removeClass('is-active').attr('aria-hidden', true);

      if (this.options.submenuToggle) {
        $allmenus.prev('.submenu-toggle').attr('aria-expanded', false);
      } else {
        $allmenus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);
      }

      $target.slideUp(this.options.slideSpeed, function () {
        /**
         * Fires when the menu is done collapsing up.
         * @event AccordionMenu#up
         */
        _this3.$element.trigger('up.zf.accordionMenu', [$target]);
      });
    }
    /**
     * Destroys an instance of accordion menu.
     * @fires AccordionMenu#destroyed
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.find('[data-submenu]').slideDown(0).css('display', '');
      this.$element.find('a').off('click.zf.accordionMenu');
      this.$element.find('[data-is-parent-link]').detach();

      if (this.options.submenuToggle) {
        this.$element.find('.has-submenu-toggle').removeClass('has-submenu-toggle');
        this.$element.find('.submenu-toggle').remove();
      }

      Nest.Burn(this.$element, 'accordion');
    }
  }]);

  return AccordionMenu;
}(Plugin);

AccordionMenu.defaults = {
  /**
   * Adds the parent link to the submenu.
   * @option
   * @type {boolean}
   * @default false
   */
  parentLink: false,

  /**
   * Amount of time to animate the opening of a submenu in ms.
   * @option
   * @type {number}
   * @default 250
   */
  slideSpeed: 250,

  /**
   * Adds a separate submenu toggle button. This allows the parent item to have a link.
   * @option
   * @example true
   */
  submenuToggle: false,

  /**
   * The text used for the submenu toggle if enabled. This is used for screen readers only.
   * @option
   * @example true
   */
  submenuToggleText: 'Toggle menu',

  /**
   * Allow the menu to have multiple open panes.
   * @option
   * @type {boolean}
   * @default true
   */
  multiOpen: true
};

/**
 * Drilldown module.
 * @module foundation.drilldown
 * @requires foundation.util.keyboard
 * @requires foundation.util.nest
 * @requires foundation.util.box
 */

var Drilldown =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Drilldown, _Plugin);

  function Drilldown() {
    _classCallCheck(this, Drilldown);

    return _possibleConstructorReturn(this, _getPrototypeOf(Drilldown).apply(this, arguments));
  }

  _createClass(Drilldown, [{
    key: "_setup",

    /**
     * Creates a new instance of a drilldown menu.
     * @class
     * @name Drilldown
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Drilldown.defaults, this.$element.data(), options);
      this.className = 'Drilldown'; // ie9 back compat

      this._init();

      Keyboard.register('Drilldown', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'previous',
        'ESCAPE': 'close',
        'TAB': 'down',
        'SHIFT_TAB': 'up'
      });
    }
    /**
     * Initializes the drilldown by creating jQuery collections of elements
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      Nest.Feather(this.$element, 'drilldown');

      if (this.options.autoApplyClass) {
        this.$element.addClass('drilldown');
      }

      this.$element.attr({
        'role': 'tree',
        'aria-multiselectable': false
      });
      this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent').children('a');
      this.$submenus = this.$submenuAnchors.parent('li').children('[data-submenu]').attr('role', 'group');
      this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'treeitem').find('a'); // Set the main menu as current by default (unless a submenu is selected)
      // Used to set the wrapper height when the drilldown is closed/reopened from any (sub)menu

      this.$currentMenu = this.$element;
      this.$element.attr('data-mutate', this.$element.attr('data-drilldown') || GetYoDigits(6, 'drilldown'));

      this._prepareMenu();

      this._registerEvents();

      this._keyboardEvents();
    }
    /**
     * prepares drilldown menu by setting attributes to links and elements
     * sets a min height to prevent content jumping
     * wraps the element if not already wrapped
     * @private
     * @function
     */

  }, {
    key: "_prepareMenu",
    value: function _prepareMenu() {
      var _this = this; // if(!this.options.holdOpen){
      //   this._menuLinkEvents();
      // }


      this.$submenuAnchors.each(function () {
        var $link = (0, _jquery2.default)(this);
        var $sub = $link.parent();

        if (_this.options.parentLink) {
          $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li data-is-parent-link class="is-submenu-parent-item is-submenu-item is-drilldown-submenu-item" role="menuitem"></li>');
        }

        $link.data('savedHref', $link.attr('href')).removeAttr('href').attr('tabindex', 0);
        $link.children('[data-submenu]').attr({
          'aria-hidden': true,
          'tabindex': 0,
          'role': 'group'
        });

        _this._events($link);
      });
      this.$submenus.each(function () {
        var $menu = (0, _jquery2.default)(this),
            $back = $menu.find('.js-drilldown-back');

        if (!$back.length) {
          switch (_this.options.backButtonPosition) {
            case "bottom":
              $menu.append(_this.options.backButton);
              break;

            case "top":
              $menu.prepend(_this.options.backButton);
              break;

            default:
              console.error("Unsupported backButtonPosition value '" + _this.options.backButtonPosition + "'");
          }
        }

        _this._back($menu);
      });
      this.$submenus.addClass('invisible');

      if (!this.options.autoHeight) {
        this.$submenus.addClass('drilldown-submenu-cover-previous');
      } // create a wrapper on element if it doesn't exist.


      if (!this.$element.parent().hasClass('is-drilldown')) {
        this.$wrapper = (0, _jquery2.default)(this.options.wrapper).addClass('is-drilldown');
        if (this.options.animateHeight) this.$wrapper.addClass('animate-height');
        this.$element.wrap(this.$wrapper);
      } // set wrapper


      this.$wrapper = this.$element.parent();
      this.$wrapper.css(this._getMaxDims());
    }
  }, {
    key: "_resize",
    value: function _resize() {
      this.$wrapper.css({
        'max-width': 'none',
        'min-height': 'none'
      }); // _getMaxDims has side effects (boo) but calling it should update all other necessary heights & widths

      this.$wrapper.css(this._getMaxDims());
    }
    /**
     * Adds event handlers to elements in the menu.
     * @function
     * @private
     * @param {jQuery} $elem - the current menu item to add handlers to.
     */

  }, {
    key: "_events",
    value: function _events($elem) {
      var _this = this;

      $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
        if ((0, _jquery2.default)(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {
          e.stopImmediatePropagation();
          e.preventDefault();
        } // if(e.target !== e.currentTarget.firstElementChild){
        //   return false;
        // }


        _this._show($elem.parent('li'));

        if (_this.options.closeOnClick) {
          var $body = (0, _jquery2.default)('body');
          $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {
            if (e.target === _this.$element[0] || _jquery2.default.contains(_this.$element[0], e.target)) {
              return;
            }

            e.preventDefault();

            _this._hideAll();

            $body.off('.zf.drilldown');
          });
        }
      });
    }
    /**
     * Adds event handlers to the menu element.
     * @function
     * @private
     */

  }, {
    key: "_registerEvents",
    value: function _registerEvents() {
      if (this.options.scrollTop) {
        this._bindHandler = this._scrollTop.bind(this);
        this.$element.on('open.zf.drilldown hide.zf.drilldown closed.zf.drilldown', this._bindHandler);
      }

      this.$element.on('mutateme.zf.trigger', this._resize.bind(this));
    }
    /**
     * Scroll to Top of Element or data-scroll-top-element
     * @function
     * @fires Drilldown#scrollme
     */

  }, {
    key: "_scrollTop",
    value: function _scrollTop() {
      var _this = this;

      var $scrollTopElement = _this.options.scrollTopElement != '' ? (0, _jquery2.default)(_this.options.scrollTopElement) : _this.$element,
          scrollPos = parseInt($scrollTopElement.offset().top + _this.options.scrollTopOffset, 10);
      (0, _jquery2.default)('html, body').stop(true).animate({
        scrollTop: scrollPos
      }, _this.options.animationDuration, _this.options.animationEasing, function () {
        /**
          * Fires after the menu has scrolled
          * @event Drilldown#scrollme
          */
        if (this === (0, _jquery2.default)('html')[0]) _this.$element.trigger('scrollme.zf.drilldown');
      });
    }
    /**
     * Adds keydown event listener to `li`'s in the menu.
     * @private
     */

  }, {
    key: "_keyboardEvents",
    value: function _keyboardEvents() {
      var _this = this;

      this.$menuItems.add(this.$element.find('.js-drilldown-back > a, .is-submenu-parent-item > a')).on('keydown.zf.drilldown', function (e) {
        var $element = (0, _jquery2.default)(this),
            $elements = $element.parent('li').parent('ul').children('li').children('a'),
            $prevElement,
            $nextElement;
        $elements.each(function (i) {
          if ((0, _jquery2.default)(this).is($element)) {
            $prevElement = $elements.eq(Math.max(0, i - 1));
            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));
            return;
          }
        });
        Keyboard.handleKey(e, 'Drilldown', {
          next: function next() {
            if ($element.is(_this.$submenuAnchors)) {
              _this._show($element.parent('li'));

              $element.parent('li').one(transitionend($element), function () {
                $element.parent('li').find('ul li a').not('.js-drilldown-back a').first().focus();
              });
              return true;
            }
          },
          previous: function previous() {
            _this._hide($element.parent('li').parent('ul'));

            $element.parent('li').parent('ul').one(transitionend($element), function () {
              setTimeout(function () {
                $element.parent('li').parent('ul').parent('li').children('a').first().focus();
              }, 1);
            });
            return true;
          },
          up: function up() {
            $prevElement.focus(); // Don't tap focus on first element in root ul

            return !$element.is(_this.$element.find('> li:first-child > a'));
          },
          down: function down() {
            $nextElement.focus(); // Don't tap focus on last element in root ul

            return !$element.is(_this.$element.find('> li:last-child > a'));
          },
          close: function close() {
            // Don't close on element in root ul
            if (!$element.is(_this.$element.find('> li > a'))) {
              _this._hide($element.parent().parent());

              $element.parent().parent().siblings('a').focus();
            }
          },
          open: function open() {
            if (_this.options.parentLink && $element.attr('href')) {
              // Link with href
              return false;
            } else if (!$element.is(_this.$menuItems)) {
              // not menu item means back button
              _this._hide($element.parent('li').parent('ul'));

              $element.parent('li').parent('ul').one(transitionend($element), function () {
                setTimeout(function () {
                  $element.parent('li').parent('ul').parent('li').children('a').first().focus();
                }, 1);
              });
              return true;
            } else if ($element.is(_this.$submenuAnchors)) {
              // Sub menu item
              _this._show($element.parent('li'));

              $element.parent('li').one(transitionend($element), function () {
                $element.parent('li').find('ul li a').not('.js-drilldown-back a').first().focus();
              });
              return true;
            }
          },
          handled: function handled(preventDefault) {
            if (preventDefault) {
              e.preventDefault();
            }

            e.stopImmediatePropagation();
          }
        });
      }); // end keyboardAccess
    }
    /**
     * Closes all open elements, and returns to root menu.
     * @function
     * @fires Drilldown#closed
     */

  }, {
    key: "_hideAll",
    value: function _hideAll() {
      var $elem = this.$element.find('.is-drilldown-submenu.is-active').addClass('is-closing');
      if (this.options.autoHeight) this.$wrapper.css({
        height: $elem.parent().closest('ul').data('calcHeight')
      });
      $elem.one(transitionend($elem), function (e) {
        $elem.removeClass('is-active is-closing');
      });
      /**
       * Fires when the menu is fully closed.
       * @event Drilldown#closed
       */

      this.$element.trigger('closed.zf.drilldown');
    }
    /**
     * Adds event listener for each `back` button, and closes open menus.
     * @function
     * @fires Drilldown#back
     * @param {jQuery} $elem - the current sub-menu to add `back` event.
     */

  }, {
    key: "_back",
    value: function _back($elem) {
      var _this = this;

      $elem.off('click.zf.drilldown');
      $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {
        e.stopImmediatePropagation(); // console.log('mouseup on back');

        _this._hide($elem); // If there is a parent submenu, call show


        var parentSubMenu = $elem.parent('li').parent('ul').parent('li');

        if (parentSubMenu.length) {
          _this._show(parentSubMenu);
        }
      });
    }
    /**
     * Adds event listener to menu items w/o submenus to close open menus on click.
     * @function
     * @private
     */

  }, {
    key: "_menuLinkEvents",
    value: function _menuLinkEvents() {
      var _this = this;

      this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
        // e.stopImmediatePropagation();
        setTimeout(function () {
          _this._hideAll();
        }, 0);
      });
    }
    /**
     * Sets the CSS classes for submenu to show it.
     * @function
     * @private
     * @param {jQuery} $elem - the target submenu (`ul` tag)
     * @param {boolean} trigger - trigger drilldown event
     */

  }, {
    key: "_setShowSubMenuClasses",
    value: function _setShowSubMenuClasses($elem, trigger) {
      $elem.addClass('is-active').removeClass('invisible').attr('aria-hidden', false);
      $elem.parent('li').attr('aria-expanded', true);

      if (trigger === true) {
        this.$element.trigger('open.zf.drilldown', [$elem]);
      }
    }
    /**
     * Sets the CSS classes for submenu to hide it.
     * @function
     * @private
     * @param {jQuery} $elem - the target submenu (`ul` tag)
     * @param {boolean} trigger - trigger drilldown event
     */

  }, {
    key: "_setHideSubMenuClasses",
    value: function _setHideSubMenuClasses($elem, trigger) {
      $elem.removeClass('is-active').addClass('invisible').attr('aria-hidden', true);
      $elem.parent('li').attr('aria-expanded', false);

      if (trigger === true) {
        $elem.trigger('hide.zf.drilldown', [$elem]);
      }
    }
    /**
     * Opens a specific drilldown (sub)menu no matter which (sub)menu in it is currently visible.
     * Compared to _show() this lets you jump into any submenu without clicking through every submenu on the way to it.
     * @function
     * @fires Drilldown#open
     * @param {jQuery} $elem - the target (sub)menu (`ul` tag)
     * @param {boolean} autoFocus - if true the first link in the target (sub)menu gets auto focused
     */

  }, {
    key: "_showMenu",
    value: function _showMenu($elem, autoFocus) {
      var _this = this; // Reset drilldown


      var $expandedSubmenus = this.$element.find('li[aria-expanded="true"] > ul[data-submenu]');
      $expandedSubmenus.each(function (index) {
        _this._setHideSubMenuClasses((0, _jquery2.default)(this));
      }); // Save the menu as the currently displayed one.

      this.$currentMenu = $elem; // If target menu is root, focus first link & exit

      if ($elem.is('[data-drilldown]')) {
        if (autoFocus === true) $elem.find('li[role="treeitem"] > a').first().focus();
        if (this.options.autoHeight) this.$wrapper.css('height', $elem.data('calcHeight'));
        return;
      } // Find all submenus on way to root incl. the element itself


      var $submenus = $elem.children().first().parentsUntil('[data-drilldown]', '[data-submenu]'); // Open target menu and all submenus on its way to root

      $submenus.each(function (index) {
        // Update height of first child (target menu) if autoHeight option true
        if (index === 0 && _this.options.autoHeight) {
          _this.$wrapper.css('height', (0, _jquery2.default)(this).data('calcHeight'));
        }

        var isLastChild = index == $submenus.length - 1; // Add transitionsend listener to last child (root due to reverse order) to open target menu's first link
        // Last child makes sure the event gets always triggered even if going through several menus

        if (isLastChild === true) {
          (0, _jquery2.default)(this).one(transitionend((0, _jquery2.default)(this)), function () {
            if (autoFocus === true) {
              $elem.find('li[role="treeitem"] > a').first().focus();
            }
          });
        }

        _this._setShowSubMenuClasses((0, _jquery2.default)(this), isLastChild);
      });
    }
    /**
     * Opens a submenu.
     * @function
     * @fires Drilldown#open
     * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.
     */

  }, {
    key: "_show",
    value: function _show($elem) {
      var $submenu = $elem.children('[data-submenu]');
      $elem.attr('aria-expanded', true);
      this.$currentMenu = $submenu;
      $submenu.addClass('is-active').removeClass('invisible').attr('aria-hidden', false);

      if (this.options.autoHeight) {
        this.$wrapper.css({
          height: $submenu.data('calcHeight')
        });
      }
      /**
       * Fires when the submenu has opened.
       * @event Drilldown#open
       */

      this.$element.trigger('open.zf.drilldown', [$elem]);
    }
    /**
     * Hides a submenu
     * @function
     * @fires Drilldown#hide
     * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.
     */

  }, {
    key: "_hide",
    value: function _hide($elem) {
      if (this.options.autoHeight) this.$wrapper.css({
        height: $elem.parent().closest('ul').data('calcHeight')
      });

      $elem.parent('li').attr('aria-expanded', false);
      $elem.attr('aria-hidden', true);
      $elem.addClass('is-closing').one(transitionend($elem), function () {
        $elem.removeClass('is-active is-closing');
        $elem.blur().addClass('invisible');
      });
      /**
       * Fires when the submenu has closed.
       * @event Drilldown#hide
       */

      $elem.trigger('hide.zf.drilldown', [$elem]);
    }
    /**
     * Iterates through the nested menus to calculate the min-height, and max-width for the menu.
     * Prevents content jumping.
     * @function
     * @private
     */

  }, {
    key: "_getMaxDims",
    value: function _getMaxDims() {
      var maxHeight = 0,
          result = {},
          _this = this; // Recalculate menu heights and total max height


      this.$submenus.add(this.$element).each(function () {
        var numOfElems = (0, _jquery2.default)(this).children('li').length;
        var height = Box.GetDimensions(this).height;
        maxHeight = height > maxHeight ? height : maxHeight;

        if (_this.options.autoHeight) {
          (0, _jquery2.default)(this).data('calcHeight', height);
        }
      });
      if (this.options.autoHeight) result['height'] = this.$currentMenu.data('calcHeight');else result['min-height'] = "".concat(maxHeight, "px");
      result['max-width'] = "".concat(this.$element[0].getBoundingClientRect().width, "px");
      return result;
    }
    /**
     * Destroys the Drilldown Menu
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      if (this.options.scrollTop) this.$element.off('.zf.drilldown', this._bindHandler);

      this._hideAll();

      this.$element.off('mutateme.zf.trigger');
      Nest.Burn(this.$element, 'drilldown');
      this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');
      this.$submenuAnchors.each(function () {
        (0, _jquery2.default)(this).off('.zf.drilldown');
      });
      this.$element.find('[data-is-parent-link]').detach();
      this.$submenus.removeClass('drilldown-submenu-cover-previous invisible');
      this.$element.find('a').each(function () {
        var $link = (0, _jquery2.default)(this);
        $link.removeAttr('tabindex');

        if ($link.data('savedHref')) {
          $link.attr('href', $link.data('savedHref')).removeData('savedHref');
        } else {
          return;
        }
      });
    }
  }]);

  return Drilldown;
}(Plugin);

Drilldown.defaults = {
  /**
   * Drilldowns depend on styles in order to function properly; in the default build of Foundation these are
   * on the `drilldown` class. This option auto-applies this class to the drilldown upon initialization.
   * @option
   * @type {boolian}
   * @default true
   */
  autoApplyClass: true,

  /**
   * Markup used for JS generated back button. Prepended  or appended (see backButtonPosition) to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\`) if copy and pasting.
   * @option
   * @type {string}
   * @default '<li class="js-drilldown-back"><a tabindex="0">Back</a></li>'
   */
  backButton: '<li class="js-drilldown-back"><a tabindex="0">Back</a></li>',

  /**
   * Position the back button either at the top or bottom of drilldown submenus. Can be `'left'` or `'bottom'`.
   * @option
   * @type {string}
   * @default top
   */
  backButtonPosition: 'top',

  /**
   * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\`) if copy and pasting.
   * @option
   * @type {string}
   * @default '<div></div>'
   */
  wrapper: '<div></div>',

  /**
   * Adds the parent link to the submenu.
   * @option
   * @type {boolean}
   * @default false
   */
  parentLink: false,

  /**
   * Allow the menu to return to root list on body click.
   * @option
   * @type {boolean}
   * @default false
   */
  closeOnClick: false,

  /**
   * Allow the menu to auto adjust height.
   * @option
   * @type {boolean}
   * @default false
   */
  autoHeight: false,

  /**
   * Animate the auto adjust height.
   * @option
   * @type {boolean}
   * @default false
   */
  animateHeight: false,

  /**
   * Scroll to the top of the menu after opening a submenu or navigating back using the menu back button
   * @option
   * @type {boolean}
   * @default false
   */
  scrollTop: false,

  /**
   * String jquery selector (for example 'body') of element to take offset().top from, if empty string the drilldown menu offset().top is taken
   * @option
   * @type {string}
   * @default ''
   */
  scrollTopElement: '',

  /**
   * ScrollTop offset
   * @option
   * @type {number}
   * @default 0
   */
  scrollTopOffset: 0,

  /**
   * Scroll animation duration
   * @option
   * @type {number}
   * @default 500
   */
  animationDuration: 500,

  /**
   * Scroll animation easing. Can be `'swing'` or `'linear'`.
   * @option
   * @type {string}
   * @see {@link https://api.jquery.com/animate|JQuery animate}
   * @default 'swing'
   */
  animationEasing: 'swing' // holdOpen: false

};

var POSITIONS = ['left', 'right', 'top', 'bottom'];
var VERTICAL_ALIGNMENTS = ['top', 'bottom', 'center'];
var HORIZONTAL_ALIGNMENTS = ['left', 'right', 'center'];
var ALIGNMENTS = {
  'left': VERTICAL_ALIGNMENTS,
  'right': VERTICAL_ALIGNMENTS,
  'top': HORIZONTAL_ALIGNMENTS,
  'bottom': HORIZONTAL_ALIGNMENTS
};

function nextItem(item, array) {
  var currentIdx = array.indexOf(item);

  if (currentIdx === array.length - 1) {
    return array[0];
  } else {
    return array[currentIdx + 1];
  }
}

var Positionable =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Positionable, _Plugin);

  function Positionable() {
    _classCallCheck(this, Positionable);

    return _possibleConstructorReturn(this, _getPrototypeOf(Positionable).apply(this, arguments));
  }

  _createClass(Positionable, [{
    key: "_init",

    /**
     * Abstract class encapsulating the tether-like explicit positioning logic
     * including repositioning based on overlap.
     * Expects classes to define defaults for vOffset, hOffset, position,
     * alignment, allowOverlap, and allowBottomOverlap. They can do this by
     * extending the defaults, or (for now recommended due to the way docs are
     * generated) by explicitly declaring them.
     *
     **/
    value: function _init() {
      this.triedPositions = {};
      this.position = this.options.position === 'auto' ? this._getDefaultPosition() : this.options.position;
      this.alignment = this.options.alignment === 'auto' ? this._getDefaultAlignment() : this.options.alignment;
      this.originalPosition = this.position;
      this.originalAlignment = this.alignment;
    }
  }, {
    key: "_getDefaultPosition",
    value: function _getDefaultPosition() {
      return 'bottom';
    }
  }, {
    key: "_getDefaultAlignment",
    value: function _getDefaultAlignment() {
      switch (this.position) {
        case 'bottom':
        case 'top':
          return rtl() ? 'right' : 'left';

        case 'left':
        case 'right':
          return 'bottom';
      }
    }
    /**
     * Adjusts the positionable possible positions by iterating through alignments
     * and positions.
     * @function
     * @private
     */

  }, {
    key: "_reposition",
    value: function _reposition() {
      if (this._alignmentsExhausted(this.position)) {
        this.position = nextItem(this.position, POSITIONS);
        this.alignment = ALIGNMENTS[this.position][0];
      } else {
        this._realign();
      }
    }
    /**
     * Adjusts the dropdown pane possible positions by iterating through alignments
     * on the current position.
     * @function
     * @private
     */

  }, {
    key: "_realign",
    value: function _realign() {
      this._addTriedPosition(this.position, this.alignment);

      this.alignment = nextItem(this.alignment, ALIGNMENTS[this.position]);
    }
  }, {
    key: "_addTriedPosition",
    value: function _addTriedPosition(position, alignment) {
      this.triedPositions[position] = this.triedPositions[position] || [];
      this.triedPositions[position].push(alignment);
    }
  }, {
    key: "_positionsExhausted",
    value: function _positionsExhausted() {
      var isExhausted = true;

      for (var i = 0; i < POSITIONS.length; i++) {
        isExhausted = isExhausted && this._alignmentsExhausted(POSITIONS[i]);
      }

      return isExhausted;
    }
  }, {
    key: "_alignmentsExhausted",
    value: function _alignmentsExhausted(position) {
      return this.triedPositions[position] && this.triedPositions[position].length == ALIGNMENTS[position].length;
    } // When we're trying to center, we don't want to apply offset that's going to
    // take us just off center, so wrap around to return 0 for the appropriate
    // offset in those alignments.  TODO: Figure out if we want to make this
    // configurable behavior... it feels more intuitive, especially for tooltips, but
    // it's possible someone might actually want to start from center and then nudge
    // slightly off.

  }, {
    key: "_getVOffset",
    value: function _getVOffset() {
      return this.options.vOffset;
    }
  }, {
    key: "_getHOffset",
    value: function _getHOffset() {
      return this.options.hOffset;
    }
  }, {
    key: "_setPosition",
    value: function _setPosition($anchor, $element, $parent) {
      if ($anchor.attr('aria-expanded') === 'false') {
        return false;
      }

      var $eleDims = Box.GetDimensions($element),
          $anchorDims = Box.GetDimensions($anchor);

      if (!this.options.allowOverlap) {
        // restore original position & alignment before checking overlap
        this.position = this.originalPosition;
        this.alignment = this.originalAlignment;
      }

      $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));

      if (!this.options.allowOverlap) {
        var minOverlap = 100000000; // default coordinates to how we start, in case we can't figure out better

        var minCoordinates = {
          position: this.position,
          alignment: this.alignment
        };

        while (!this._positionsExhausted()) {
          var overlap = Box.OverlapArea($element, $parent, false, false, this.options.allowBottomOverlap);

          if (overlap === 0) {
            return;
          }

          if (overlap < minOverlap) {
            minOverlap = overlap;
            minCoordinates = {
              position: this.position,
              alignment: this.alignment
            };
          }

          this._reposition();

          $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
        } // If we get through the entire loop, there was no non-overlapping
        // position available. Pick the version with least overlap.


        this.position = minCoordinates.position;
        this.alignment = minCoordinates.alignment;
        $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
      }
    }
  }]);

  return Positionable;
}(Plugin);

Positionable.defaults = {
  /**
   * Position of positionable relative to anchor. Can be left, right, bottom, top, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  position: 'auto',

  /**
   * Alignment of positionable relative to anchor. Can be left, right, bottom, top, center, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  alignment: 'auto',

  /**
   * Allow overlap of container/window. If false, dropdown positionable first
   * try to position as defined by data-position and data-alignment, but
   * reposition if it would cause an overflow.
   * @option
   * @type {boolean}
   * @default false
   */
  allowOverlap: false,

  /**
   * Allow overlap of only the bottom of the container. This is the most common
   * behavior for dropdowns, allowing the dropdown to extend the bottom of the
   * screen but not otherwise influence or break out of the container.
   * @option
   * @type {boolean}
   * @default true
   */
  allowBottomOverlap: true,

  /**
   * Number of pixels the positionable should be separated vertically from anchor
   * @option
   * @type {number}
   * @default 0
   */
  vOffset: 0,

  /**
   * Number of pixels the positionable should be separated horizontally from anchor
   * @option
   * @type {number}
   * @default 0
   */
  hOffset: 0
};

/**
 * Dropdown module.
 * @module foundation.dropdown
 * @requires foundation.util.keyboard
 * @requires foundation.util.box
 * @requires foundation.util.triggers
 */

var Dropdown =
/*#__PURE__*/
function (_Positionable) {
  _inherits(Dropdown, _Positionable);

  function Dropdown() {
    _classCallCheck(this, Dropdown);

    return _possibleConstructorReturn(this, _getPrototypeOf(Dropdown).apply(this, arguments));
  }

  _createClass(Dropdown, [{
    key: "_setup",

    /**
     * Creates a new instance of a dropdown.
     * @class
     * @name Dropdown
     * @param {jQuery} element - jQuery object to make into a dropdown.
     *        Object should be of the dropdown panel, rather than its anchor.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Dropdown.defaults, this.$element.data(), options);
      this.className = 'Dropdown'; // ie9 back compat
      // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      this._init();

      Keyboard.register('Dropdown', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ESCAPE': 'close'
      });
    }
    /**
     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var $id = this.$element.attr('id');
      this.$anchors = (0, _jquery2.default)("[data-toggle=\"".concat($id, "\"]")).length ? (0, _jquery2.default)("[data-toggle=\"".concat($id, "\"]")) : (0, _jquery2.default)("[data-open=\"".concat($id, "\"]"));
      this.$anchors.attr({
        'aria-controls': $id,
        'data-is-focus': false,
        'data-yeti-box': $id,
        'aria-haspopup': true,
        'aria-expanded': false
      });

      this._setCurrentAnchor(this.$anchors.first());

      if (this.options.parentClass) {
        this.$parent = this.$element.parents('.' + this.options.parentClass);
      } else {
        this.$parent = null;
      } // Set [aria-labelledby] on the Dropdown if it is not set


      if (typeof this.$element.attr('aria-labelledby') === 'undefined') {
        // Get the anchor ID or create one
        if (typeof this.$currentAnchor.attr('id') === 'undefined') {
          this.$currentAnchor.attr('id', GetYoDigits(6, 'dd-anchor'));
        }
        this.$element.attr('aria-labelledby', this.$currentAnchor.attr('id'));
      }

      this.$element.attr({
        'aria-hidden': 'true',
        'data-yeti-box': $id,
        'data-resize': $id
      });

      _get(_getPrototypeOf(Dropdown.prototype), "_init", this).call(this);

      this._events();
    }
  }, {
    key: "_getDefaultPosition",
    value: function _getDefaultPosition() {
      // handle legacy classnames
      var position = this.$element[0].className.match(/(top|left|right|bottom)/g);

      if (position) {
        return position[0];
      } else {
        return 'bottom';
      }
    }
  }, {
    key: "_getDefaultAlignment",
    value: function _getDefaultAlignment() {
      // handle legacy float approach
      var horizontalPosition = /float-(\S+)/.exec(this.$currentAnchor.attr('class'));

      if (horizontalPosition) {
        return horizontalPosition[1];
      }

      return _get(_getPrototypeOf(Dropdown.prototype), "_getDefaultAlignment", this).call(this);
    }
    /**
     * Sets the position and orientation of the dropdown pane, checks for collisions if allow-overlap is not true.
     * Recursively calls itself if a collision is detected, with a new position class.
     * @function
     * @private
     */

  }, {
    key: "_setPosition",
    value: function _setPosition() {
      this.$element.removeClass("has-position-".concat(this.position, " has-alignment-").concat(this.alignment));

      _get(_getPrototypeOf(Dropdown.prototype), "_setPosition", this).call(this, this.$currentAnchor, this.$element, this.$parent);

      this.$element.addClass("has-position-".concat(this.position, " has-alignment-").concat(this.alignment));
    }
    /**
     * Make it a current anchor.
     * Current anchor as the reference for the position of Dropdown panes.
     * @param {HTML} el - DOM element of the anchor.
     * @function
     * @private
     */

  }, {
    key: "_setCurrentAnchor",
    value: function _setCurrentAnchor(el) {
      this.$currentAnchor = (0, _jquery2.default)(el);
    }
    /**
     * Adds event listeners to the element utilizing the triggers utility library.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      this.$element.on({
        'open.zf.trigger': this.open.bind(this),
        'close.zf.trigger': this.close.bind(this),
        'toggle.zf.trigger': this.toggle.bind(this),
        'resizeme.zf.trigger': this._setPosition.bind(this)
      });
      this.$anchors.off('click.zf.trigger').on('click.zf.trigger', function () {
        _this._setCurrentAnchor(this);
      });

      if (this.options.hover) {
        this.$anchors.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {
          _this._setCurrentAnchor(this);

          var bodyData = (0, _jquery2.default)('body').data();

          if (typeof bodyData.whatinput === 'undefined' || bodyData.whatinput === 'mouse') {
            clearTimeout(_this.timeout);
            _this.timeout = setTimeout(function () {
              _this.open();

              _this.$anchors.data('hover', true);
            }, _this.options.hoverDelay);
          }
        }).on('mouseleave.zf.dropdown', ignoreMousedisappear(function () {
          clearTimeout(_this.timeout);
          _this.timeout = setTimeout(function () {
            _this.close();

            _this.$anchors.data('hover', false);
          }, _this.options.hoverDelay);
        }));

        if (this.options.hoverPane) {
          this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {
            clearTimeout(_this.timeout);
          }).on('mouseleave.zf.dropdown', ignoreMousedisappear(function () {
            clearTimeout(_this.timeout);
            _this.timeout = setTimeout(function () {
              _this.close();

              _this.$anchors.data('hover', false);
            }, _this.options.hoverDelay);
          }));
        }
      }

      this.$anchors.add(this.$element).on('keydown.zf.dropdown', function (e) {
        var $target = (0, _jquery2.default)(this),
            visibleFocusableElements = Keyboard.findFocusable(_this.$element);
        Keyboard.handleKey(e, 'Dropdown', {
          open: function open() {
            if ($target.is(_this.$anchors) && !$target.is('input, textarea')) {
              _this.open();

              _this.$element.attr('tabindex', -1).focus();

              e.preventDefault();
            }
          },
          close: function close() {
            _this.close();

            _this.$anchors.focus();
          }
        });
      });
    }
    /**
     * Adds an event handler to the body to close any dropdowns on a click.
     * @function
     * @private
     */

  }, {
    key: "_addBodyHandler",
    value: function _addBodyHandler() {
      var $body = (0, _jquery2.default)(document.body).not(this.$element),
          _this = this;

      $body.off('click.zf.dropdown').on('click.zf.dropdown', function (e) {
        if (_this.$anchors.is(e.target) || _this.$anchors.find(e.target).length) {
          return;
        }

        if (_this.$element.is(e.target) || _this.$element.find(e.target).length) {
          return;
        }

        _this.close();

        $body.off('click.zf.dropdown');
      });
    }
    /**
     * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.
     * @function
     * @fires Dropdown#closeme
     * @fires Dropdown#show
     */

  }, {
    key: "open",
    value: function open() {
      // var _this = this;

      /**
       * Fires to close other open dropdowns, typically when dropdown is opening
       * @event Dropdown#closeme
       */
      this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));
      this.$anchors.addClass('hover').attr({
        'aria-expanded': true
      }); // this.$element/*.show()*/;

      this.$element.addClass('is-opening');

      this._setPosition();

      this.$element.removeClass('is-opening').addClass('is-open').attr({
        'aria-hidden': false
      });

      if (this.options.autoFocus) {
        var $focusable = Keyboard.findFocusable(this.$element);

        if ($focusable.length) {
          $focusable.eq(0).focus();
        }
      }

      if (this.options.closeOnClick) {
        this._addBodyHandler();
      }

      if (this.options.trapFocus) {
        Keyboard.trapFocus(this.$element);
      }
      /**
       * Fires once the dropdown is visible.
       * @event Dropdown#show
       */

      this.$element.trigger('show.zf.dropdown', [this.$element]);
    }
    /**
     * Closes the open dropdown pane.
     * @function
     * @fires Dropdown#hide
     */

  }, {
    key: "close",
    value: function close() {
      if (!this.$element.hasClass('is-open')) {
        return false;
      }

      this.$element.removeClass('is-open').attr({
        'aria-hidden': true
      });
      this.$anchors.removeClass('hover').attr('aria-expanded', false);
      /**
       * Fires once the dropdown is no longer visible.
       * @event Dropdown#hide
       */

      this.$element.trigger('hide.zf.dropdown', [this.$element]);

      if (this.options.trapFocus) {
        Keyboard.releaseFocus(this.$element);
      }
    }
    /**
     * Toggles the dropdown pane's visibility.
     * @function
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this.$element.hasClass('is-open')) {
        if (this.$anchors.data('hover')) return;
        this.close();
      } else {
        this.open();
      }
    }
    /**
     * Destroys the dropdown.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.trigger').hide();
      this.$anchors.off('.zf.dropdown');
      (0, _jquery2.default)(document.body).off('click.zf.dropdown');
    }
  }]);

  return Dropdown;
}(Positionable);

Dropdown.defaults = {
  /**
   * Class that designates bounding container of Dropdown (default: window)
   * @option
   * @type {?string}
   * @default null
   */
  parentClass: null,

  /**
   * Amount of time to delay opening a submenu on hover event.
   * @option
   * @type {number}
   * @default 250
   */
  hoverDelay: 250,

  /**
   * Allow submenus to open on hover events
   * @option
   * @type {boolean}
   * @default false
   */
  hover: false,

  /**
   * Don't close dropdown when hovering over dropdown pane
   * @option
   * @type {boolean}
   * @default false
   */
  hoverPane: false,

  /**
   * Number of pixels between the dropdown pane and the triggering element on open.
   * @option
   * @type {number}
   * @default 0
   */
  vOffset: 0,

  /**
   * Number of pixels between the dropdown pane and the triggering element on open.
   * @option
   * @type {number}
   * @default 0
   */
  hOffset: 0,

  /**
   * Position of dropdown. Can be left, right, bottom, top, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  position: 'auto',

  /**
   * Alignment of dropdown relative to anchor. Can be left, right, bottom, top, center, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  alignment: 'auto',

  /**
   * Allow overlap of container/window. If false, dropdown will first try to position as defined by data-position and data-alignment, but reposition if it would cause an overflow.
   * @option
   * @type {boolean}
   * @default false
   */
  allowOverlap: false,

  /**
   * Allow overlap of only the bottom of the container. This is the most common
   * behavior for dropdowns, allowing the dropdown to extend the bottom of the
   * screen but not otherwise influence or break out of the container.
   * @option
   * @type {boolean}
   * @default true
   */
  allowBottomOverlap: true,

  /**
   * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.
   * @option
   * @type {boolean}
   * @default false
   */
  trapFocus: false,

  /**
   * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.
   * @option
   * @type {boolean}
   * @default false
   */
  autoFocus: false,

  /**
   * Allows a click on the body to close the dropdown.
   * @option
   * @type {boolean}
   * @default false
   */
  closeOnClick: false
};

/**
 * DropdownMenu module.
 * @module foundation.dropdown-menu
 * @requires foundation.util.keyboard
 * @requires foundation.util.box
 * @requires foundation.util.nest
 */

var DropdownMenu =
/*#__PURE__*/
function (_Plugin) {
  _inherits(DropdownMenu, _Plugin);

  function DropdownMenu() {
    _classCallCheck(this, DropdownMenu);

    return _possibleConstructorReturn(this, _getPrototypeOf(DropdownMenu).apply(this, arguments));
  }

  _createClass(DropdownMenu, [{
    key: "_setup",

    /**
     * Creates a new instance of DropdownMenu.
     * @class
     * @name DropdownMenu
     * @fires DropdownMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, DropdownMenu.defaults, this.$element.data(), options);
      this.className = 'DropdownMenu'; // ie9 back compat

      this._init();

      Keyboard.register('DropdownMenu', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'previous',
        'ESCAPE': 'close'
      });
    }
    /**
     * Initializes the plugin, and calls _prepareMenu
     * @private
     * @function
     */

  }, {
    key: "_init",
    value: function _init() {
      Nest.Feather(this.$element, 'dropdown');
      var subs = this.$element.find('li.is-dropdown-submenu-parent');
      this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');
      this.$menuItems = this.$element.find('[role="menuitem"]');
      this.$tabs = this.$element.children('[role="menuitem"]');
      this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);

      if (this.options.alignment === 'auto') {
        if (this.$element.hasClass(this.options.rightClass) || rtl() || this.$element.parents('.top-bar-right').is('*')) {
          this.options.alignment = 'right';
          subs.addClass('opens-left');
        } else {
          this.options.alignment = 'left';
          subs.addClass('opens-right');
        }
      } else {
        if (this.options.alignment === 'right') {
          subs.addClass('opens-left');
        } else {
          subs.addClass('opens-right');
        }
      }

      this.changed = false;

      this._events();
    }
  }, {
    key: "_isVertical",
    value: function _isVertical() {
      return this.$tabs.css('display') === 'block' || this.$element.css('flex-direction') === 'column';
    }
  }, {
    key: "_isRtl",
    value: function _isRtl() {
      return this.$element.hasClass('align-right') || rtl() && !this.$element.hasClass('align-left');
    }
    /**
     * Adds event listeners to elements within the menu
     * @private
     * @function
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this,
          hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',
          parClass = 'is-dropdown-submenu-parent'; // used for onClick and in the keyboard handlers


      var handleClickFn = function handleClickFn(e) {
        var $elem = (0, _jquery2.default)(e.target).parentsUntil('ul', ".".concat(parClass)),
            hasSub = $elem.hasClass(parClass),
            hasClicked = $elem.attr('data-is-click') === 'true',
            $sub = $elem.children('.is-dropdown-submenu');

        if (hasSub) {
          if (hasClicked) {
            if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {
              return;
            } else {
              e.stopImmediatePropagation();
              e.preventDefault();

              _this._hide($elem);
            }
          } else {
            e.preventDefault();
            e.stopImmediatePropagation();

            _this._show($sub);

            $elem.add($elem.parentsUntil(_this.$element, ".".concat(parClass))).attr('data-is-click', true);
          }
        }
      };

      if (this.options.clickOpen || hasTouch) {
        this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu', handleClickFn);
      } // Handle Leaf element Clicks


      if (_this.options.closeOnClickInside) {
        this.$menuItems.on('click.zf.dropdownmenu', function (e) {
          var $elem = (0, _jquery2.default)(this),
              hasSub = $elem.hasClass(parClass);

          if (!hasSub) {
            _this._hide();
          }
        });
      }

      if (!this.options.disableHover) {
        this.$menuItems.on('mouseenter.zf.dropdownmenu', function (e) {
          var $elem = (0, _jquery2.default)(this),
              hasSub = $elem.hasClass(parClass);

          if (hasSub) {
            clearTimeout($elem.data('_delay'));
            $elem.data('_delay', setTimeout(function () {
              _this._show($elem.children('.is-dropdown-submenu'));
            }, _this.options.hoverDelay));
          }
        }).on('mouseleave.zf.dropdownMenu', ignoreMousedisappear(function (e) {
          var $elem = (0, _jquery2.default)(this),
              hasSub = $elem.hasClass(parClass);

          if (hasSub && _this.options.autoclose) {
            if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {
              return false;
            }

            clearTimeout($elem.data('_delay'));
            $elem.data('_delay', setTimeout(function () {
              _this._hide($elem);
            }, _this.options.closingTime));
          }
        }));
      }

      this.$menuItems.on('keydown.zf.dropdownmenu', function (e) {
        var $element = (0, _jquery2.default)(e.target).parentsUntil('ul', '[role="menuitem"]'),
            isTab = _this.$tabs.index($element) > -1,
            $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),
            $prevElement,
            $nextElement;
        $elements.each(function (i) {
          if ((0, _jquery2.default)(this).is($element)) {
            $prevElement = $elements.eq(i - 1);
            $nextElement = $elements.eq(i + 1);
            return;
          }
        });

        var nextSibling = function nextSibling() {
          $nextElement.children('a:first').focus();
          e.preventDefault();
        },
            prevSibling = function prevSibling() {
          $prevElement.children('a:first').focus();
          e.preventDefault();
        },
            openSub = function openSub() {
          var $sub = $element.children('ul.is-dropdown-submenu');

          if ($sub.length) {
            _this._show($sub);

            $element.find('li > a:first').focus();
            e.preventDefault();
          } else {
            return;
          }
        },
            closeSub = function closeSub() {
          //if ($element.is(':first-child')) {
          var close = $element.parent('ul').parent('li');
          close.children('a:first').focus();

          _this._hide(close);

          e.preventDefault(); //}
        };

        var functions = {
          open: openSub,
          close: function close() {
            _this._hide(_this.$element);

            _this.$menuItems.eq(0).children('a').focus(); // focus to first element


            e.preventDefault();
          },
          handled: function handled() {
            e.stopImmediatePropagation();
          }
        };

        if (isTab) {
          if (_this._isVertical()) {
            // vertical menu
            if (_this._isRtl()) {
              // right aligned
              _jquery2.default.extend(functions, {
                down: nextSibling,
                up: prevSibling,
                next: closeSub,
                previous: openSub
              });
            } else {
              // left aligned
              _jquery2.default.extend(functions, {
                down: nextSibling,
                up: prevSibling,
                next: openSub,
                previous: closeSub
              });
            }
          } else {
            // horizontal menu
            if (_this._isRtl()) {
              // right aligned
              _jquery2.default.extend(functions, {
                next: prevSibling,
                previous: nextSibling,
                down: openSub,
                up: closeSub
              });
            } else {
              // left aligned
              _jquery2.default.extend(functions, {
                next: nextSibling,
                previous: prevSibling,
                down: openSub,
                up: closeSub
              });
            }
          }
        } else {
          // not tabs -> one sub
          if (_this._isRtl()) {
            // right aligned
            _jquery2.default.extend(functions, {
              next: closeSub,
              previous: openSub,
              down: nextSibling,
              up: prevSibling
            });
          } else {
            // left aligned
            _jquery2.default.extend(functions, {
              next: openSub,
              previous: closeSub,
              down: nextSibling,
              up: prevSibling
            });
          }
        }

        Keyboard.handleKey(e, 'DropdownMenu', functions);
      });
    }
    /**
     * Adds an event handler to the body to close any dropdowns on a click.
     * @function
     * @private
     */

  }, {
    key: "_addBodyHandler",
    value: function _addBodyHandler() {
      var $body = (0, _jquery2.default)(document.body),
          _this = this;

      $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu').on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu', function (e) {
        var $link = _this.$element.find(e.target);

        if ($link.length) {
          return;
        }

        _this._hide();

        $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');
      });
    }
    /**
     * Opens a dropdown pane, and checks for collisions first.
     * @param {jQuery} $sub - ul element that is a submenu to show
     * @function
     * @private
     * @fires Dropdownmenu#show
     */

  }, {
    key: "_show",
    value: function _show($sub) {
      var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {
        return (0, _jquery2.default)(el).find($sub).length > 0;
      }));
      var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');

      this._hide($sibs, idx);

      $sub.css('visibility', 'hidden').addClass('js-dropdown-active').parent('li.is-dropdown-submenu-parent').addClass('is-active');
      var clear = Box.ImNotTouchingYou($sub, null, true);

      if (!clear) {
        var oldClass = this.options.alignment === 'left' ? '-right' : '-left',
            $parentLi = $sub.parent('.is-dropdown-submenu-parent');
        $parentLi.removeClass("opens".concat(oldClass)).addClass("opens-".concat(this.options.alignment));
        clear = Box.ImNotTouchingYou($sub, null, true);

        if (!clear) {
          $parentLi.removeClass("opens-".concat(this.options.alignment)).addClass('opens-inner');
        }

        this.changed = true;
      }

      $sub.css('visibility', '');

      if (this.options.closeOnClick) {
        this._addBodyHandler();
      }
      /**
       * Fires when the new dropdown pane is visible.
       * @event Dropdownmenu#show
       */

      this.$element.trigger('show.zf.dropdownmenu', [$sub]);
    }
    /**
     * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.
     * @function
     * @param {jQuery} $elem - element with a submenu to hide
     * @param {Number} idx - index of the $tabs collection to hide
     * @private
     */

  }, {
    key: "_hide",
    value: function _hide($elem, idx) {
      var $toClose;

      if ($elem && $elem.length) {
        $toClose = $elem;
      } else if (typeof idx !== 'undefined') {
        $toClose = this.$tabs.not(function (i, el) {
          return i === idx;
        });
      } else {
        $toClose = this.$element;
      }

      var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;

      if (somethingToClose) {
        $toClose.find('li.is-active').add($toClose).attr({
          'data-is-click': false
        }).removeClass('is-active');
        $toClose.find('ul.js-dropdown-active').removeClass('js-dropdown-active');

        if (this.changed || $toClose.find('opens-inner').length) {
          var oldClass = this.options.alignment === 'left' ? 'right' : 'left';
          $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass("opens-inner opens-".concat(this.options.alignment)).addClass("opens-".concat(oldClass));
          this.changed = false;
        }
        /**
         * Fires when the open menus are closed.
         * @event Dropdownmenu#hide
         */

        this.$element.trigger('hide.zf.dropdownmenu', [$toClose]);
      }
    }
    /**
     * Destroys the plugin.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');
      (0, _jquery2.default)(document.body).off('.zf.dropdownmenu');
      Nest.Burn(this.$element, 'dropdown');
    }
  }]);

  return DropdownMenu;
}(Plugin);
/**
 * Default settings for plugin
 */

DropdownMenu.defaults = {
  /**
   * Disallows hover events from opening submenus
   * @option
   * @type {boolean}
   * @default false
   */
  disableHover: false,

  /**
   * Allow a submenu to automatically close on a mouseleave event, if not clicked open.
   * @option
   * @type {boolean}
   * @default true
   */
  autoclose: true,

  /**
   * Amount of time to delay opening a submenu on hover event.
   * @option
   * @type {number}
   * @default 50
   */
  hoverDelay: 50,

  /**
   * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.
   * @option
   * @type {boolean}
   * @default false
   */
  clickOpen: false,

  /**
   * Amount of time to delay closing a submenu on a mouseleave event.
   * @option
   * @type {number}
   * @default 500
   */
  closingTime: 500,

  /**
   * Position of the menu relative to what direction the submenus should open. Handled by JS. Can be `'auto'`, `'left'` or `'right'`.
   * @option
   * @type {string}
   * @default 'auto'
   */
  alignment: 'auto',

  /**
   * Allow clicks on the body to close any open submenus.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnClick: true,

  /**
   * Allow clicks on leaf anchor links to close any open submenus.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnClickInside: true,

  /**
   * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.
   * @option
   * @type {string}
   * @default 'vertical'
   */
  verticalClass: 'vertical',

  /**
   * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.
   * @option
   * @type {string}
   * @default 'align-right'
   */
  rightClass: 'align-right',

  /**
   * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.
   * @option
   * @type {boolean}
   * @default true
   */
  forceFollow: true
};

/**
 * Equalizer module.
 * @module foundation.equalizer
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.imageLoader if equalizer contains images
 */

var Equalizer =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Equalizer, _Plugin);

  function Equalizer() {
    _classCallCheck(this, Equalizer);

    return _possibleConstructorReturn(this, _getPrototypeOf(Equalizer).apply(this, arguments));
  }

  _createClass(Equalizer, [{
    key: "_setup",

    /**
     * Creates a new instance of Equalizer.
     * @class
     * @name Equalizer
     * @fires Equalizer#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Equalizer.defaults, this.$element.data(), options);
      this.className = 'Equalizer'; // ie9 back compat

      this._init();
    }
    /**
     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var eqId = this.$element.attr('data-equalizer') || '';
      var $watched = this.$element.find("[data-equalizer-watch=\"".concat(eqId, "\"]"));

      MediaQuery._init();

      this.$watched = $watched.length ? $watched : this.$element.find('[data-equalizer-watch]');
      this.$element.attr('data-resize', eqId || GetYoDigits(6, 'eq'));
      this.$element.attr('data-mutate', eqId || GetYoDigits(6, 'eq'));
      this.hasNested = this.$element.find('[data-equalizer]').length > 0;
      this.isNested = this.$element.parentsUntil(document.body, '[data-equalizer]').length > 0;
      this.isOn = false;
      this._bindHandler = {
        onResizeMeBound: this._onResizeMe.bind(this),
        onPostEqualizedBound: this._onPostEqualized.bind(this)
      };
      var imgs = this.$element.find('img');
      var tooSmall;

      if (this.options.equalizeOn) {
        tooSmall = this._checkMQ();
        (0, _jquery2.default)(window).on('changed.zf.mediaquery', this._checkMQ.bind(this));
      } else {
        this._events();
      }

      if (typeof tooSmall !== 'undefined' && tooSmall === false || typeof tooSmall === 'undefined') {
        if (imgs.length) {
          onImagesLoaded(imgs, this._reflow.bind(this));
        } else {
          this._reflow();
        }
      }
    }
    /**
     * Removes event listeners if the breakpoint is too small.
     * @private
     */

  }, {
    key: "_pauseEvents",
    value: function _pauseEvents() {
      this.isOn = false;
      this.$element.off({
        '.zf.equalizer': this._bindHandler.onPostEqualizedBound,
        'resizeme.zf.trigger': this._bindHandler.onResizeMeBound,
        'mutateme.zf.trigger': this._bindHandler.onResizeMeBound
      });
    }
    /**
     * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound
     * @private
     */

  }, {
    key: "_onResizeMe",
    value: function _onResizeMe(e) {
      this._reflow();
    }
    /**
     * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound
     * @private
     */

  }, {
    key: "_onPostEqualized",
    value: function _onPostEqualized(e) {
      if (e.target !== this.$element[0]) {
        this._reflow();
      }
    }
    /**
     * Initializes events for Equalizer.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {

      this._pauseEvents();

      if (this.hasNested) {
        this.$element.on('postequalized.zf.equalizer', this._bindHandler.onPostEqualizedBound);
      } else {
        this.$element.on('resizeme.zf.trigger', this._bindHandler.onResizeMeBound);
        this.$element.on('mutateme.zf.trigger', this._bindHandler.onResizeMeBound);
      }

      this.isOn = true;
    }
    /**
     * Checks the current breakpoint to the minimum required size.
     * @private
     */

  }, {
    key: "_checkMQ",
    value: function _checkMQ() {
      var tooSmall = !MediaQuery.is(this.options.equalizeOn);

      if (tooSmall) {
        if (this.isOn) {
          this._pauseEvents();

          this.$watched.css('height', 'auto');
        }
      } else {
        if (!this.isOn) {
          this._events();
        }
      }

      return tooSmall;
    }
    /**
     * A noop version for the plugin
     * @private
     */

  }, {
    key: "_killswitch",
    value: function _killswitch() {
      return;
    }
    /**
     * Calls necessary functions to update Equalizer upon DOM change
     * @private
     */

  }, {
    key: "_reflow",
    value: function _reflow() {
      if (!this.options.equalizeOnStack) {
        if (this._isStacked()) {
          this.$watched.css('height', 'auto');
          return false;
        }
      }

      if (this.options.equalizeByRow) {
        this.getHeightsByRow(this.applyHeightByRow.bind(this));
      } else {
        this.getHeights(this.applyHeight.bind(this));
      }
    }
    /**
     * Manually determines if the first 2 elements are *NOT* stacked.
     * @private
     */

  }, {
    key: "_isStacked",
    value: function _isStacked() {
      if (!this.$watched[0] || !this.$watched[1]) {
        return true;
      }

      return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;
    }
    /**
     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
     * @param {Function} cb - A non-optional callback to return the heights array to.
     * @returns {Array} heights - An array of heights of children within Equalizer container
     */

  }, {
    key: "getHeights",
    value: function getHeights(cb) {
      var heights = [];

      for (var i = 0, len = this.$watched.length; i < len; i++) {
        this.$watched[i].style.height = 'auto';
        heights.push(this.$watched[i].offsetHeight);
      }

      cb(heights);
    }
    /**
     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
     * @param {Function} cb - A non-optional callback to return the heights array to.
     * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
     */

  }, {
    key: "getHeightsByRow",
    value: function getHeightsByRow(cb) {
      var lastElTopOffset = this.$watched.length ? this.$watched.first().offset().top : 0,
          groups = [],
          group = 0; //group by Row

      groups[group] = [];

      for (var i = 0, len = this.$watched.length; i < len; i++) {
        this.$watched[i].style.height = 'auto'; //maybe could use this.$watched[i].offsetTop

        var elOffsetTop = (0, _jquery2.default)(this.$watched[i]).offset().top;

        if (elOffsetTop != lastElTopOffset) {
          group++;
          groups[group] = [];
          lastElTopOffset = elOffsetTop;
        }

        groups[group].push([this.$watched[i], this.$watched[i].offsetHeight]);
      }

      for (var j = 0, ln = groups.length; j < ln; j++) {
        var heights = (0, _jquery2.default)(groups[j]).map(function () {
          return this[1];
        }).get();
        var max = Math.max.apply(null, heights);
        groups[j].push(max);
      }

      cb(groups);
    }
    /**
     * Changes the CSS height property of each child in an Equalizer parent to match the tallest
     * @param {array} heights - An array of heights of children within Equalizer container
     * @fires Equalizer#preequalized
     * @fires Equalizer#postequalized
     */

  }, {
    key: "applyHeight",
    value: function applyHeight(heights) {
      var max = Math.max.apply(null, heights);
      /**
       * Fires before the heights are applied
       * @event Equalizer#preequalized
       */

      this.$element.trigger('preequalized.zf.equalizer');
      this.$watched.css('height', max);
      /**
       * Fires when the heights have been applied
       * @event Equalizer#postequalized
       */

      this.$element.trigger('postequalized.zf.equalizer');
    }
    /**
     * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row
     * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
     * @fires Equalizer#preequalized
     * @fires Equalizer#preequalizedrow
     * @fires Equalizer#postequalizedrow
     * @fires Equalizer#postequalized
     */

  }, {
    key: "applyHeightByRow",
    value: function applyHeightByRow(groups) {
      /**
       * Fires before the heights are applied
       */
      this.$element.trigger('preequalized.zf.equalizer');

      for (var i = 0, len = groups.length; i < len; i++) {
        var groupsILength = groups[i].length,
            max = groups[i][groupsILength - 1];

        if (groupsILength <= 2) {
          (0, _jquery2.default)(groups[i][0][0]).css({
            'height': 'auto'
          });
          continue;
        }
        /**
          * Fires before the heights per row are applied
          * @event Equalizer#preequalizedrow
          */

        this.$element.trigger('preequalizedrow.zf.equalizer');

        for (var j = 0, lenJ = groupsILength - 1; j < lenJ; j++) {
          (0, _jquery2.default)(groups[i][j][0]).css({
            'height': max
          });
        }
        /**
          * Fires when the heights per row have been applied
          * @event Equalizer#postequalizedrow
          */

        this.$element.trigger('postequalizedrow.zf.equalizer');
      }
      /**
       * Fires when the heights have been applied
       */

      this.$element.trigger('postequalized.zf.equalizer');
    }
    /**
     * Destroys an instance of Equalizer.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this._pauseEvents();

      this.$watched.css('height', 'auto');
    }
  }]);

  return Equalizer;
}(Plugin);
/**
 * Default settings for plugin
 */

Equalizer.defaults = {
  /**
   * Enable height equalization when stacked on smaller screens.
   * @option
   * @type {boolean}
   * @default false
   */
  equalizeOnStack: false,

  /**
   * Enable height equalization row by row.
   * @option
   * @type {boolean}
   * @default false
   */
  equalizeByRow: false,

  /**
   * String representing the minimum breakpoint size the plugin should equalize heights on.
   * @option
   * @type {string}
   * @default ''
   */
  equalizeOn: ''
};

/**
 * Interchange module.
 * @module foundation.interchange
 * @requires foundation.util.mediaQuery
 */

var Interchange =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Interchange, _Plugin);

  function Interchange() {
    _classCallCheck(this, Interchange);

    return _possibleConstructorReturn(this, _getPrototypeOf(Interchange).apply(this, arguments));
  }

  _createClass(Interchange, [{
    key: "_setup",

    /**
     * Creates a new instance of Interchange.
     * @class
     * @name Interchange
     * @fires Interchange#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Interchange.defaults, options);
      this.rules = [];
      this.currentPath = '';
      this.className = 'Interchange'; // ie9 back compat

      this._init();

      this._events();
    }
    /**
     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init();

      var id = this.$element[0].id || GetYoDigits(6, 'interchange');
      this.$element.attr({
        'data-resize': id,
        'id': id
      });

      this._addBreakpoints();

      this._generateRules();

      this._reflow();
    }
    /**
     * Initializes events for Interchange.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this2 = this;

      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function () {
        return _this2._reflow();
      });
    }
    /**
     * Calls necessary functions to update Interchange upon DOM change
     * @function
     * @private
     */

  }, {
    key: "_reflow",
    value: function _reflow() {
      var match; // Iterate through each rule, but only save the last match

      for (var i in this.rules) {
        if (this.rules.hasOwnProperty(i)) {
          var rule = this.rules[i];

          if (window.matchMedia(rule.query).matches) {
            match = rule;
          }
        }
      }

      if (match) {
        this.replace(match.path);
      }
    }
    /**
     * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.
     * @function
     * @private
     */

  }, {
    key: "_addBreakpoints",
    value: function _addBreakpoints() {
      for (var i in MediaQuery.queries) {
        if (MediaQuery.queries.hasOwnProperty(i)) {
          var query = MediaQuery.queries[i];
          Interchange.SPECIAL_QUERIES[query.name] = query.value;
        }
      }
    }
    /**
     * Checks the Interchange element for the provided media query + content pairings
     * @function
     * @private
     * @param {Object} element - jQuery object that is an Interchange instance
     * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys
     */

  }, {
    key: "_generateRules",
    value: function _generateRules(element) {
      var rulesList = [];
      var rules;

      if (this.options.rules) {
        rules = this.options.rules;
      } else {
        rules = this.$element.data('interchange');
      }

      rules = typeof rules === 'string' ? rules.match(/\[.*?, .*?\]/g) : rules;

      for (var i in rules) {
        if (rules.hasOwnProperty(i)) {
          var rule = rules[i].slice(1, -1).split(', ');
          var path = rule.slice(0, -1).join('');
          var query = rule[rule.length - 1];

          if (Interchange.SPECIAL_QUERIES[query]) {
            query = Interchange.SPECIAL_QUERIES[query];
          }

          rulesList.push({
            path: path,
            query: query
          });
        }
      }

      this.rules = rulesList;
    }
    /**
     * Update the `src` property of an image, or change the HTML of a container, to the specified path.
     * @function
     * @param {String} path - Path to the image or HTML partial.
     * @fires Interchange#replaced
     */

  }, {
    key: "replace",
    value: function replace(path) {
      if (this.currentPath === path) return;

      var _this = this,
          trigger = 'replaced.zf.interchange'; // Replacing images


      if (this.$element[0].nodeName === 'IMG') {
        this.$element.attr('src', path).on('load', function () {
          _this.currentPath = path;
        }).trigger(trigger);
      } // Replacing background images
      else if (path.match(/\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)) {
          path = path.replace(/\(/g, '%28').replace(/\)/g, '%29');
          this.$element.css({
            'background-image': 'url(' + path + ')'
          }).trigger(trigger);
        } // Replacing HTML
        else {
            _jquery2.default.get(path, function (response) {
              _this.$element.html(response).trigger(trigger);

              (0, _jquery2.default)(response).foundation();
              _this.currentPath = path;
            });
          }
      /**
       * Fires when content in an Interchange element is done being loaded.
       * @event Interchange#replaced
       */
      // this.$element.trigger('replaced.zf.interchange');
    }
    /**
     * Destroys an instance of interchange.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('resizeme.zf.trigger');
    }
  }]);

  return Interchange;
}(Plugin);
/**
 * Default settings for plugin
 */

Interchange.defaults = {
  /**
   * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.
   * @option
   * @type {?array}
   * @default null
   */
  rules: null
};
Interchange.SPECIAL_QUERIES = {
  'landscape': 'screen and (orientation: landscape)',
  'portrait': 'screen and (orientation: portrait)',
  'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'
};

/**
 * SmoothScroll module.
 * @module foundation.smooth-scroll
 */

var SmoothScroll =
/*#__PURE__*/
function (_Plugin) {
  _inherits(SmoothScroll, _Plugin);

  function SmoothScroll() {
    _classCallCheck(this, SmoothScroll);

    return _possibleConstructorReturn(this, _getPrototypeOf(SmoothScroll).apply(this, arguments));
  }

  _createClass(SmoothScroll, [{
    key: "_setup",

    /**
     * Creates a new instance of SmoothScroll.
     * @class
     * @name SmoothScroll
     * @fires SmoothScroll#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, SmoothScroll.defaults, this.$element.data(), options);
      this.className = 'SmoothScroll'; // ie9 back compat

      this._init();
    }
    /**
     * Initialize the SmoothScroll plugin
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var id = this.$element[0].id || GetYoDigits(6, 'smooth-scroll');
      this.$element.attr({
        id: id
      });

      this._events();
    }
    /**
     * Initializes events for SmoothScroll.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this.$element.on('click.zf.smoothScroll', this._handleLinkClick);
      this.$element.on('click.zf.smoothScroll', 'a[href^="#"]', this._handleLinkClick);
    }
    /**
     * Handle the given event to smoothly scroll to the anchor pointed by the event target.
     * @param {*} e - event
     * @function
     * @private
     */

  }, {
    key: "_handleLinkClick",
    value: function _handleLinkClick(e) {
      var _this = this;

      // Follow the link if it does not point to an anchor.
      if (!(0, _jquery2.default)(e.currentTarget).is('a[href^="#"]')) return;
      var arrival = e.currentTarget.getAttribute('href');
      this._inTransition = true;
      SmoothScroll.scrollToLoc(arrival, this.options, function () {
        _this._inTransition = false;
      });
      e.preventDefault();
    }
  }, {
    key: "_destroy",

    /**
     * Destroys the SmoothScroll instance.
     * @function
     */
    value: function _destroy() {
      this.$element.off('click.zf.smoothScroll', this._handleLinkClick);
      this.$element.off('click.zf.smoothScroll', 'a[href^="#"]', this._handleLinkClick);
    }
  }], [{
    key: "scrollToLoc",

    /**
     * Function to scroll to a given location on the page.
     * @param {String} loc - A properly formatted jQuery id selector. Example: '#foo'
     * @param {Object} options - The options to use.
     * @param {Function} callback - The callback function.
     * @static
     * @function
     */
    value: function scrollToLoc(loc) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SmoothScroll.defaults;
      var callback = arguments.length > 2 ? arguments[2] : undefined;
      var $loc = (0, _jquery2.default)(loc); // Do nothing if target does not exist to prevent errors

      if (!$loc.length) return false;
      var scrollPos = Math.round($loc.offset().top - options.threshold / 2 - options.offset);
      (0, _jquery2.default)('html, body').stop(true).animate({
        scrollTop: scrollPos
      }, options.animationDuration, options.animationEasing, function () {
        if (typeof callback === 'function') {
          callback();
        }
      });
    }
  }]);

  return SmoothScroll;
}(Plugin);
/**
 * Default settings for plugin.
 */

SmoothScroll.defaults = {
  /**
   * Amount of time, in ms, the animated scrolling should take between locations.
   * @option
   * @type {number}
   * @default 500
   */
  animationDuration: 500,

  /**
   * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.
   * @option
   * @type {string}
   * @default 'linear'
   * @see {@link https://api.jquery.com/animate|Jquery animate}
   */
  animationEasing: 'linear',

  /**
   * Number of pixels to use as a marker for location changes.
   * @option
   * @type {number}
   * @default 50
   */
  threshold: 50,

  /**
   * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.
   * @option
   * @type {number}
   * @default 0
   */
  offset: 0
};

/**
 * Magellan module.
 * @module foundation.magellan
 * @requires foundation.smoothScroll
 */

var Magellan =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Magellan, _Plugin);

  function Magellan() {
    _classCallCheck(this, Magellan);

    return _possibleConstructorReturn(this, _getPrototypeOf(Magellan).apply(this, arguments));
  }

  _createClass(Magellan, [{
    key: "_setup",

    /**
     * Creates a new instance of Magellan.
     * @class
     * @name Magellan
     * @fires Magellan#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Magellan.defaults, this.$element.data(), options);
      this.className = 'Magellan'; // ie9 back compat

      this._init();

      this.calcPoints();
    }
    /**
     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var id = this.$element[0].id || GetYoDigits(6, 'magellan');

      this.$targets = (0, _jquery2.default)('[data-magellan-target]');
      this.$links = this.$element.find('a');
      this.$element.attr({
        'data-resize': id,
        'data-scroll': id,
        'id': id
      });
      this.$active = (0, _jquery2.default)();
      this.scrollPos = parseInt(window.pageYOffset, 10);

      this._events();
    }
    /**
     * Calculates an array of pixel values that are the demarcation lines between locations on the page.
     * Can be invoked if new elements are added or the size of a location changes.
     * @function
     */

  }, {
    key: "calcPoints",
    value: function calcPoints() {
      var _this = this,
          body = document.body,
          html = document.documentElement;

      this.points = [];
      this.winHeight = Math.round(Math.max(window.innerHeight, html.clientHeight));
      this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));
      this.$targets.each(function () {
        var $tar = (0, _jquery2.default)(this),
            pt = Math.round($tar.offset().top - _this.options.threshold);
        $tar.targetPoint = pt;

        _this.points.push(pt);
      });
    }
    /**
     * Initializes events for Magellan.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this,
          $body = (0, _jquery2.default)('html, body'),
          opts = {
        duration: _this.options.animationDuration,
        easing: _this.options.animationEasing
      };

      (0, _jquery2.default)(window).one('load', function () {
        if (_this.options.deepLinking) {
          if (location.hash) {
            _this.scrollToLoc(location.hash);
          }
        }

        _this.calcPoints();

        _this._updateActive();
      });
      _this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
        _this.$element.on({
          'resizeme.zf.trigger': _this.reflow.bind(_this),
          'scrollme.zf.trigger': _this._updateActive.bind(_this)
        }).on('click.zf.magellan', 'a[href^="#"]', function (e) {
          e.preventDefault();
          var arrival = this.getAttribute('href');

          _this.scrollToLoc(arrival);
        });
      });

      this._deepLinkScroll = function (e) {
        if (_this.options.deepLinking) {
          _this.scrollToLoc(window.location.hash);
        }
      };

      (0, _jquery2.default)(window).on('hashchange', this._deepLinkScroll);
    }
    /**
     * Function to scroll to a given location on the page.
     * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'
     * @function
     */

  }, {
    key: "scrollToLoc",
    value: function scrollToLoc(loc) {
      this._inTransition = true;

      var _this = this;

      var options = {
        animationEasing: this.options.animationEasing,
        animationDuration: this.options.animationDuration,
        threshold: this.options.threshold,
        offset: this.options.offset
      };
      SmoothScroll.scrollToLoc(loc, options, function () {
        _this._inTransition = false;
      });
    }
    /**
     * Calls necessary functions to update Magellan upon DOM change
     * @function
     */

  }, {
    key: "reflow",
    value: function reflow() {
      this.calcPoints();

      this._updateActive();
    }
    /**
     * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.
     * @private
     * @function
     * @fires Magellan#update
     */

  }, {
    key: "_updateActive",
    value: function _updateActive()
    /*evt, elem, scrollPos*/
    {
      var _this2 = this;

      if (this._inTransition) return;
      var newScrollPos = parseInt(window.pageYOffset, 10);
      var isScrollingUp = this.scrollPos > newScrollPos;
      this.scrollPos = newScrollPos;
      var activeIdx; // Before the first point: no link

      if (newScrollPos < this.points[0]) ;
      /* do nothing */
      // At the bottom of the page: last link
      else if (newScrollPos + this.winHeight === this.docHeight) {
          activeIdx = this.points.length - 1;
        } // Otherwhise, use the last visible link
        else {
            var visibleLinks = this.points.filter(function (p, i) {
              return p - _this2.options.offset - (isScrollingUp ? _this2.options.threshold : 0) <= newScrollPos;
            });
            activeIdx = visibleLinks.length ? visibleLinks.length - 1 : 0;
          } // Get the new active link


      var $oldActive = this.$active;
      var activeHash = '';

      if (typeof activeIdx !== 'undefined') {
        this.$active = this.$links.filter('[href="#' + this.$targets.eq(activeIdx).data('magellan-target') + '"]');
        if (this.$active.length) activeHash = this.$active[0].getAttribute('href');
      } else {
        this.$active = (0, _jquery2.default)();
      }

      var isNewActive = !(!this.$active.length && !$oldActive.length) && !this.$active.is($oldActive);
      var isNewHash = activeHash !== window.location.hash; // Update the active link element

      if (isNewActive) {
        $oldActive.removeClass(this.options.activeClass);
        this.$active.addClass(this.options.activeClass);
      } // Update the hash (it may have changed with the same active link)


      if (this.options.deepLinking && isNewHash) {
        if (window.history.pushState) {
          // Set or remove the hash (see: https://stackoverflow.com/a/5298684/4317384
          var url = activeHash ? activeHash : window.location.pathname + window.location.search;
          window.history.pushState(null, null, url);
        } else {
          window.location.hash = activeHash;
        }
      }

      if (isNewActive) {
        /**
         * Fires when magellan is finished updating to the new active element.
         * @event Magellan#update
         */
        this.$element.trigger('update.zf.magellan', [this.$active]);
      }
    }
    /**
     * Destroys an instance of Magellan and resets the url of the window.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.trigger .zf.magellan').find(".".concat(this.options.activeClass)).removeClass(this.options.activeClass);

      if (this.options.deepLinking) {
        var hash = this.$active[0].getAttribute('href');
        window.location.hash.replace(hash, '');
      }

      (0, _jquery2.default)(window).off('hashchange', this._deepLinkScroll);
      if (this.onLoadListener) (0, _jquery2.default)(window).off(this.onLoadListener);
    }
  }]);

  return Magellan;
}(Plugin);
/**
 * Default settings for plugin
 */

Magellan.defaults = {
  /**
   * Amount of time, in ms, the animated scrolling should take between locations.
   * @option
   * @type {number}
   * @default 500
   */
  animationDuration: 500,

  /**
   * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.
   * @option
   * @type {string}
   * @default 'linear'
   * @see {@link https://api.jquery.com/animate|Jquery animate}
   */
  animationEasing: 'linear',

  /**
   * Number of pixels to use as a marker for location changes.
   * @option
   * @type {number}
   * @default 50
   */
  threshold: 50,

  /**
   * Class applied to the active locations link on the magellan container.
   * @option
   * @type {string}
   * @default 'is-active'
   */
  activeClass: 'is-active',

  /**
   * Allows the script to manipulate the url of the current page, and if supported, alter the history.
   * @option
   * @type {boolean}
   * @default false
   */
  deepLinking: false,

  /**
   * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.
   * @option
   * @type {number}
   * @default 0
   */
  offset: 0
};

/**
 * OffCanvas module.
 * @module foundation.offcanvas
 * @requires foundation.util.keyboard
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.triggers
 */

var OffCanvas =
/*#__PURE__*/
function (_Plugin) {
  _inherits(OffCanvas, _Plugin);

  function OffCanvas() {
    _classCallCheck(this, OffCanvas);

    return _possibleConstructorReturn(this, _getPrototypeOf(OffCanvas).apply(this, arguments));
  }

  _createClass(OffCanvas, [{
    key: "_setup",

    /**
     * Creates a new instance of an off-canvas wrapper.
     * @class
     * @name OffCanvas
     * @fires OffCanvas#init
     * @param {Object} element - jQuery object to initialize.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      var _this2 = this;

      this.className = 'OffCanvas'; // ie9 back compat

      this.$element = element;
      this.options = _jquery2.default.extend({}, OffCanvas.defaults, this.$element.data(), options);
      this.contentClasses = {
        base: [],
        reveal: []
      };
      this.$lastTrigger = (0, _jquery2.default)();
      this.$triggers = (0, _jquery2.default)();
      this.position = 'left';
      this.$content = (0, _jquery2.default)();
      this.nested = !!this.options.nested; // Defines the CSS transition/position classes of the off-canvas content container.

      (0, _jquery2.default)(['push', 'overlap']).each(function (index, val) {
        _this2.contentClasses.base.push('has-transition-' + val);
      });
      (0, _jquery2.default)(['left', 'right', 'top', 'bottom']).each(function (index, val) {
        _this2.contentClasses.base.push('has-position-' + val);

        _this2.contentClasses.reveal.push('has-reveal-' + val);
      }); // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      MediaQuery._init();

      this._init();

      this._events();

      Keyboard.register('OffCanvas', {
        'ESCAPE': 'close'
      });
    }
    /**
     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var id = this.$element.attr('id');
      this.$element.attr('aria-hidden', 'true'); // Find off-canvas content, either by ID (if specified), by siblings or by closest selector (fallback)

      if (this.options.contentId) {
        this.$content = (0, _jquery2.default)('#' + this.options.contentId);
      } else if (this.$element.siblings('[data-off-canvas-content]').length) {
        this.$content = this.$element.siblings('[data-off-canvas-content]').first();
      } else {
        this.$content = this.$element.closest('[data-off-canvas-content]').first();
      }

      if (!this.options.contentId) {
        // Assume that the off-canvas element is nested if it isn't a sibling of the content
        this.nested = this.$element.siblings('[data-off-canvas-content]').length === 0;
      } else if (this.options.contentId && this.options.nested === null) {
        // Warning if using content ID without setting the nested option
        // Once the element is nested it is required to work properly in this case
        console.warn('Remember to use the nested option if using the content ID option!');
      }

      if (this.nested === true) {
        // Force transition overlap if nested
        this.options.transition = 'overlap'; // Remove appropriate classes if already assigned in markup

        this.$element.removeClass('is-transition-push');
      }

      this.$element.addClass("is-transition-".concat(this.options.transition, " is-closed")); // Find triggers that affect this element and add aria-expanded to them

      this.$triggers = (0, _jquery2.default)(document).find('[data-open="' + id + '"], [data-close="' + id + '"], [data-toggle="' + id + '"]').attr('aria-expanded', 'false').attr('aria-controls', id); // Get position by checking for related CSS class

      this.position = this.$element.is('.position-left, .position-top, .position-right, .position-bottom') ? this.$element.attr('class').match(/position\-(left|top|right|bottom)/)[1] : this.position; // Add an overlay over the content if necessary

      if (this.options.contentOverlay === true) {
        var overlay = document.createElement('div');
        var overlayPosition = (0, _jquery2.default)(this.$element).css("position") === 'fixed' ? 'is-overlay-fixed' : 'is-overlay-absolute';
        overlay.setAttribute('class', 'js-off-canvas-overlay ' + overlayPosition);
        this.$overlay = (0, _jquery2.default)(overlay);

        if (overlayPosition === 'is-overlay-fixed') {
          (0, _jquery2.default)(this.$overlay).insertAfter(this.$element);
        } else {
          this.$content.append(this.$overlay);
        }
      } // Get the revealOn option from the class.


      var revealOnRegExp = new RegExp(RegExpEscape(this.options.revealClass) + '([^\\s]+)', 'g');
      var revealOnClass = revealOnRegExp.exec(this.$element[0].className);

      if (revealOnClass) {
        this.options.isRevealed = true;
        this.options.revealOn = this.options.revealOn || revealOnClass[1];
      } // Ensure the `reveal-on-*` class is set.


      if (this.options.isRevealed === true && this.options.revealOn) {
        this.$element.first().addClass("".concat(this.options.revealClass).concat(this.options.revealOn));

        this._setMQChecker();
      }

      if (this.options.transitionTime) {
        this.$element.css('transition-duration', this.options.transitionTime);
      } // Initally remove all transition/position CSS classes from off-canvas content container.


      this._removeContentClasses();
    }
    /**
     * Adds event handlers to the off-canvas wrapper and the exit overlay.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this.$element.off('.zf.trigger .zf.offcanvas').on({
        'open.zf.trigger': this.open.bind(this),
        'close.zf.trigger': this.close.bind(this),
        'toggle.zf.trigger': this.toggle.bind(this),
        'keydown.zf.offcanvas': this._handleKeyboard.bind(this)
      });

      if (this.options.closeOnClick === true) {
        var $target = this.options.contentOverlay ? this.$overlay : this.$content;
        $target.on({
          'click.zf.offcanvas': this.close.bind(this)
        });
      }
    }
    /**
     * Applies event listener for elements that will reveal at certain breakpoints.
     * @private
     */

  }, {
    key: "_setMQChecker",
    value: function _setMQChecker() {
      var _this = this;

      this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
        if (MediaQuery.atLeast(_this.options.revealOn)) {
          _this.reveal(true);
        }
      });
      (0, _jquery2.default)(window).on('changed.zf.mediaquery', function () {
        if (MediaQuery.atLeast(_this.options.revealOn)) {
          _this.reveal(true);
        } else {
          _this.reveal(false);
        }
      });
    }
    /**
     * Removes the CSS transition/position classes of the off-canvas content container.
     * Removing the classes is important when another off-canvas gets opened that uses the same content container.
     * @param {Boolean} hasReveal - true if related off-canvas element is revealed.
     * @private
     */

  }, {
    key: "_removeContentClasses",
    value: function _removeContentClasses(hasReveal) {
      if (typeof hasReveal !== 'boolean') {
        this.$content.removeClass(this.contentClasses.base.join(' '));
      } else if (hasReveal === false) {
        this.$content.removeClass("has-reveal-".concat(this.position));
      }
    }
    /**
     * Adds the CSS transition/position classes of the off-canvas content container, based on the opening off-canvas element.
     * Beforehand any transition/position class gets removed.
     * @param {Boolean} hasReveal - true if related off-canvas element is revealed.
     * @private
     */

  }, {
    key: "_addContentClasses",
    value: function _addContentClasses(hasReveal) {
      this._removeContentClasses(hasReveal);

      if (typeof hasReveal !== 'boolean') {
        this.$content.addClass("has-transition-".concat(this.options.transition, " has-position-").concat(this.position));
      } else if (hasReveal === true) {
        this.$content.addClass("has-reveal-".concat(this.position));
      }
    }
    /**
     * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.
     * @param {Boolean} isRevealed - true if element should be revealed.
     * @function
     */

  }, {
    key: "reveal",
    value: function reveal(isRevealed) {
      if (isRevealed) {
        this.close();
        this.isRevealed = true;
        this.$element.attr('aria-hidden', 'false');
        this.$element.off('open.zf.trigger toggle.zf.trigger');
        this.$element.removeClass('is-closed');
      } else {
        this.isRevealed = false;
        this.$element.attr('aria-hidden', 'true');
        this.$element.off('open.zf.trigger toggle.zf.trigger').on({
          'open.zf.trigger': this.open.bind(this),
          'toggle.zf.trigger': this.toggle.bind(this)
        });
        this.$element.addClass('is-closed');
      }

      this._addContentClasses(isRevealed);
    }
    /**
     * Stops scrolling of the body when offcanvas is open on mobile Safari and other troublesome browsers.
     * @private
     */

  }, {
    key: "_stopScrolling",
    value: function _stopScrolling(event) {
      return false;
    } // Taken and adapted from http://stackoverflow.com/questions/16889447/prevent-full-page-scrolling-ios
    // Only really works for y, not sure how to extend to x or if we need to.

  }, {
    key: "_recordScrollable",
    value: function _recordScrollable(event) {
      var elem = this; // called from event handler context with this as elem
      // If the element is scrollable (content overflows), then...

      if (elem.scrollHeight !== elem.clientHeight) {
        // If we're at the top, scroll down one pixel to allow scrolling up
        if (elem.scrollTop === 0) {
          elem.scrollTop = 1;
        } // If we're at the bottom, scroll up one pixel to allow scrolling down


        if (elem.scrollTop === elem.scrollHeight - elem.clientHeight) {
          elem.scrollTop = elem.scrollHeight - elem.clientHeight - 1;
        }
      }

      elem.allowUp = elem.scrollTop > 0;
      elem.allowDown = elem.scrollTop < elem.scrollHeight - elem.clientHeight;
      elem.lastY = event.originalEvent.pageY;
    }
  }, {
    key: "_stopScrollPropagation",
    value: function _stopScrollPropagation(event) {
      var elem = this; // called from event handler context with this as elem

      var up = event.pageY < elem.lastY;
      var down = !up;
      elem.lastY = event.pageY;

      if (up && elem.allowUp || down && elem.allowDown) {
        event.stopPropagation();
      } else {
        event.preventDefault();
      }
    }
    /**
     * Opens the off-canvas menu.
     * @function
     * @param {Object} event - Event object passed from listener.
     * @param {jQuery} trigger - element that triggered the off-canvas to open.
     * @fires Offcanvas#opened
     * @todo also trigger 'open' event?
     */

  }, {
    key: "open",
    value: function open(event, trigger) {
      if (this.$element.hasClass('is-open') || this.isRevealed) {
        return;
      }

      var _this = this;

      if (trigger) {
        this.$lastTrigger = trigger;
      }

      if (this.options.forceTo === 'top') {
        window.scrollTo(0, 0);
      } else if (this.options.forceTo === 'bottom') {
        window.scrollTo(0, document.body.scrollHeight);
      }

      if (this.options.transitionTime && this.options.transition !== 'overlap') {
        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', this.options.transitionTime);
      } else {
        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', '');
      }

      this.$element.addClass('is-open').removeClass('is-closed');
      this.$triggers.attr('aria-expanded', 'true');
      this.$element.attr('aria-hidden', 'false');
      this.$content.addClass('is-open-' + this.position); // If `contentScroll` is set to false, add class and disable scrolling on touch devices.

      if (this.options.contentScroll === false) {
        (0, _jquery2.default)('body').addClass('is-off-canvas-open').on('touchmove', this._stopScrolling);
        this.$element.on('touchstart', this._recordScrollable);
        this.$element.on('touchmove', this._stopScrollPropagation);
      }

      if (this.options.contentOverlay === true) {
        this.$overlay.addClass('is-visible');
      }

      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {
        this.$overlay.addClass('is-closable');
      }

      if (this.options.autoFocus === true) {
        this.$element.one(transitionend(this.$element), function () {
          if (!_this.$element.hasClass('is-open')) {
            return; // exit if prematurely closed
          }

          var canvasFocus = _this.$element.find('[data-autofocus]');

          if (canvasFocus.length) {
            canvasFocus.eq(0).focus();
          } else {
            _this.$element.find('a, button').eq(0).focus();
          }
        });
      }

      if (this.options.trapFocus === true) {
        this.$content.attr('tabindex', '-1');
        Keyboard.trapFocus(this.$element);
      }

      this._addContentClasses();
      /**
       * Fires when the off-canvas menu opens.
       * @event Offcanvas#opened
       */

      this.$element.trigger('opened.zf.offcanvas');
    }
    /**
     * Closes the off-canvas menu.
     * @function
     * @param {Function} cb - optional cb to fire after closure.
     * @fires Offcanvas#closed
     */

  }, {
    key: "close",
    value: function close(cb) {
      if (!this.$element.hasClass('is-open') || this.isRevealed) {
        return;
      }

      var _this = this;

      this.$element.removeClass('is-open');
      this.$element.attr('aria-hidden', 'true')
      /**
       * Fires when the off-canvas menu opens.
       * @event Offcanvas#closed
       */
      .trigger('closed.zf.offcanvas');
      this.$content.removeClass('is-open-left is-open-top is-open-right is-open-bottom'); // If `contentScroll` is set to false, remove class and re-enable scrolling on touch devices.

      if (this.options.contentScroll === false) {
        (0, _jquery2.default)('body').removeClass('is-off-canvas-open').off('touchmove', this._stopScrolling);
        this.$element.off('touchstart', this._recordScrollable);
        this.$element.off('touchmove', this._stopScrollPropagation);
      }

      if (this.options.contentOverlay === true) {
        this.$overlay.removeClass('is-visible');
      }

      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {
        this.$overlay.removeClass('is-closable');
      }

      this.$triggers.attr('aria-expanded', 'false');

      if (this.options.trapFocus === true) {
        this.$content.removeAttr('tabindex');
        Keyboard.releaseFocus(this.$element);
      } // Listen to transitionEnd and add class when done.


      this.$element.one(transitionend(this.$element), function (e) {
        _this.$element.addClass('is-closed');

        _this._removeContentClasses();
      });
    }
    /**
     * Toggles the off-canvas menu open or closed.
     * @function
     * @param {Object} event - Event object passed from listener.
     * @param {jQuery} trigger - element that triggered the off-canvas to open.
     */

  }, {
    key: "toggle",
    value: function toggle(event, trigger) {
      if (this.$element.hasClass('is-open')) {
        this.close(event, trigger);
      } else {
        this.open(event, trigger);
      }
    }
    /**
     * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.
     * @function
     * @private
     */

  }, {
    key: "_handleKeyboard",
    value: function _handleKeyboard(e) {
      var _this3 = this;

      Keyboard.handleKey(e, 'OffCanvas', {
        close: function close() {
          _this3.close();

          _this3.$lastTrigger.focus();

          return true;
        },
        handled: function handled() {
          e.stopPropagation();
          e.preventDefault();
        }
      });
    }
    /**
     * Destroys the offcanvas plugin.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.close();
      this.$element.off('.zf.trigger .zf.offcanvas');
      this.$overlay.off('.zf.offcanvas');
      if (this.onLoadListener) (0, _jquery2.default)(window).off(this.onLoadListener);
    }
  }]);

  return OffCanvas;
}(Plugin);

OffCanvas.defaults = {
  /**
   * Allow the user to click outside of the menu to close it.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnClick: true,

  /**
   * Adds an overlay on top of `[data-off-canvas-content]`.
   * @option
   * @type {boolean}
   * @default true
   */
  contentOverlay: true,

  /**
   * Target an off-canvas content container by ID that may be placed anywhere. If null the closest content container will be taken.
   * @option
   * @type {?string}
   * @default null
   */
  contentId: null,

  /**
   * Define the off-canvas element is nested in an off-canvas content. This is required when using the contentId option for a nested element.
   * @option
   * @type {boolean}
   * @default null
   */
  nested: null,

  /**
   * Enable/disable scrolling of the main content when an off canvas panel is open.
   * @option
   * @type {boolean}
   * @default true
   */
  contentScroll: true,

  /**
   * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.
   * @option
   * @type {number}
   * @default null
   */
  transitionTime: null,

  /**
   * Type of transition for the offcanvas menu. Options are 'push', 'detached' or 'slide'.
   * @option
   * @type {string}
   * @default push
   */
  transition: 'push',

  /**
   * Force the page to scroll to top or bottom on open.
   * @option
   * @type {?string}
   * @default null
   */
  forceTo: null,

  /**
   * Allow the offcanvas to remain open for certain breakpoints.
   * @option
   * @type {boolean}
   * @default false
   */
  isRevealed: false,

  /**
   * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.
   * @option
   * @type {?string}
   * @default null
   */
  revealOn: null,

  /**
   * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.
   * @option
   * @type {boolean}
   * @default true
   */
  autoFocus: true,

  /**
   * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.
   * @option
   * @type {string}
   * @default reveal-for-
   * @todo improve the regex testing for this.
   */
  revealClass: 'reveal-for-',

  /**
   * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.
   * @option
   * @type {boolean}
   * @default false
   */
  trapFocus: false
};

/**
 * Orbit module.
 * @module foundation.orbit
 * @requires foundation.util.keyboard
 * @requires foundation.util.motion
 * @requires foundation.util.timer
 * @requires foundation.util.imageLoader
 * @requires foundation.util.touch
 */

var Orbit =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Orbit, _Plugin);

  function Orbit() {
    _classCallCheck(this, Orbit);

    return _possibleConstructorReturn(this, _getPrototypeOf(Orbit).apply(this, arguments));
  }

  _createClass(Orbit, [{
    key: "_setup",

    /**
    * Creates a new instance of an orbit carousel.
    * @class
    * @name Orbit
    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.
    * @param {Object} options - Overrides to the default plugin settings.
    */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Orbit.defaults, this.$element.data(), options);
      this.className = 'Orbit'; // ie9 back compat

      Touch.init(_jquery2.default); // Touch init is idempotent, we just need to make sure it's initialied.

      this._init();

      Keyboard.register('Orbit', {
        'ltr': {
          'ARROW_RIGHT': 'next',
          'ARROW_LEFT': 'previous'
        },
        'rtl': {
          'ARROW_LEFT': 'next',
          'ARROW_RIGHT': 'previous'
        }
      });
    }
    /**
    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.
    * @function
    * @private
    */

  }, {
    key: "_init",
    value: function _init() {
      // @TODO: consider discussion on PR #9278 about DOM pollution by changeSlide
      this._reset();

      this.$wrapper = this.$element.find(".".concat(this.options.containerClass));
      this.$slides = this.$element.find(".".concat(this.options.slideClass));
      var $images = this.$element.find('img'),
          initActive = this.$slides.filter('.is-active'),
          id = this.$element[0].id || GetYoDigits(6, 'orbit');
      this.$element.attr({
        'data-resize': id,
        'id': id
      });

      if (!initActive.length) {
        this.$slides.eq(0).addClass('is-active');
      }

      if (!this.options.useMUI) {
        this.$slides.addClass('no-motionui');
      }

      if ($images.length) {
        onImagesLoaded($images, this._prepareForOrbit.bind(this));
      } else {
        this._prepareForOrbit(); //hehe
      }

      if (this.options.bullets) {
        this._loadBullets();
      }

      this._events();

      if (this.options.autoPlay && this.$slides.length > 1) {
        this.geoSync();
      }

      if (this.options.accessible) {
        // allow wrapper to be focusable to enable arrow navigation
        this.$wrapper.attr('tabindex', 0);
      }
    }
    /**
    * Creates a jQuery collection of bullets, if they are being used.
    * @function
    * @private
    */

  }, {
    key: "_loadBullets",
    value: function _loadBullets() {
      this.$bullets = this.$element.find(".".concat(this.options.boxOfBullets)).find('button');
    }
    /**
    * Sets a `timer` object on the orbit, and starts the counter for the next slide.
    * @function
    */

  }, {
    key: "geoSync",
    value: function geoSync() {
      var _this = this;

      this.timer = new Timer(this.$element, {
        duration: this.options.timerDelay,
        infinite: false
      }, function () {
        _this.changeSlide(true);
      });
      this.timer.start();
    }
    /**
    * Sets wrapper and slide heights for the orbit.
    * @function
    * @private
    */

  }, {
    key: "_prepareForOrbit",
    value: function _prepareForOrbit() {

      this._setWrapperHeight();
    }
    /**
    * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.
    * @function
    * @private
    * @param {Function} cb - a callback function to fire when complete.
    */

  }, {
    key: "_setWrapperHeight",
    value: function _setWrapperHeight(cb) {
      //rewrite this to `for` loop
      var max = 0,
          temp,
          counter = 0,
          _this = this;

      this.$slides.each(function () {
        temp = this.getBoundingClientRect().height;
        (0, _jquery2.default)(this).attr('data-slide', counter); // hide all slides but the active one

        if (!/mui/g.test((0, _jquery2.default)(this)[0].className) && _this.$slides.filter('.is-active')[0] !== _this.$slides.eq(counter)[0]) {
          (0, _jquery2.default)(this).css({
            'display': 'none'
          });
        }

        max = temp > max ? temp : max;
        counter++;
      });

      if (counter === this.$slides.length) {
        this.$wrapper.css({
          'height': max
        }); //only change the wrapper height property once.

        if (cb) {
          cb(max);
        } //fire callback with max height dimension.
      }
    }
    /**
    * Sets the max-height of each slide.
    * @function
    * @private
    */

  }, {
    key: "_setSlideHeight",
    value: function _setSlideHeight(height) {
      this.$slides.each(function () {
        (0, _jquery2.default)(this).css('max-height', height);
      });
    }
    /**
    * Adds event listeners to basically everything within the element.
    * @function
    * @private
    */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this; //***************************************
      //**Now using custom event - thanks to:**
      //**      Yohai Ararat of Toronto      **
      //***************************************
      //


      this.$element.off('.resizeme.zf.trigger').on({
        'resizeme.zf.trigger': this._prepareForOrbit.bind(this)
      });

      if (this.$slides.length > 1) {
        if (this.options.swipe) {
          this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit', function (e) {
            e.preventDefault();

            _this.changeSlide(true);
          }).on('swiperight.zf.orbit', function (e) {
            e.preventDefault();

            _this.changeSlide(false);
          });
        } //***************************************


        if (this.options.autoPlay) {
          this.$slides.on('click.zf.orbit', function () {
            _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);

            _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();
          });

          if (this.options.pauseOnHover) {
            this.$element.on('mouseenter.zf.orbit', function () {
              _this.timer.pause();
            }).on('mouseleave.zf.orbit', function () {
              if (!_this.$element.data('clickedOn')) {
                _this.timer.start();
              }
            });
          }
        }

        if (this.options.navButtons) {
          var $controls = this.$element.find(".".concat(this.options.nextClass, ", .").concat(this.options.prevClass));
          $controls.attr('tabindex', 0) //also need to handle enter/return and spacebar key presses
          .on('click.zf.orbit touchend.zf.orbit', function (e) {
            e.preventDefault();

            _this.changeSlide((0, _jquery2.default)(this).hasClass(_this.options.nextClass));
          });
        }

        if (this.options.bullets) {
          this.$bullets.on('click.zf.orbit touchend.zf.orbit', function () {
            if (/is-active/g.test(this.className)) {
              return false;
            } //if this is active, kick out of function.


            var idx = (0, _jquery2.default)(this).data('slide'),
                ltr = idx > _this.$slides.filter('.is-active').data('slide'),
                $slide = _this.$slides.eq(idx);

            _this.changeSlide(ltr, $slide, idx);
          });
        }

        if (this.options.accessible) {
          this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function (e) {
            // handle keyboard event with keyboard util
            Keyboard.handleKey(e, 'Orbit', {
              next: function next() {
                _this.changeSlide(true);
              },
              previous: function previous() {
                _this.changeSlide(false);
              },
              handled: function handled() {
                // if bullet is focused, make sure focus moves
                if ((0, _jquery2.default)(e.target).is(_this.$bullets)) {
                  _this.$bullets.filter('.is-active').focus();
                }
              }
            });
          });
        }
      }
    }
    /**
     * Resets Orbit so it can be reinitialized
     */

  }, {
    key: "_reset",
    value: function _reset() {
      // Don't do anything if there are no slides (first run)
      if (typeof this.$slides == 'undefined') {
        return;
      }

      if (this.$slides.length > 1) {
        // Remove old events
        this.$element.off('.zf.orbit').find('*').off('.zf.orbit'); // Restart timer if autoPlay is enabled

        if (this.options.autoPlay) {
          this.timer.restart();
        } // Reset all sliddes


        this.$slides.each(function (el) {
          (0, _jquery2.default)(el).removeClass('is-active is-active is-in').removeAttr('aria-live').hide();
        }); // Show the first slide

        this.$slides.first().addClass('is-active').show(); // Triggers when the slide has finished animating

        this.$element.trigger('slidechange.zf.orbit', [this.$slides.first()]); // Select first bullet if bullets are present

        if (this.options.bullets) {
          this._updateBullets(0);
        }
      }
    }
    /**
    * Changes the current slide to a new one.
    * @function
    * @param {Boolean} isLTR - if true the slide moves from right to left, if false the slide moves from left to right.
    * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.
    * @param {Number} idx - the index of the new slide in its collection, if one chosen.
    * @fires Orbit#slidechange
    */

  }, {
    key: "changeSlide",
    value: function changeSlide(isLTR, chosenSlide, idx) {
      if (!this.$slides) {
        return;
      } // Don't freak out if we're in the middle of cleanup


      var $curSlide = this.$slides.filter('.is-active').eq(0);

      if (/mui/g.test($curSlide[0].className)) {
        return false;
      } //if the slide is currently animating, kick out of the function


      var $firstSlide = this.$slides.first(),
          $lastSlide = this.$slides.last(),
          dirIn = isLTR ? 'Right' : 'Left',
          dirOut = isLTR ? 'Left' : 'Right',
          _this = this,
          $newSlide;

      if (!chosenSlide) {
        //most of the time, this will be auto played or clicked from the navButtons.
        $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!
        this.options.infiniteWrap ? $curSlide.next(".".concat(this.options.slideClass)).length ? $curSlide.next(".".concat(this.options.slideClass)) : $firstSlide : $curSlide.next(".".concat(this.options.slideClass)) : //pick next slide if moving left to right
        this.options.infiniteWrap ? $curSlide.prev(".".concat(this.options.slideClass)).length ? $curSlide.prev(".".concat(this.options.slideClass)) : $lastSlide : $curSlide.prev(".".concat(this.options.slideClass)); //pick prev slide if moving right to left
      } else {
        $newSlide = chosenSlide;
      }

      if ($newSlide.length) {
        /**
        * Triggers before the next slide starts animating in and only if a next slide has been found.
        * @event Orbit#beforeslidechange
        */
        this.$element.trigger('beforeslidechange.zf.orbit', [$curSlide, $newSlide]);

        if (this.options.bullets) {
          idx = idx || this.$slides.index($newSlide); //grab index to update bullets

          this._updateBullets(idx);
        }

        if (this.options.useMUI && !this.$element.is(':hidden')) {
          Motion.animateIn($newSlide.addClass('is-active'), this.options["animInFrom".concat(dirIn)], function () {
            $newSlide.css({
              'display': 'block'
            }).attr('aria-live', 'polite');
          });
          Motion.animateOut($curSlide.removeClass('is-active'), this.options["animOutTo".concat(dirOut)], function () {
            $curSlide.removeAttr('aria-live');

            if (_this.options.autoPlay && !_this.timer.isPaused) {
              _this.timer.restart();
            } //do stuff?
          });
        } else {
          $curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();
          $newSlide.addClass('is-active is-in').attr('aria-live', 'polite').show();

          if (this.options.autoPlay && !this.timer.isPaused) {
            this.timer.restart();
          }
        }
        /**
        * Triggers when the slide has finished animating in.
        * @event Orbit#slidechange
        */

        this.$element.trigger('slidechange.zf.orbit', [$newSlide]);
      }
    }
    /**
    * Updates the active state of the bullets, if displayed.
    * @function
    * @private
    * @param {Number} idx - the index of the current slide.
    */

  }, {
    key: "_updateBullets",
    value: function _updateBullets(idx) {
      var $oldBullet = this.$element.find(".".concat(this.options.boxOfBullets)).find('.is-active').removeClass('is-active').blur(),
          span = $oldBullet.find('span:last').detach(),
          $newBullet = this.$bullets.eq(idx).addClass('is-active').append(span);
    }
    /**
    * Destroys the carousel and hides the element.
    * @function
    */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();
    }
  }]);

  return Orbit;
}(Plugin);

Orbit.defaults = {
  /**
  * Tells the JS to look for and loadBullets.
  * @option
   * @type {boolean}
  * @default true
  */
  bullets: true,

  /**
  * Tells the JS to apply event listeners to nav buttons
  * @option
   * @type {boolean}
  * @default true
  */
  navButtons: true,

  /**
  * motion-ui animation class to apply
  * @option
   * @type {string}
  * @default 'slide-in-right'
  */
  animInFromRight: 'slide-in-right',

  /**
  * motion-ui animation class to apply
  * @option
   * @type {string}
  * @default 'slide-out-right'
  */
  animOutToRight: 'slide-out-right',

  /**
  * motion-ui animation class to apply
  * @option
   * @type {string}
  * @default 'slide-in-left'
  *
  */
  animInFromLeft: 'slide-in-left',

  /**
  * motion-ui animation class to apply
  * @option
   * @type {string}
  * @default 'slide-out-left'
  */
  animOutToLeft: 'slide-out-left',

  /**
  * Allows Orbit to automatically animate on page load.
  * @option
   * @type {boolean}
  * @default true
  */
  autoPlay: true,

  /**
  * Amount of time, in ms, between slide transitions
  * @option
   * @type {number}
  * @default 5000
  */
  timerDelay: 5000,

  /**
  * Allows Orbit to infinitely loop through the slides
  * @option
   * @type {boolean}
  * @default true
  */
  infiniteWrap: true,

  /**
  * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library
  * @option
   * @type {boolean}
  * @default true
  */
  swipe: true,

  /**
  * Allows the timing function to pause animation on hover.
  * @option
   * @type {boolean}
  * @default true
  */
  pauseOnHover: true,

  /**
  * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys
  * @option
   * @type {boolean}
  * @default true
  */
  accessible: true,

  /**
  * Class applied to the container of Orbit
  * @option
   * @type {string}
  * @default 'orbit-container'
  */
  containerClass: 'orbit-container',

  /**
  * Class applied to individual slides.
  * @option
   * @type {string}
  * @default 'orbit-slide'
  */
  slideClass: 'orbit-slide',

  /**
  * Class applied to the bullet container. You're welcome.
  * @option
   * @type {string}
  * @default 'orbit-bullets'
  */
  boxOfBullets: 'orbit-bullets',

  /**
  * Class applied to the `next` navigation button.
  * @option
   * @type {string}
  * @default 'orbit-next'
  */
  nextClass: 'orbit-next',

  /**
  * Class applied to the `previous` navigation button.
  * @option
   * @type {string}
  * @default 'orbit-previous'
  */
  prevClass: 'orbit-previous',

  /**
  * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatibility.
  * @option
   * @type {boolean}
  * @default true
  */
  useMUI: true
};

var MenuPlugins = {
  dropdown: {
    cssClass: 'dropdown',
    plugin: DropdownMenu
  },
  drilldown: {
    cssClass: 'drilldown',
    plugin: Drilldown
  },
  accordion: {
    cssClass: 'accordion-menu',
    plugin: AccordionMenu
  }
}; // import "foundation.util.triggers.js";

/**
 * ResponsiveMenu module.
 * @module foundation.responsiveMenu
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 */

var ResponsiveMenu =
/*#__PURE__*/
function (_Plugin) {
  _inherits(ResponsiveMenu, _Plugin);

  function ResponsiveMenu() {
    _classCallCheck(this, ResponsiveMenu);

    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveMenu).apply(this, arguments));
  }

  _createClass(ResponsiveMenu, [{
    key: "_setup",

    /**
     * Creates a new instance of a responsive menu.
     * @class
     * @name ResponsiveMenu
     * @fires ResponsiveMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = (0, _jquery2.default)(element);
      this.rules = this.$element.data('responsive-menu');
      this.currentMq = null;
      this.currentPlugin = null;
      this.className = 'ResponsiveMenu'; // ie9 back compat

      this._init();

      this._events();
    }
    /**
     * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init(); // The first time an Interchange plugin is initialized, this.rules is converted from a string of "classes" to an object of rules


      if (typeof this.rules === 'string') {
        var rulesTree = {}; // Parse rules from "classes" pulled from data attribute

        var rules = this.rules.split(' '); // Iterate through every rule found

        for (var i = 0; i < rules.length; i++) {
          var rule = rules[i].split('-');
          var ruleSize = rule.length > 1 ? rule[0] : 'small';
          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];

          if (MenuPlugins[rulePlugin] !== null) {
            rulesTree[ruleSize] = MenuPlugins[rulePlugin];
          }
        }

        this.rules = rulesTree;
      }

      if (!_jquery2.default.isEmptyObject(this.rules)) {
        this._checkMediaQueries();
      } // Add data-mutate since children may need it.


      this.$element.attr('data-mutate', this.$element.attr('data-mutate') || GetYoDigits(6, 'responsive-menu'));
    }
    /**
     * Initializes events for the Menu.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      (0, _jquery2.default)(window).on('changed.zf.mediaquery', function () {
        _this._checkMediaQueries();
      }); // $(window).on('resize.zf.ResponsiveMenu', function() {
      //   _this._checkMediaQueries();
      // });
    }
    /**
     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.
     * @function
     * @private
     */

  }, {
    key: "_checkMediaQueries",
    value: function _checkMediaQueries() {
      var matchedMq,
          _this = this; // Iterate through each rule and find the last matching rule


      _jquery2.default.each(this.rules, function (key) {
        if (MediaQuery.atLeast(key)) {
          matchedMq = key;
        }
      }); // No match? No dice

      if (!matchedMq) return; // Plugin already initialized? We good

      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return; // Remove existing plugin-specific CSS classes

      _jquery2.default.each(MenuPlugins, function (key, value) {
        _this.$element.removeClass(value.cssClass);
      }); // Add the CSS class for the new plugin

      this.$element.addClass(this.rules[matchedMq].cssClass); // Create an instance of the new plugin

      if (this.currentPlugin) this.currentPlugin.destroy();
      this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});
    }
    /**
     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.currentPlugin.destroy();
      (0, _jquery2.default)(window).off('.zf.ResponsiveMenu');
    }
  }]);

  return ResponsiveMenu;
}(Plugin);

ResponsiveMenu.defaults = {};

/**
 * ResponsiveToggle module.
 * @module foundation.responsiveToggle
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.motion
 */

var ResponsiveToggle =
/*#__PURE__*/
function (_Plugin) {
  _inherits(ResponsiveToggle, _Plugin);

  function ResponsiveToggle() {
    _classCallCheck(this, ResponsiveToggle);

    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveToggle).apply(this, arguments));
  }

  _createClass(ResponsiveToggle, [{
    key: "_setup",

    /**
     * Creates a new instance of Tab Bar.
     * @class
     * @name ResponsiveToggle
     * @fires ResponsiveToggle#init
     * @param {jQuery} element - jQuery object to attach tab bar functionality to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = (0, _jquery2.default)(element);
      this.options = _jquery2.default.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);
      this.className = 'ResponsiveToggle'; // ie9 back compat

      this._init();

      this._events();
    }
    /**
     * Initializes the tab bar by finding the target element, toggling element, and running update().
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init();

      var targetID = this.$element.data('responsive-toggle');

      if (!targetID) {
        console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');
      }

      this.$targetMenu = (0, _jquery2.default)("#".concat(targetID));
      this.$toggler = this.$element.find('[data-toggle]').filter(function () {
        var target = (0, _jquery2.default)(this).data('toggle');
        return target === targetID || target === "";
      });
      this.options = _jquery2.default.extend({}, this.options, this.$targetMenu.data()); // If they were set, parse the animation classes

      if (this.options.animate) {
        var input = this.options.animate.split(' ');
        this.animationIn = input[0];
        this.animationOut = input[1] || null;
      }

      this._update();
    }
    /**
     * Adds necessary event handlers for the tab bar to work.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {

      this._updateMqHandler = this._update.bind(this);
      (0, _jquery2.default)(window).on('changed.zf.mediaquery', this._updateMqHandler);
      this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));
    }
    /**
     * Checks the current media query to determine if the tab bar should be visible or hidden.
     * @function
     * @private
     */

  }, {
    key: "_update",
    value: function _update() {
      // Mobile
      if (!MediaQuery.atLeast(this.options.hideFor)) {
        this.$element.show();
        this.$targetMenu.hide();
      } // Desktop
      else {
          this.$element.hide();
          this.$targetMenu.show();
        }
    }
    /**
     * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.
     * @function
     * @fires ResponsiveToggle#toggled
     */

  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      var _this2 = this;

      if (!MediaQuery.atLeast(this.options.hideFor)) {
        /**
         * Fires when the element attached to the tab bar toggles.
         * @event ResponsiveToggle#toggled
         */
        if (this.options.animate) {
          if (this.$targetMenu.is(':hidden')) {
            Motion.animateIn(this.$targetMenu, this.animationIn, function () {
              _this2.$element.trigger('toggled.zf.responsiveToggle');

              _this2.$targetMenu.find('[data-mutate]').triggerHandler('mutateme.zf.trigger');
            });
          } else {
            Motion.animateOut(this.$targetMenu, this.animationOut, function () {
              _this2.$element.trigger('toggled.zf.responsiveToggle');
            });
          }
        } else {
          this.$targetMenu.toggle(0);
          this.$targetMenu.find('[data-mutate]').trigger('mutateme.zf.trigger');
          this.$element.trigger('toggled.zf.responsiveToggle');
        }
      }
    }
  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.responsiveToggle');
      this.$toggler.off('.zf.responsiveToggle');
      (0, _jquery2.default)(window).off('changed.zf.mediaquery', this._updateMqHandler);
    }
  }]);

  return ResponsiveToggle;
}(Plugin);

ResponsiveToggle.defaults = {
  /**
   * The breakpoint after which the menu is always shown, and the tab bar is hidden.
   * @option
   * @type {string}
   * @default 'medium'
   */
  hideFor: 'medium',

  /**
   * To decide if the toggle should be animated or not.
   * @option
   * @type {boolean}
   * @default false
   */
  animate: false
};

/**
 * Reveal module.
 * @module foundation.reveal
 * @requires foundation.util.keyboard
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.motion if using animations
 */

var Reveal =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Reveal, _Plugin);

  function Reveal() {
    _classCallCheck(this, Reveal);

    return _possibleConstructorReturn(this, _getPrototypeOf(Reveal).apply(this, arguments));
  }

  _createClass(Reveal, [{
    key: "_setup",

    /**
     * Creates a new instance of Reveal.
     * @class
     * @name Reveal
     * @param {jQuery} element - jQuery object to use for the modal.
     * @param {Object} options - optional parameters.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Reveal.defaults, this.$element.data(), options);
      this.className = 'Reveal'; // ie9 back compat

      this._init(); // Triggers init is idempotent, just need to make sure it is initialized


      Triggers.init(_jquery2.default);
      Keyboard.register('Reveal', {
        'ESCAPE': 'close'
      });
    }
    /**
     * Initializes the modal by adding the overlay and close buttons, (if selected).
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      MediaQuery._init();

      this.id = this.$element.attr('id');
      this.isActive = false;
      this.cached = {
        mq: MediaQuery.current
      };
      this.$anchor = (0, _jquery2.default)("[data-open=\"".concat(this.id, "\"]")).length ? (0, _jquery2.default)("[data-open=\"".concat(this.id, "\"]")) : (0, _jquery2.default)("[data-toggle=\"".concat(this.id, "\"]"));
      this.$anchor.attr({
        'aria-controls': this.id,
        'aria-haspopup': true,
        'tabindex': 0
      });

      if (this.options.fullScreen || this.$element.hasClass('full')) {
        this.options.fullScreen = true;
        this.options.overlay = false;
      }

      if (this.options.overlay && !this.$overlay) {
        this.$overlay = this._makeOverlay(this.id);
      }

      this.$element.attr({
        'role': 'dialog',
        'aria-hidden': true,
        'data-yeti-box': this.id,
        'data-resize': this.id
      });

      if (this.$overlay) {
        this.$element.detach().appendTo(this.$overlay);
      } else {
        this.$element.detach().appendTo((0, _jquery2.default)(this.options.appendTo));
        this.$element.addClass('without-overlay');
      }

      this._events();

      if (this.options.deepLink && window.location.hash === "#".concat(this.id)) {
        this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
          return _this2.open();
        });
      }
    }
    /**
     * Creates an overlay div to display behind the modal.
     * @private
     */

  }, {
    key: "_makeOverlay",
    value: function _makeOverlay() {
      var additionalOverlayClasses = '';

      if (this.options.additionalOverlayClasses) {
        additionalOverlayClasses = ' ' + this.options.additionalOverlayClasses;
      }

      return (0, _jquery2.default)('<div></div>').addClass('reveal-overlay' + additionalOverlayClasses).appendTo(this.options.appendTo);
    }
    /**
     * Updates position of modal
     * TODO:  Figure out if we actually need to cache these values or if it doesn't matter
     * @private
     */

  }, {
    key: "_updatePosition",
    value: function _updatePosition() {
      var width = this.$element.outerWidth();
      var outerWidth = (0, _jquery2.default)(window).width();
      var height = this.$element.outerHeight();
      var outerHeight = (0, _jquery2.default)(window).height();
      var left,
          top = null;

      if (this.options.hOffset === 'auto') {
        left = parseInt((outerWidth - width) / 2, 10);
      } else {
        left = parseInt(this.options.hOffset, 10);
      }

      if (this.options.vOffset === 'auto') {
        if (height > outerHeight) {
          top = parseInt(Math.min(100, outerHeight / 10), 10);
        } else {
          top = parseInt((outerHeight - height) / 4, 10);
        }
      } else if (this.options.vOffset !== null) {
        top = parseInt(this.options.vOffset, 10);
      }

      if (top !== null) {
        this.$element.css({
          top: top + 'px'
        });
      } // only worry about left if we don't have an overlay or we have a horizontal offset,
      // otherwise we're perfectly in the middle


      if (!this.$overlay || this.options.hOffset !== 'auto') {
        this.$element.css({
          left: left + 'px'
        });
        this.$element.css({
          margin: '0px'
        });
      }
    }
    /**
     * Adds event handlers for the modal.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this3 = this;

      var _this = this;

      this.$element.on({
        'open.zf.trigger': this.open.bind(this),
        'close.zf.trigger': function closeZfTrigger(event, $element) {
          if (event.target === _this.$element[0] || (0, _jquery2.default)(event.target).parents('[data-closable]')[0] === $element) {
            // only close reveal when it's explicitly called
            return _this3.close.apply(_this3);
          }
        },
        'toggle.zf.trigger': this.toggle.bind(this),
        'resizeme.zf.trigger': function resizemeZfTrigger() {
          _this._updatePosition();
        }
      });

      if (this.options.closeOnClick && this.options.overlay) {
        this.$overlay.off('.zf.reveal').on('click.zf.reveal', function (e) {
          if (e.target === _this.$element[0] || _jquery2.default.contains(_this.$element[0], e.target) || !_jquery2.default.contains(document, e.target)) {
            return;
          }

          _this.close();
        });
      }

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).on("hashchange.zf.reveal:".concat(this.id), this._handleState.bind(this));
      }
    }
    /**
     * Handles modal methods on back/forward button clicks or any other event that triggers hashchange.
     * @private
     */

  }, {
    key: "_handleState",
    value: function _handleState(e) {
      if (window.location.hash === '#' + this.id && !this.isActive) {
        this.open();
      } else {
        this.close();
      }
    }
    /**
    * Disables the scroll when Reveal is shown to prevent the background from shifting
    * @param {number} scrollTop - Scroll to visually apply, window current scroll by default
    */

  }, {
    key: "_disableScroll",
    value: function _disableScroll(scrollTop) {
      scrollTop = scrollTop || (0, _jquery2.default)(window).scrollTop();

      if ((0, _jquery2.default)(document).height() > (0, _jquery2.default)(window).height()) {
        (0, _jquery2.default)("html").css("top", -scrollTop);
      }
    }
    /**
    * Reenables the scroll when Reveal closes
    * @param {number} scrollTop - Scroll to restore, html "top" property by default (as set by `_disableScroll`)
    */

  }, {
    key: "_enableScroll",
    value: function _enableScroll(scrollTop) {
      scrollTop = scrollTop || parseInt((0, _jquery2.default)("html").css("top"));

      if ((0, _jquery2.default)(document).height() > (0, _jquery2.default)(window).height()) {
        (0, _jquery2.default)("html").css("top", "");
        (0, _jquery2.default)(window).scrollTop(-scrollTop);
      }
    }
    /**
     * Opens the modal controlled by `this.$anchor`, and closes all others by default.
     * @function
     * @fires Reveal#closeme
     * @fires Reveal#open
     */

  }, {
    key: "open",
    value: function open() {
      var _this4 = this;

      // either update or replace browser history
      var hash = "#".concat(this.id);

      if (this.options.deepLink && window.location.hash !== hash) {
        if (window.history.pushState) {
          if (this.options.updateHistory) {
            window.history.pushState({}, '', hash);
          } else {
            window.history.replaceState({}, '', hash);
          }
        } else {
          window.location.hash = hash;
        }
      } // Remember anchor that opened it to set focus back later, have general anchors as fallback


      this.$activeAnchor = (0, _jquery2.default)(document.activeElement).is(this.$anchor) ? (0, _jquery2.default)(document.activeElement) : this.$anchor;
      this.isActive = true; // Make elements invisible, but remove display: none so we can get size and positioning

      this.$element.css({
        'visibility': 'hidden'
      }).show().scrollTop(0);

      if (this.options.overlay) {
        this.$overlay.css({
          'visibility': 'hidden'
        }).show();
      }

      this._updatePosition();

      this.$element.hide().css({
        'visibility': ''
      });

      if (this.$overlay) {
        this.$overlay.css({
          'visibility': ''
        }).hide();

        if (this.$element.hasClass('fast')) {
          this.$overlay.addClass('fast');
        } else if (this.$element.hasClass('slow')) {
          this.$overlay.addClass('slow');
        }
      }

      if (!this.options.multipleOpened) {
        /**
         * Fires immediately before the modal opens.
         * Closes any other modals that are currently open
         * @event Reveal#closeme
         */
        this.$element.trigger('closeme.zf.reveal', this.id);
      }

      this._disableScroll();

      var _this = this; // Motion UI method of reveal


      if (this.options.animationIn) {
        var afterAnimation = function afterAnimation() {
          _this.$element.attr({
            'aria-hidden': false,
            'tabindex': -1
          }).focus();

          _this._addGlobalClasses();

          Keyboard.trapFocus(_this.$element);
        };

        if (this.options.overlay) {
          Motion.animateIn(this.$overlay, 'fade-in');
        }

        Motion.animateIn(this.$element, this.options.animationIn, function () {
          if (_this4.$element) {
            // protect against object having been removed
            _this4.focusableElements = Keyboard.findFocusable(_this4.$element);
            afterAnimation();
          }
        });
      } // jQuery method of reveal
      else {
          if (this.options.overlay) {
            this.$overlay.show(0);
          }

          this.$element.show(this.options.showDelay);
        } // handle accessibility


      this.$element.attr({
        'aria-hidden': false,
        'tabindex': -1
      }).focus();
      Keyboard.trapFocus(this.$element);

      this._addGlobalClasses();

      this._addGlobalListeners();
      /**
       * Fires when the modal has successfully opened.
       * @event Reveal#open
       */

      this.$element.trigger('open.zf.reveal');
    }
    /**
     * Adds classes and listeners on document required by open modals.
     *
     * The following classes are added and updated:
     * - `.is-reveal-open` - Prevents the scroll on document
     * - `.zf-has-scroll`  - Displays a disabled scrollbar on document if required like if the
     *                       scroll was not disabled. This prevent a "shift" of the page content due
     *                       the scrollbar disappearing when the modal opens.
     *
     * @private
     */

  }, {
    key: "_addGlobalClasses",
    value: function _addGlobalClasses() {
      var updateScrollbarClass = function updateScrollbarClass() {
        (0, _jquery2.default)('html').toggleClass('zf-has-scroll', !!((0, _jquery2.default)(document).height() > (0, _jquery2.default)(window).height()));
      };

      this.$element.on('resizeme.zf.trigger.revealScrollbarListener', function () {
        return updateScrollbarClass();
      });
      updateScrollbarClass();
      (0, _jquery2.default)('html').addClass('is-reveal-open');
    }
    /**
     * Removes classes and listeners on document that were required by open modals.
     * @private
     */

  }, {
    key: "_removeGlobalClasses",
    value: function _removeGlobalClasses() {
      this.$element.off('resizeme.zf.trigger.revealScrollbarListener');
      (0, _jquery2.default)('html').removeClass('is-reveal-open');
      (0, _jquery2.default)('html').removeClass('zf-has-scroll');
    }
    /**
     * Adds extra event handlers for the body and window if necessary.
     * @private
     */

  }, {
    key: "_addGlobalListeners",
    value: function _addGlobalListeners() {
      var _this = this;

      if (!this.$element) {
        return;
      } // If we're in the middle of cleanup, don't freak out


      this.focusableElements = Keyboard.findFocusable(this.$element);

      if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {
        (0, _jquery2.default)('body').on('click.zf.reveal', function (e) {
          if (e.target === _this.$element[0] || _jquery2.default.contains(_this.$element[0], e.target) || !_jquery2.default.contains(document, e.target)) {
            return;
          }

          _this.close();
        });
      }

      if (this.options.closeOnEsc) {
        (0, _jquery2.default)(window).on('keydown.zf.reveal', function (e) {
          Keyboard.handleKey(e, 'Reveal', {
            close: function close() {
              if (_this.options.closeOnEsc) {
                _this.close();
              }
            }
          });
        });
      }
    }
    /**
     * Closes the modal.
     * @function
     * @fires Reveal#closed
     */

  }, {
    key: "close",
    value: function close() {
      if (!this.isActive || !this.$element.is(':visible')) {
        return false;
      }

      var _this = this; // Motion UI method of hiding


      if (this.options.animationOut) {
        if (this.options.overlay) {
          Motion.animateOut(this.$overlay, 'fade-out');
        }

        Motion.animateOut(this.$element, this.options.animationOut, finishUp);
      } // jQuery method of hiding
      else {
          this.$element.hide(this.options.hideDelay);

          if (this.options.overlay) {
            this.$overlay.hide(0, finishUp);
          } else {
            finishUp();
          }
        } // Conditionals to remove extra event listeners added on open


      if (this.options.closeOnEsc) {
        (0, _jquery2.default)(window).off('keydown.zf.reveal');
      }

      if (!this.options.overlay && this.options.closeOnClick) {
        (0, _jquery2.default)('body').off('click.zf.reveal');
      }

      this.$element.off('keydown.zf.reveal');

      function finishUp() {
        // Get the current top before the modal is closed and restore the scroll after.
        // TODO: use component properties instead of HTML properties
        // See https://github.com/zurb/foundation-sites/pull/10786
        var scrollTop = parseInt((0, _jquery2.default)("html").css("top"));

        if ((0, _jquery2.default)('.reveal:visible').length === 0) {
          _this._removeGlobalClasses(); // also remove .is-reveal-open from the html element when there is no opened reveal
        }

        Keyboard.releaseFocus(_this.$element);

        _this.$element.attr('aria-hidden', true);

        _this._enableScroll(scrollTop);
        /**
        * Fires when the modal is done closing.
        * @event Reveal#closed
        */

        _this.$element.trigger('closed.zf.reveal');
      }
      /**
      * Resets the modal content
      * This prevents a running video to keep going in the background
      */

      if (this.options.resetOnClose) {
        this.$element.html(this.$element.html());
      }

      this.isActive = false; // If deepLink and we did not switched to an other modal...

      if (_this.options.deepLink && window.location.hash === "#".concat(this.id)) {
        // Remove the history hash
        if (window.history.replaceState) {
          var urlWithoutHash = window.location.pathname + window.location.search;

          if (this.options.updateHistory) {
            window.history.pushState({}, '', urlWithoutHash); // remove the hash
          } else {
            window.history.replaceState('', document.title, urlWithoutHash);
          }
        } else {
          window.location.hash = '';
        }
      }

      this.$activeAnchor.focus();
    }
    /**
     * Toggles the open/closed state of a modal.
     * @function
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this.isActive) {
        this.close();
      } else {
        this.open();
      }
    }
  }, {
    key: "_destroy",

    /**
     * Destroys an instance of a modal.
     * @function
     */
    value: function _destroy() {
      if (this.options.overlay) {
        this.$element.appendTo((0, _jquery2.default)(this.options.appendTo)); // move $element outside of $overlay to prevent error unregisterPlugin()

        this.$overlay.hide().off().remove();
      }

      this.$element.hide().off();
      this.$anchor.off('.zf');
      (0, _jquery2.default)(window).off(".zf.reveal:".concat(this.id));
      if (this.onLoadListener) (0, _jquery2.default)(window).off(this.onLoadListener);

      if ((0, _jquery2.default)('.reveal:visible').length === 0) {
        this._removeGlobalClasses(); // also remove .is-reveal-open from the html element when there is no opened reveal
      }
    }
  }]);

  return Reveal;
}(Plugin);

Reveal.defaults = {
  /**
   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
   * @option
   * @type {string}
   * @default ''
   */
  animationIn: '',

  /**
   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
   * @option
   * @type {string}
   * @default ''
   */
  animationOut: '',

  /**
   * Time, in ms, to delay the opening of a modal after a click if no animation used.
   * @option
   * @type {number}
   * @default 0
   */
  showDelay: 0,

  /**
   * Time, in ms, to delay the closing of a modal after a click if no animation used.
   * @option
   * @type {number}
   * @default 0
   */
  hideDelay: 0,

  /**
   * Allows a click on the body/overlay to close the modal.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnClick: true,

  /**
   * Allows the modal to close if the user presses the `ESCAPE` key.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnEsc: true,

  /**
   * If true, allows multiple modals to be displayed at once.
   * @option
   * @type {boolean}
   * @default false
   */
  multipleOpened: false,

  /**
   * Distance, in pixels, the modal should push down from the top of the screen.
   * @option
   * @type {number|string}
   * @default auto
   */
  vOffset: 'auto',

  /**
   * Distance, in pixels, the modal should push in from the side of the screen.
   * @option
   * @type {number|string}
   * @default auto
   */
  hOffset: 'auto',

  /**
   * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.
   * @option
   * @type {boolean}
   * @default false
   */
  fullScreen: false,

  /**
   * Allows the modal to generate an overlay div, which will cover the view when modal opens.
   * @option
   * @type {boolean}
   * @default true
   */
  overlay: true,

  /**
   * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.
   * @option
   * @type {boolean}
   * @default false
   */
  resetOnClose: false,

  /**
   * Link the location hash to the modal.
   * Set the location hash when the modal is opened/closed, and open/close the modal when the location changes.
   * @option
   * @type {boolean}
   * @default false
   */
  deepLink: false,

  /**
   * If `deepLink` is enabled, update the browser history with the open modal
   * @option
   * @default false
   */
  updateHistory: false,

  /**
  * Allows the modal to append to custom div.
  * @option
  * @type {string}
  * @default "body"
  */
  appendTo: "body",

  /**
   * Allows adding additional class names to the reveal overlay.
   * @option
   * @type {string}
   * @default ''
   */
  additionalOverlayClasses: ''
};

/**
 * Slider module.
 * @module foundation.slider
 * @requires foundation.util.motion
 * @requires foundation.util.triggers
 * @requires foundation.util.keyboard
 * @requires foundation.util.touch
 */

var Slider =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Slider, _Plugin);

  function Slider() {
    _classCallCheck(this, Slider);

    return _possibleConstructorReturn(this, _getPrototypeOf(Slider).apply(this, arguments));
  }

  _createClass(Slider, [{
    key: "_setup",

    /**
     * Creates a new instance of a slider control.
     * @class
     * @name Slider
     * @param {jQuery} element - jQuery object to make into a slider control.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Slider.defaults, this.$element.data(), options);
      this.className = 'Slider'; // ie9 back compat
      // Touch and Triggers inits are idempotent, we just need to make sure it's initialied.

      Touch.init(_jquery2.default);
      Triggers.init(_jquery2.default);

      this._init();

      Keyboard.register('Slider', {
        'ltr': {
          'ARROW_RIGHT': 'increase',
          'ARROW_UP': 'increase',
          'ARROW_DOWN': 'decrease',
          'ARROW_LEFT': 'decrease',
          'SHIFT_ARROW_RIGHT': 'increase_fast',
          'SHIFT_ARROW_UP': 'increase_fast',
          'SHIFT_ARROW_DOWN': 'decrease_fast',
          'SHIFT_ARROW_LEFT': 'decrease_fast',
          'HOME': 'min',
          'END': 'max'
        },
        'rtl': {
          'ARROW_LEFT': 'increase',
          'ARROW_RIGHT': 'decrease',
          'SHIFT_ARROW_LEFT': 'increase_fast',
          'SHIFT_ARROW_RIGHT': 'decrease_fast'
        }
      });
    }
    /**
     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      this.inputs = this.$element.find('input');
      this.handles = this.$element.find('[data-slider-handle]');
      this.$handle = this.handles.eq(0);
      this.$input = this.inputs.length ? this.inputs.eq(0) : (0, _jquery2.default)("#".concat(this.$handle.attr('aria-controls')));
      this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);

      if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {
        this.options.disabled = true;
        this.$element.addClass(this.options.disabledClass);
      }

      if (!this.inputs.length) {
        this.inputs = (0, _jquery2.default)().add(this.$input);
        this.options.binding = true;
      }

      this._setInitAttr(0);

      if (this.handles[1]) {
        this.options.doubleSided = true;
        this.$handle2 = this.handles.eq(1);
        this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : (0, _jquery2.default)("#".concat(this.$handle2.attr('aria-controls')));

        if (!this.inputs[1]) {
          this.inputs = this.inputs.add(this.$input2);
        }

        this._setInitAttr(1);
      } // Set handle positions


      this.setHandles();

      this._events();
    }
  }, {
    key: "setHandles",
    value: function setHandles() {
      var _this2 = this;

      if (this.handles[1]) {
        this._setHandlePos(this.$handle, this.inputs.eq(0).val(), true, function () {
          _this2._setHandlePos(_this2.$handle2, _this2.inputs.eq(1).val(), true);
        });
      } else {
        this._setHandlePos(this.$handle, this.inputs.eq(0).val(), true);
      }
    }
  }, {
    key: "_reflow",
    value: function _reflow() {
      this.setHandles();
    }
    /**
    * @function
    * @private
    * @param {Number} value - floating point (the value) to be transformed using to a relative position on the slider (the inverse of _value)
    */

  }, {
    key: "_pctOfBar",
    value: function _pctOfBar(value) {
      var pctOfBar = percent(value - this.options.start, this.options.end - this.options.start);

      switch (this.options.positionValueFunction) {
        case "pow":
          pctOfBar = this._logTransform(pctOfBar);
          break;

        case "log":
          pctOfBar = this._powTransform(pctOfBar);
          break;
      }

      return pctOfBar.toFixed(2);
    }
    /**
    * @function
    * @private
    * @param {Number} pctOfBar - floating point, the relative position of the slider (typically between 0-1) to be transformed to a value
    */

  }, {
    key: "_value",
    value: function _value(pctOfBar) {
      switch (this.options.positionValueFunction) {
        case "pow":
          pctOfBar = this._powTransform(pctOfBar);
          break;

        case "log":
          pctOfBar = this._logTransform(pctOfBar);
          break;
      }

      var value = (this.options.end - this.options.start) * pctOfBar + parseFloat(this.options.start);
      return value;
    }
    /**
    * @function
    * @private
    * @param {Number} value - floating point (typically between 0-1) to be transformed using the log function
    */

  }, {
    key: "_logTransform",
    value: function _logTransform(value) {
      return baseLog(this.options.nonLinearBase, value * (this.options.nonLinearBase - 1) + 1);
    }
    /**
    * @function
    * @private
    * @param {Number} value - floating point (typically between 0-1) to be transformed using the power function
    */

  }, {
    key: "_powTransform",
    value: function _powTransform(value) {
      return (Math.pow(this.options.nonLinearBase, value) - 1) / (this.options.nonLinearBase - 1);
    }
    /**
     * Sets the position of the selected handle and fill bar.
     * @function
     * @private
     * @param {jQuery} $hndl - the selected handle to move.
     * @param {Number} location - floating point between the start and end values of the slider bar.
     * @param {Function} cb - callback function to fire on completion.
     * @fires Slider#moved
     * @fires Slider#changed
     */

  }, {
    key: "_setHandlePos",
    value: function _setHandlePos($hndl, location, noInvert, cb) {
      // don't move if the slider has been disabled since its initialization
      if (this.$element.hasClass(this.options.disabledClass)) {
        return;
      } //might need to alter that slightly for bars that will have odd number selections.


      location = parseFloat(location); //on input change events, convert string to number...grumble.
      // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max

      if (location < this.options.start) {
        location = this.options.start;
      } else if (location > this.options.end) {
        location = this.options.end;
      }

      var isDbl = this.options.doubleSided; //this is for single-handled vertical sliders, it adjusts the value to account for the slider being "upside-down"
      //for click and drag events, it's weird due to the scale(-1, 1) css property

      if (this.options.vertical && !noInvert) {
        location = this.options.end - location;
      }

      if (isDbl) {
        //this block is to prevent 2 handles from crossing eachother. Could/should be improved.
        if (this.handles.index($hndl) === 0) {
          var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));
          location = location >= h2Val ? h2Val - this.options.step : location;
        } else {
          var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));
          location = location <= h1Val ? h1Val + this.options.step : location;
        }
      }

      var _this = this,
          vert = this.options.vertical,
          hOrW = vert ? 'height' : 'width',
          lOrT = vert ? 'top' : 'left',
          handleDim = $hndl[0].getBoundingClientRect()[hOrW],
          elemDim = this.$element[0].getBoundingClientRect()[hOrW],

      //percentage of bar min/max value based on click or drag point
      pctOfBar = this._pctOfBar(location),

      //number of actual pixels to shift the handle, based on the percentage obtained above
      pxToMove = (elemDim - handleDim) * pctOfBar,

      //percentage of bar to shift the handle
      movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal); //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value


      location = parseFloat(location.toFixed(this.options.decimal)); // declare empty object for css adjustments, only used with 2 handled-sliders

      var css = {};

      this._setValues($hndl, location); // TODO update to calculate based on values set to respective inputs??


      if (isDbl) {
        var isLeftHndl = this.handles.index($hndl) === 0,

        //empty variable, will be used for min-height/width for fill bar
        dim,

        //percentage w/h of the handle compared to the slider bar
        handlePct = ~~(percent(handleDim, elemDim) * 100); //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar

        if (isLeftHndl) {
          //left or top percentage value to apply to the fill bar.
          css[lOrT] = "".concat(movement, "%"); //calculate the new min-height/width for the fill bar.

          dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct; //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider
          //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.

          if (cb && typeof cb === 'function') {
            cb();
          } //this is only needed for the initialization of 2 handled sliders
        } else {
          //just caching the value of the left/bottom handle's left/top property
          var handlePos = parseFloat(this.$handle[0].style[lOrT]); //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0
          //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself

          dim = movement - (isNaN(handlePos) ? (this.options.initialStart - this.options.start) / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;
        } // assign the min-height/width to our css object


        css["min-".concat(hOrW)] = "".concat(dim, "%");
      }

      this.$element.one('finished.zf.animate', function () {
        /**
         * Fires when the handle is done moving.
         * @event Slider#moved
         */
        _this.$element.trigger('moved.zf.slider', [$hndl]);
      }); //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.

      var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;
      Move(moveTime, $hndl, function () {
        // adjusting the left/top property of the handle, based on the percentage calculated above
        // if movement isNaN, that is because the slider is hidden and we cannot determine handle width,
        // fall back to next best guess.
        if (isNaN(movement)) {
          $hndl.css(lOrT, "".concat(pctOfBar * 100, "%"));
        } else {
          $hndl.css(lOrT, "".concat(movement, "%"));
        }

        if (!_this.options.doubleSided) {
          //if single-handled, a simple method to expand the fill bar
          _this.$fill.css(hOrW, "".concat(pctOfBar * 100, "%"));
        } else {
          //otherwise, use the css object we created above
          _this.$fill.css(css);
        }
      });
      /**
       * Fires when the value has not been change for a given time.
       * @event Slider#changed
       */

      clearTimeout(_this.timeout);
      _this.timeout = setTimeout(function () {
        _this.$element.trigger('changed.zf.slider', [$hndl]);
      }, _this.options.changedDelay);
    }
    /**
     * Sets the initial attribute for the slider element.
     * @function
     * @private
     * @param {Number} idx - index of the current handle/input to use.
     */

  }, {
    key: "_setInitAttr",
    value: function _setInitAttr(idx) {
      var initVal = idx === 0 ? this.options.initialStart : this.options.initialEnd;
      var id = this.inputs.eq(idx).attr('id') || GetYoDigits(6, 'slider');
      this.inputs.eq(idx).attr({
        'id': id,
        'max': this.options.end,
        'min': this.options.start,
        'step': this.options.step
      });
      this.inputs.eq(idx).val(initVal);
      this.handles.eq(idx).attr({
        'role': 'slider',
        'aria-controls': id,
        'aria-valuemax': this.options.end,
        'aria-valuemin': this.options.start,
        'aria-valuenow': initVal,
        'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',
        'tabindex': 0
      });
    }
    /**
     * Sets the input and `aria-valuenow` values for the slider element.
     * @function
     * @private
     * @param {jQuery} $handle - the currently selected handle.
     * @param {Number} val - floating point of the new value.
     */

  }, {
    key: "_setValues",
    value: function _setValues($handle, val) {
      var idx = this.options.doubleSided ? this.handles.index($handle) : 0;
      this.inputs.eq(idx).val(val);
      $handle.attr('aria-valuenow', val);
    }
    /**
     * Handles events on the slider element.
     * Calculates the new location of the current handle.
     * If there are two handles and the bar was clicked, it determines which handle to move.
     * @function
     * @private
     * @param {Object} e - the `event` object passed from the listener.
     * @param {jQuery} $handle - the current handle to calculate for, if selected.
     * @param {Number} val - floating point number for the new value of the slider.
     * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.
     */

  }, {
    key: "_handleEvent",
    value: function _handleEvent(e, $handle, val) {
      var value, hasVal;

      if (!val) {
        //click or drag events
        e.preventDefault();

        var _this = this,
            vertical = this.options.vertical,
            param = vertical ? 'height' : 'width',
            direction = vertical ? 'top' : 'left',
            eventOffset = vertical ? e.pageY : e.pageX,
            halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,
            barDim = this.$element[0].getBoundingClientRect()[param],
            windowScroll = vertical ? (0, _jquery2.default)(window).scrollTop() : (0, _jquery2.default)(window).scrollLeft();

        var elemOffset = this.$element.offset()[direction]; // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...
        // best way to guess this is simulated is if clientY == pageY

        if (e.clientY === e.pageY) {
          eventOffset = eventOffset + windowScroll;
        }

        var eventFromBar = eventOffset - elemOffset;
        var barXY;

        if (eventFromBar < 0) {
          barXY = 0;
        } else if (eventFromBar > barDim) {
          barXY = barDim;
        } else {
          barXY = eventFromBar;
        }

        var offsetPct = percent(barXY, barDim);
        value = this._value(offsetPct); // turn everything around for RTL, yay math!

        if (rtl() && !this.options.vertical) {
          value = this.options.end - value;
        }

        value = _this._adjustValue(null, value); //boolean flag for the setHandlePos fn, specifically for vertical sliders

        hasVal = false;

        if (!$handle) {
          //figure out which handle it is, pass it to the next function.
          var firstHndlPos = absPosition(this.$handle, direction, barXY, param),
              secndHndlPos = absPosition(this.$handle2, direction, barXY, param);
          $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;
        }
      } else {
        //change event on input
        value = this._adjustValue(null, val);
        hasVal = true;
      }

      this._setHandlePos($handle, value, hasVal);
    }
    /**
     * Adjustes value for handle in regard to step value. returns adjusted value
     * @function
     * @private
     * @param {jQuery} $handle - the selected handle.
     * @param {Number} value - value to adjust. used if $handle is falsy
     */

  }, {
    key: "_adjustValue",
    value: function _adjustValue($handle, value) {
      var val,
          step = this.options.step,
          div = parseFloat(step / 2),
          left,
          prev_val,
          next_val;

      if (!!$handle) {
        val = parseFloat($handle.attr('aria-valuenow'));
      } else {
        val = value;
      }

      if (val >= 0) {
        left = val % step;
      } else {
        left = step + val % step;
      }

      prev_val = val - left;
      next_val = prev_val + step;

      if (left === 0) {
        return val;
      }

      val = val >= prev_val + div ? next_val : prev_val;
      return val;
    }
    /**
     * Adds event listeners to the slider elements.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this._eventsForHandle(this.$handle);

      if (this.handles[1]) {
        this._eventsForHandle(this.$handle2);
      }
    }
    /**
     * Adds event listeners a particular handle
     * @function
     * @private
     * @param {jQuery} $handle - the current handle to apply listeners to.
     */

  }, {
    key: "_eventsForHandle",
    value: function _eventsForHandle($handle) {
      var _this = this,
          curHandle;

      var handleChangeEvent = function handleChangeEvent(e) {
        var idx = _this.inputs.index((0, _jquery2.default)(this));

        _this._handleEvent(e, _this.handles.eq(idx), (0, _jquery2.default)(this).val());
      }; // IE only triggers the change event when the input loses focus which strictly follows the HTML specification
      // listen for the enter key and trigger a change
      // @see https://html.spec.whatwg.org/multipage/input.html#common-input-element-events


      this.inputs.off('keyup.zf.slider').on('keyup.zf.slider', function (e) {
        if (e.keyCode == 13) handleChangeEvent.call(this, e);
      });
      this.inputs.off('change.zf.slider').on('change.zf.slider', handleChangeEvent);

      if (this.options.clickSelect) {
        this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {
          if (_this.$element.data('dragging')) {
            return false;
          }

          if (!(0, _jquery2.default)(e.target).is('[data-slider-handle]')) {
            if (_this.options.doubleSided) {
              _this._handleEvent(e);
            } else {
              _this._handleEvent(e, _this.$handle);
            }
          }
        });
      }

      if (this.options.draggable) {
        this.handles.addTouch();
        var $body = (0, _jquery2.default)('body');
        $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {
          $handle.addClass('is-dragging');

          _this.$fill.addClass('is-dragging'); //


          _this.$element.data('dragging', true);

          curHandle = (0, _jquery2.default)(e.currentTarget);
          $body.on('mousemove.zf.slider', function (e) {
            e.preventDefault();

            _this._handleEvent(e, curHandle);
          }).on('mouseup.zf.slider', function (e) {
            _this._handleEvent(e, curHandle);

            $handle.removeClass('is-dragging');

            _this.$fill.removeClass('is-dragging');

            _this.$element.data('dragging', false);

            $body.off('mousemove.zf.slider mouseup.zf.slider');
          });
        }) // prevent events triggered by touch
        .on('selectstart.zf.slider touchmove.zf.slider', function (e) {
          e.preventDefault();
        });
      }

      $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {
        var _$handle = (0, _jquery2.default)(this),
            idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,
            oldValue = parseFloat(_this.inputs.eq(idx).val()),
            newValue; // handle keyboard event with keyboard util


        Keyboard.handleKey(e, 'Slider', {
          decrease: function decrease() {
            newValue = oldValue - _this.options.step;
          },
          increase: function increase() {
            newValue = oldValue + _this.options.step;
          },
          decrease_fast: function decrease_fast() {
            newValue = oldValue - _this.options.step * 10;
          },
          increase_fast: function increase_fast() {
            newValue = oldValue + _this.options.step * 10;
          },
          min: function min() {
            newValue = _this.options.start;
          },
          max: function max() {
            newValue = _this.options.end;
          },
          handled: function handled() {
            // only set handle pos when event was handled specially
            e.preventDefault();

            _this._setHandlePos(_$handle, newValue, true);
          }
        });
        /*if (newValue) { // if pressed key has special function, update value
          e.preventDefault();
          _this._setHandlePos(_$handle, newValue);
        }*/
      });
    }
    /**
     * Destroys the slider plugin.
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.handles.off('.zf.slider');
      this.inputs.off('.zf.slider');
      this.$element.off('.zf.slider');
      clearTimeout(this.timeout);
    }
  }]);

  return Slider;
}(Plugin);

Slider.defaults = {
  /**
   * Minimum value for the slider scale.
   * @option
   * @type {number}
   * @default 0
   */
  start: 0,

  /**
   * Maximum value for the slider scale.
   * @option
   * @type {number}
   * @default 100
   */
  end: 100,

  /**
   * Minimum value change per change event.
   * @option
   * @type {number}
   * @default 1
   */
  step: 1,

  /**
   * Value at which the handle/input *(left handle/first input)* should be set to on initialization.
   * @option
   * @type {number}
   * @default 0
   */
  initialStart: 0,

  /**
   * Value at which the right handle/second input should be set to on initialization.
   * @option
   * @type {number}
   * @default 100
   */
  initialEnd: 100,

  /**
   * Allows the input to be located outside the container and visible. Set to by the JS
   * @option
   * @type {boolean}
   * @default false
   */
  binding: false,

  /**
   * Allows the user to click/tap on the slider bar to select a value.
   * @option
   * @type {boolean}
   * @default true
   */
  clickSelect: true,

  /**
   * Set to true and use the `vertical` class to change alignment to vertical.
   * @option
   * @type {boolean}
   * @default false
   */
  vertical: false,

  /**
   * Allows the user to drag the slider handle(s) to select a value.
   * @option
   * @type {boolean}
   * @default true
   */
  draggable: true,

  /**
   * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.
   * @option
   * @type {boolean}
   * @default false
   */
  disabled: false,

  /**
   * Allows the use of two handles. Double checked by the JS. Changes some logic handling.
   * @option
   * @type {boolean}
   * @default false
   */
  doubleSided: false,

  /**
   * Potential future feature.
   */
  // steps: 100,

  /**
   * Number of decimal places the plugin should go to for floating point precision.
   * @option
   * @type {number}
   * @default 2
   */
  decimal: 2,

  /**
   * Time delay for dragged elements.
   */
  // dragDelay: 0,

  /**
   * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.
   * @option
   * @type {number}
   * @default 200
   */
  moveTime: 200,
  //update this if changing the transition time in the sass

  /**
   * Class applied to disabled sliders.
   * @option
   * @type {string}
   * @default 'disabled'
   */
  disabledClass: 'disabled',

  /**
   * Will invert the default layout for a vertical<span data-tooltip title="who would do this???"> </span>slider.
   * @option
   * @type {boolean}
   * @default false
   */
  invertVertical: false,

  /**
   * Milliseconds before the `changed.zf-slider` event is triggered after value change.
   * @option
   * @type {number}
   * @default 500
   */
  changedDelay: 500,

  /**
  * Basevalue for non-linear sliders
  * @option
  * @type {number}
  * @default 5
  */
  nonLinearBase: 5,

  /**
  * Basevalue for non-linear sliders, possible values are: `'linear'`, `'pow'` & `'log'`. Pow and Log use the nonLinearBase setting.
  * @option
  * @type {string}
  * @default 'linear'
  */
  positionValueFunction: 'linear'
};

function percent(frac, num) {
  return frac / num;
}

function absPosition($handle, dir, clickPos, param) {
  return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);
}

function baseLog(base, value) {
  return Math.log(value) / Math.log(base);
}

/**
 * Sticky module.
 * @module foundation.sticky
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 */

var Sticky =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Sticky, _Plugin);

  function Sticky() {
    _classCallCheck(this, Sticky);

    return _possibleConstructorReturn(this, _getPrototypeOf(Sticky).apply(this, arguments));
  }

  _createClass(Sticky, [{
    key: "_setup",

    /**
     * Creates a new instance of a sticky thing.
     * @class
     * @name Sticky
     * @param {jQuery} element - jQuery object to make sticky.
     * @param {Object} options - options object passed when creating the element programmatically.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Sticky.defaults, this.$element.data(), options);
      this.className = 'Sticky'; // ie9 back compat
      // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      this._init();
    }
    /**
     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init();

      var $parent = this.$element.parent('[data-sticky-container]'),
          id = this.$element[0].id || GetYoDigits(6, 'sticky'),
          _this = this;

      if ($parent.length) {
        this.$container = $parent;
      } else {
        this.wasWrapped = true;
        this.$element.wrap(this.options.container);
        this.$container = this.$element.parent();
      }

      this.$container.addClass(this.options.containerClass);
      this.$element.addClass(this.options.stickyClass).attr({
        'data-resize': id,
        'data-mutate': id
      });

      if (this.options.anchor !== '') {
        (0, _jquery2.default)('#' + _this.options.anchor).attr({
          'data-mutate': id
        });
      }

      this.scrollCount = this.options.checkEvery;
      this.isStuck = false;
      this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
        //We calculate the container height to have correct values for anchor points offset calculation.
        _this.containerHeight = _this.$element.css("display") == "none" ? 0 : _this.$element[0].getBoundingClientRect().height;

        _this.$container.css('height', _this.containerHeight);

        _this.elemHeight = _this.containerHeight;

        if (_this.options.anchor !== '') {
          _this.$anchor = (0, _jquery2.default)('#' + _this.options.anchor);
        } else {
          _this._parsePoints();
        }

        _this._setSizes(function () {
          var scroll = window.pageYOffset;

          _this._calc(false, scroll); //Unstick the element will ensure that proper classes are set.


          if (!_this.isStuck) {
            _this._removeSticky(scroll >= _this.topPoint ? false : true);
          }
        });

        _this._events(id.split('-').reverse().join('-'));
      });
    }
    /**
     * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.
     * @function
     * @private
     */

  }, {
    key: "_parsePoints",
    value: function _parsePoints() {
      var top = this.options.topAnchor == "" ? 1 : this.options.topAnchor,
          btm = this.options.btmAnchor == "" ? document.documentElement.scrollHeight : this.options.btmAnchor,
          pts = [top, btm],
          breaks = {};

      for (var i = 0, len = pts.length; i < len && pts[i]; i++) {
        var pt;

        if (typeof pts[i] === 'number') {
          pt = pts[i];
        } else {
          var place = pts[i].split(':'),
              anchor = (0, _jquery2.default)("#".concat(place[0]));
          pt = anchor.offset().top;

          if (place[1] && place[1].toLowerCase() === 'bottom') {
            pt += anchor[0].getBoundingClientRect().height;
          }
        }

        breaks[i] = pt;
      }

      this.points = breaks;
      return;
    }
    /**
     * Adds event handlers for the scrolling element.
     * @private
     * @param {String} id - pseudo-random id for unique scroll event listener.
     */

  }, {
    key: "_events",
    value: function _events(id) {
      var _this = this,
          scrollListener = this.scrollListener = "scroll.zf.".concat(id);

      if (this.isOn) {
        return;
      }

      if (this.canStick) {
        this.isOn = true;
        (0, _jquery2.default)(window).off(scrollListener).on(scrollListener, function (e) {
          if (_this.scrollCount === 0) {
            _this.scrollCount = _this.options.checkEvery;

            _this._setSizes(function () {
              _this._calc(false, window.pageYOffset);
            });
          } else {
            _this.scrollCount--;

            _this._calc(false, window.pageYOffset);
          }
        });
      }

      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {
        _this._eventsHandler(id);
      });
      this.$element.on('mutateme.zf.trigger', function (e, el) {
        _this._eventsHandler(id);
      });

      if (this.$anchor) {
        this.$anchor.on('mutateme.zf.trigger', function (e, el) {
          _this._eventsHandler(id);
        });
      }
    }
    /**
     * Handler for events.
     * @private
     * @param {String} id - pseudo-random id for unique scroll event listener.
     */

  }, {
    key: "_eventsHandler",
    value: function _eventsHandler(id) {
      var _this = this,
          scrollListener = this.scrollListener = "scroll.zf.".concat(id);

      _this._setSizes(function () {
        _this._calc(false);

        if (_this.canStick) {
          if (!_this.isOn) {
            _this._events(id);
          }
        } else if (_this.isOn) {
          _this._pauseListeners(scrollListener);
        }
      });
    }
    /**
     * Removes event handlers for scroll and change events on anchor.
     * @fires Sticky#pause
     * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`
     */

  }, {
    key: "_pauseListeners",
    value: function _pauseListeners(scrollListener) {
      this.isOn = false;
      (0, _jquery2.default)(window).off(scrollListener);
      /**
       * Fires when the plugin is paused due to resize event shrinking the view.
       * @event Sticky#pause
       * @private
       */

      this.$element.trigger('pause.zf.sticky');
    }
    /**
     * Called on every `scroll` event and on `_init`
     * fires functions based on booleans and cached values
     * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.
     * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.
     */

  }, {
    key: "_calc",
    value: function _calc(checkSizes, scroll) {
      if (checkSizes) {
        this._setSizes();
      }

      if (!this.canStick) {
        if (this.isStuck) {
          this._removeSticky(true);
        }

        return false;
      }

      if (!scroll) {
        scroll = window.pageYOffset;
      }

      if (scroll >= this.topPoint) {
        if (scroll <= this.bottomPoint) {
          if (!this.isStuck) {
            this._setSticky();
          }
        } else {
          if (this.isStuck) {
            this._removeSticky(false);
          }
        }
      } else {
        if (this.isStuck) {
          this._removeSticky(true);
        }
      }
    }
    /**
     * Causes the $element to become stuck.
     * Adds `position: fixed;`, and helper classes.
     * @fires Sticky#stuckto
     * @function
     * @private
     */

  }, {
    key: "_setSticky",
    value: function _setSticky() {
      var _this = this,
          stickTo = this.options.stickTo,
          mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',
          notStuckTo = stickTo === 'top' ? 'bottom' : 'top',
          css = {};

      css[mrgn] = "".concat(this.options[mrgn], "em");
      css[stickTo] = 0;
      css[notStuckTo] = 'auto';
      this.isStuck = true;
      this.$element.removeClass("is-anchored is-at-".concat(notStuckTo)).addClass("is-stuck is-at-".concat(stickTo)).css(css)
      /**
       * Fires when the $element has become `position: fixed;`
       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`
       * @event Sticky#stuckto
       */
      .trigger("sticky.zf.stuckto:".concat(stickTo));
      this.$element.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd", function () {
        _this._setSizes();
      });
    }
    /**
     * Causes the $element to become unstuck.
     * Removes `position: fixed;`, and helper classes.
     * Adds other helper classes.
     * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.
     * @fires Sticky#unstuckfrom
     * @private
     */

  }, {
    key: "_removeSticky",
    value: function _removeSticky(isTop) {
      var stickTo = this.options.stickTo,
          stickToTop = stickTo === 'top',
          css = {},
          anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,
          mrgn = stickToTop ? 'marginTop' : 'marginBottom',
          topOrBottom = isTop ? 'top' : 'bottom';
      css[mrgn] = 0;
      css['bottom'] = 'auto';

      if (isTop) {
        css['top'] = 0;
      } else {
        css['top'] = anchorPt;
      }

      this.isStuck = false;
      this.$element.removeClass("is-stuck is-at-".concat(stickTo)).addClass("is-anchored is-at-".concat(topOrBottom)).css(css)
      /**
       * Fires when the $element has become anchored.
       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`
       * @event Sticky#unstuckfrom
       */
      .trigger("sticky.zf.unstuckfrom:".concat(topOrBottom));
    }
    /**
     * Sets the $element and $container sizes for plugin.
     * Calls `_setBreakPoints`.
     * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.
     * @private
     */

  }, {
    key: "_setSizes",
    value: function _setSizes(cb) {
      this.canStick = MediaQuery.is(this.options.stickyOn);

      if (!this.canStick) {
        if (cb && typeof cb === 'function') {
          cb();
        }
      }

      var newElemWidth = this.$container[0].getBoundingClientRect().width,
          comp = window.getComputedStyle(this.$container[0]),
          pdngl = parseInt(comp['padding-left'], 10),
          pdngr = parseInt(comp['padding-right'], 10);

      if (this.$anchor && this.$anchor.length) {
        this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;
      } else {
        this._parsePoints();
      }

      this.$element.css({
        'max-width': "".concat(newElemWidth - pdngl - pdngr, "px")
      });
      var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;

      if (this.$element.css("display") == "none") {
        newContainerHeight = 0;
      }

      this.containerHeight = newContainerHeight;
      this.$container.css({
        height: newContainerHeight
      });
      this.elemHeight = newContainerHeight;

      if (!this.isStuck) {
        if (this.$element.hasClass('is-at-bottom')) {
          var anchorPt = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;
          this.$element.css('top', anchorPt);
        }
      }

      this._setBreakPoints(newContainerHeight, function () {
        if (cb && typeof cb === 'function') {
          cb();
        }
      });
    }
    /**
     * Sets the upper and lower breakpoints for the element to become sticky/unsticky.
     * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.
     * @param {Function} cb - optional callback function to be called on completion.
     * @private
     */

  }, {
    key: "_setBreakPoints",
    value: function _setBreakPoints(elemHeight, cb) {
      if (!this.canStick) {
        if (cb && typeof cb === 'function') {
          cb();
        } else {
          return false;
        }
      }

      var mTop = emCalc(this.options.marginTop),
          mBtm = emCalc(this.options.marginBottom),
          topPoint = this.points ? this.points[0] : this.$anchor.offset().top,
          bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,

      // topPoint = this.$anchor.offset().top || this.points[0],
      // bottomPoint = topPoint + this.anchorHeight || this.points[1],
      winHeight = window.innerHeight;

      if (this.options.stickTo === 'top') {
        topPoint -= mTop;
        bottomPoint -= elemHeight + mTop;
      } else if (this.options.stickTo === 'bottom') {
        topPoint -= winHeight - (elemHeight + mBtm);
        bottomPoint -= winHeight - mBtm;
      }

      this.topPoint = topPoint;
      this.bottomPoint = bottomPoint;

      if (cb && typeof cb === 'function') {
        cb();
      }
    }
    /**
     * Destroys the current sticky element.
     * Resets the element to the top position first.
     * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this._removeSticky(true);

      this.$element.removeClass("".concat(this.options.stickyClass, " is-anchored is-at-top")).css({
        height: '',
        top: '',
        bottom: '',
        'max-width': ''
      }).off('resizeme.zf.trigger').off('mutateme.zf.trigger');

      if (this.$anchor && this.$anchor.length) {
        this.$anchor.off('change.zf.sticky');
      }

      if (this.scrollListener) (0, _jquery2.default)(window).off(this.scrollListener);
      if (this.onLoadListener) (0, _jquery2.default)(window).off(this.onLoadListener);

      if (this.wasWrapped) {
        this.$element.unwrap();
      } else {
        this.$container.removeClass(this.options.containerClass).css({
          height: ''
        });
      }
    }
  }]);

  return Sticky;
}(Plugin);

Sticky.defaults = {
  /**
   * Customizable container template. Add your own classes for styling and sizing.
   * @option
   * @type {string}
   * @default '&lt;div data-sticky-container&gt;&lt;/div&gt;'
   */
  container: '<div data-sticky-container></div>',

  /**
   * Location in the view the element sticks to. Can be `'top'` or `'bottom'`.
   * @option
   * @type {string}
   * @default 'top'
   */
  stickTo: 'top',

  /**
   * If anchored to a single element, the id of that element.
   * @option
   * @type {string}
   * @default ''
   */
  anchor: '',

  /**
   * If using more than one element as anchor points, the id of the top anchor.
   * @option
   * @type {string}
   * @default ''
   */
  topAnchor: '',

  /**
   * If using more than one element as anchor points, the id of the bottom anchor.
   * @option
   * @type {string}
   * @default ''
   */
  btmAnchor: '',

  /**
   * Margin, in `em`'s to apply to the top of the element when it becomes sticky.
   * @option
   * @type {number}
   * @default 1
   */
  marginTop: 1,

  /**
   * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.
   * @option
   * @type {number}
   * @default 1
   */
  marginBottom: 1,

  /**
   * Breakpoint string that is the minimum screen size an element should become sticky.
   * @option
   * @type {string}
   * @default 'medium'
   */
  stickyOn: 'medium',

  /**
   * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.
   * @option
   * @type {string}
   * @default 'sticky'
   */
  stickyClass: 'sticky',

  /**
   * Class applied to sticky container. Foundation defaults to `sticky-container`.
   * @option
   * @type {string}
   * @default 'sticky-container'
   */
  containerClass: 'sticky-container',

  /**
   * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.
   * @option
   * @type {number}
   * @default -1
   */
  checkEvery: -1
};
/**
 * Helper function to calculate em values
 * @param Number {em} - number of em's to calculate into pixels
 */

function emCalc(em) {
  return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;
}

/**
 * Tabs module.
 * @module foundation.tabs
 * @requires foundation.util.keyboard
 * @requires foundation.util.imageLoader if tabs contain images
 */

var Tabs =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Tabs, _Plugin);

  function Tabs() {
    _classCallCheck(this, Tabs);

    return _possibleConstructorReturn(this, _getPrototypeOf(Tabs).apply(this, arguments));
  }

  _createClass(Tabs, [{
    key: "_setup",

    /**
     * Creates a new instance of tabs.
     * @class
     * @name Tabs
     * @fires Tabs#init
     * @param {jQuery} element - jQuery object to make into tabs.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Tabs.defaults, this.$element.data(), options);
      this.className = 'Tabs'; // ie9 back compat

      this._init();

      Keyboard.register('Tabs', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'previous',
        'ARROW_DOWN': 'next',
        'ARROW_LEFT': 'previous' // 'TAB': 'next',
        // 'SHIFT_TAB': 'previous'

      });
    }
    /**
     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      var _this = this;

      this._isInitializing = true;
      this.$element.attr({
        'role': 'tablist'
      });
      this.$tabTitles = this.$element.find(".".concat(this.options.linkClass));
      this.$tabContent = (0, _jquery2.default)("[data-tabs-content=\"".concat(this.$element[0].id, "\"]"));
      this.$tabTitles.each(function () {
        var $elem = (0, _jquery2.default)(this),
            $link = $elem.find('a'),
            isActive = $elem.hasClass("".concat(_this.options.linkActiveClass)),
            hash = $link.attr('data-tabs-target') || $link[0].hash.slice(1),
            linkId = $link[0].id ? $link[0].id : "".concat(hash, "-label"),
            $tabContent = (0, _jquery2.default)("#".concat(hash));
        $elem.attr({
          'role': 'presentation'
        });
        $link.attr({
          'role': 'tab',
          'aria-controls': hash,
          'aria-selected': isActive,
          'id': linkId,
          'tabindex': isActive ? '0' : '-1'
        });
        $tabContent.attr({
          'role': 'tabpanel',
          'aria-labelledby': linkId
        }); // Save up the initial hash to return to it later when going back in history

        if (isActive) {
          _this._initialAnchor = "#".concat(hash);
        }

        if (!isActive) {
          $tabContent.attr('aria-hidden', 'true');
        }

        if (isActive && _this.options.autoFocus) {
          _this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
            (0, _jquery2.default)('html, body').animate({
              scrollTop: $elem.offset().top
            }, _this.options.deepLinkSmudgeDelay, function () {
              $link.focus();
            });
          });
        }
      });

      if (this.options.matchHeight) {
        var $images = this.$tabContent.find('img');

        if ($images.length) {
          onImagesLoaded($images, this._setHeight.bind(this));
        } else {
          this._setHeight();
        }
      } // Current context-bound function to open tabs on page load or history hashchange


      this._checkDeepLink = function () {
        var anchor = window.location.hash;

        if (!anchor.length) {
          // If we are still initializing and there is no anchor, then there is nothing to do
          if (_this2._isInitializing) return; // Otherwise, move to the initial anchor

          if (_this2._initialAnchor) anchor = _this2._initialAnchor;
        }

        var $anchor = anchor && (0, _jquery2.default)(anchor);

        var $link = anchor && _this2.$element.find('[href$="' + anchor + '"]'); // Whether the anchor element that has been found is part of this element


        var isOwnAnchor = !!($anchor.length && $link.length); // If there is an anchor for the hash, select it

        if ($anchor && $anchor.length && $link && $link.length) {
          _this2.selectTab($anchor, true);
        } // Otherwise, collapse everything
        else {
            _this2._collapse();
          }

        if (isOwnAnchor) {
          // Roll up a little to show the titles
          if (_this2.options.deepLinkSmudge) {
            var offset = _this2.$element.offset();

            (0, _jquery2.default)('html, body').animate({
              scrollTop: offset.top
            }, _this2.options.deepLinkSmudgeDelay);
          }
          /**
           * Fires when the plugin has deeplinked at pageload
           * @event Tabs#deeplink
           */

          _this2.$element.trigger('deeplink.zf.tabs', [$link, $anchor]);
        }
      }; //use browser to open a tab, if it exists in this tabset


      if (this.options.deepLink) {
        this._checkDeepLink();
      }

      this._events();

      this._isInitializing = false;
    }
    /**
     * Adds event handlers for items within the tabs.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this._addKeyHandler();

      this._addClickHandler();

      this._setHeightMqHandler = null;

      if (this.options.matchHeight) {
        this._setHeightMqHandler = this._setHeight.bind(this);
        (0, _jquery2.default)(window).on('changed.zf.mediaquery', this._setHeightMqHandler);
      }

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).on('hashchange', this._checkDeepLink);
      }
    }
    /**
     * Adds click handlers for items within the tabs.
     * @private
     */

  }, {
    key: "_addClickHandler",
    value: function _addClickHandler() {
      var _this = this;

      this.$element.off('click.zf.tabs').on('click.zf.tabs', ".".concat(this.options.linkClass), function (e) {
        e.preventDefault();
        e.stopPropagation();

        _this._handleTabChange((0, _jquery2.default)(this));
      });
    }
    /**
     * Adds keyboard event handlers for items within the tabs.
     * @private
     */

  }, {
    key: "_addKeyHandler",
    value: function _addKeyHandler() {
      var _this = this;

      this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function (e) {
        if (e.which === 9) return;
        var $element = (0, _jquery2.default)(this),
            $elements = $element.parent('ul').children('li'),
            $prevElement,
            $nextElement;
        $elements.each(function (i) {
          if ((0, _jquery2.default)(this).is($element)) {
            if (_this.options.wrapOnKeys) {
              $prevElement = i === 0 ? $elements.last() : $elements.eq(i - 1);
              $nextElement = i === $elements.length - 1 ? $elements.first() : $elements.eq(i + 1);
            } else {
              $prevElement = $elements.eq(Math.max(0, i - 1));
              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));
            }

            return;
          }
        }); // handle keyboard event with keyboard util

        Keyboard.handleKey(e, 'Tabs', {
          open: function open() {
            $element.find('[role="tab"]').focus();

            _this._handleTabChange($element);
          },
          previous: function previous() {
            $prevElement.find('[role="tab"]').focus();

            _this._handleTabChange($prevElement);
          },
          next: function next() {
            $nextElement.find('[role="tab"]').focus();

            _this._handleTabChange($nextElement);
          },
          handled: function handled() {
            e.stopPropagation();
            e.preventDefault();
          }
        });
      });
    }
    /**
     * Opens the tab `$targetContent` defined by `$target`. Collapses active tab.
     * @param {jQuery} $target - Tab to open.
     * @param {boolean} historyHandled - browser has already handled a history update
     * @fires Tabs#change
     * @function
     */

  }, {
    key: "_handleTabChange",
    value: function _handleTabChange($target, historyHandled) {
      // With `activeCollapse`, if the target is the active Tab, collapse it.
      if ($target.hasClass("".concat(this.options.linkActiveClass))) {
        if (this.options.activeCollapse) {
          this._collapse();
        }

        return;
      }

      var $oldTab = this.$element.find(".".concat(this.options.linkClass, ".").concat(this.options.linkActiveClass)),
          $tabLink = $target.find('[role="tab"]'),
          target = $tabLink.attr('data-tabs-target'),
          anchor = target && target.length ? "#".concat(target) : $tabLink[0].hash,
          $targetContent = this.$tabContent.find(anchor); //close old tab

      this._collapseTab($oldTab); //open new tab


      this._openTab($target); //either replace or update browser history


      if (this.options.deepLink && !historyHandled) {
        if (this.options.updateHistory) {
          history.pushState({}, '', anchor);
        } else {
          history.replaceState({}, '', anchor);
        }
      }
      /**
       * Fires when the plugin has successfully changed tabs.
       * @event Tabs#change
       */

      this.$element.trigger('change.zf.tabs', [$target, $targetContent]); //fire to children a mutation event

      $targetContent.find("[data-mutate]").trigger("mutateme.zf.trigger");
    }
    /**
     * Opens the tab `$targetContent` defined by `$target`.
     * @param {jQuery} $target - Tab to open.
     * @function
     */

  }, {
    key: "_openTab",
    value: function _openTab($target) {
      var $tabLink = $target.find('[role="tab"]'),
          hash = $tabLink.attr('data-tabs-target') || $tabLink[0].hash.slice(1),
          $targetContent = this.$tabContent.find("#".concat(hash));
      $target.addClass("".concat(this.options.linkActiveClass));
      $tabLink.attr({
        'aria-selected': 'true',
        'tabindex': '0'
      });
      $targetContent.addClass("".concat(this.options.panelActiveClass)).removeAttr('aria-hidden');
    }
    /**
     * Collapses `$targetContent` defined by `$target`.
     * @param {jQuery} $target - Tab to collapse.
     * @function
     */

  }, {
    key: "_collapseTab",
    value: function _collapseTab($target) {
      var $target_anchor = $target.removeClass("".concat(this.options.linkActiveClass)).find('[role="tab"]').attr({
        'aria-selected': 'false',
        'tabindex': -1
      });
      (0, _jquery2.default)("#".concat($target_anchor.attr('aria-controls'))).removeClass("".concat(this.options.panelActiveClass)).attr({
        'aria-hidden': 'true'
      });
    }
    /**
     * Collapses the active Tab.
     * @fires Tabs#collapse
     * @function
     */

  }, {
    key: "_collapse",
    value: function _collapse() {
      var $activeTab = this.$element.find(".".concat(this.options.linkClass, ".").concat(this.options.linkActiveClass));

      if ($activeTab.length) {
        this._collapseTab($activeTab);
        /**
        * Fires when the plugin has successfully collapsed tabs.
        * @event Tabs#collapse
        */

        this.$element.trigger('collapse.zf.tabs', [$activeTab]);
      }
    }
    /**
     * Public method for selecting a content pane to display.
     * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.
     * @param {boolean} historyHandled - browser has already handled a history update
     * @function
     */

  }, {
    key: "selectTab",
    value: function selectTab(elem, historyHandled) {
      var idStr;

      if (_typeof(elem) === 'object') {
        idStr = elem[0].id;
      } else {
        idStr = elem;
      }

      if (idStr.indexOf('#') < 0) {
        idStr = "#".concat(idStr);
      }

      var $target = this.$tabTitles.has("[href$=\"".concat(idStr, "\"]"));

      this._handleTabChange($target, historyHandled);
    }
  }, {
    key: "_setHeight",

    /**
     * Sets the height of each panel to the height of the tallest panel.
     * If enabled in options, gets called on media query change.
     * If loading content via external source, can be called directly or with _reflow.
     * If enabled with `data-match-height="true"`, tabs sets to equal height
     * @function
     * @private
     */
    value: function _setHeight() {
      var max = 0,
          _this = this; // Lock down the `this` value for the root tabs object


      this.$tabContent.find(".".concat(this.options.panelClass)).css('height', '').each(function () {
        var panel = (0, _jquery2.default)(this),
            isActive = panel.hasClass("".concat(_this.options.panelActiveClass)); // get the options from the parent instead of trying to get them from the child

        if (!isActive) {
          panel.css({
            'visibility': 'hidden',
            'display': 'block'
          });
        }

        var temp = this.getBoundingClientRect().height;

        if (!isActive) {
          panel.css({
            'visibility': '',
            'display': ''
          });
        }

        max = temp > max ? temp : max;
      }).css('height', "".concat(max, "px"));
    }
    /**
     * Destroys an instance of tabs.
     * @fires Tabs#destroyed
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.find(".".concat(this.options.linkClass)).off('.zf.tabs').hide().end().find(".".concat(this.options.panelClass)).hide();

      if (this.options.matchHeight) {
        if (this._setHeightMqHandler != null) {
          (0, _jquery2.default)(window).off('changed.zf.mediaquery', this._setHeightMqHandler);
        }
      }

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).off('hashchange', this._checkDeepLink);
      }

      if (this.onLoadListener) {
        (0, _jquery2.default)(window).off(this.onLoadListener);
      }
    }
  }]);

  return Tabs;
}(Plugin);

Tabs.defaults = {
  /**
   * Link the location hash to the active pane.
   * Set the location hash when the active pane changes, and open the corresponding pane when the location changes.
   * @option
   * @type {boolean}
   * @default false
   */
  deepLink: false,

  /**
   * If `deepLink` is enabled, adjust the deep link scroll to make sure the top of the tab panel is visible
   * @option
   * @type {boolean}
   * @default false
   */
  deepLinkSmudge: false,

  /**
   * If `deepLinkSmudge` is enabled, animation time (ms) for the deep link adjustment
   * @option
   * @type {number}
   * @default 300
   */
  deepLinkSmudgeDelay: 300,

  /**
   * If `deepLink` is enabled, update the browser history with the open tab
   * @option
   * @type {boolean}
   * @default false
   */
  updateHistory: false,

  /**
   * Allows the window to scroll to content of active pane on load.
   * Not recommended if more than one tab panel per page.
   * @option
   * @type {boolean}
   * @default false
   */
  autoFocus: false,

  /**
   * Allows keyboard input to 'wrap' around the tab links.
   * @option
   * @type {boolean}
   * @default true
   */
  wrapOnKeys: true,

  /**
   * Allows the tab content panes to match heights if set to true.
   * @option
   * @type {boolean}
   * @default false
   */
  matchHeight: false,

  /**
   * Allows active tabs to collapse when clicked.
   * @option
   * @type {boolean}
   * @default false
   */
  activeCollapse: false,

  /**
   * Class applied to `li`'s in tab link list.
   * @option
   * @type {string}
   * @default 'tabs-title'
   */
  linkClass: 'tabs-title',

  /**
   * Class applied to the active `li` in tab link list.
   * @option
   * @type {string}
   * @default 'is-active'
   */
  linkActiveClass: 'is-active',

  /**
   * Class applied to the content containers.
   * @option
   * @type {string}
   * @default 'tabs-panel'
   */
  panelClass: 'tabs-panel',

  /**
   * Class applied to the active content container.
   * @option
   * @type {string}
   * @default 'is-active'
   */
  panelActiveClass: 'is-active'
};

/**
 * Toggler module.
 * @module foundation.toggler
 * @requires foundation.util.motion
 * @requires foundation.util.triggers
 */

var Toggler =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Toggler, _Plugin);

  function Toggler() {
    _classCallCheck(this, Toggler);

    return _possibleConstructorReturn(this, _getPrototypeOf(Toggler).apply(this, arguments));
  }

  _createClass(Toggler, [{
    key: "_setup",

    /**
     * Creates a new instance of Toggler.
     * @class
     * @name Toggler
     * @fires Toggler#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Toggler.defaults, element.data(), options);
      this.className = '';
      this.className = 'Toggler'; // ie9 back compat
      // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      this._init();

      this._events();
    }
    /**
     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var input; // Parse animation classes if they were set

      if (this.options.animate) {
        input = this.options.animate.split(' ');
        this.animationIn = input[0];
        this.animationOut = input[1] || null;
      } // Otherwise, parse toggle class
      else {
          input = this.$element.data('toggler'); // Allow for a . at the beginning of the string

          this.className = input[0] === '.' ? input.slice(1) : input;
        } // Add ARIA attributes to triggers:


      var id = this.$element[0].id,
          $triggers = (0, _jquery2.default)("[data-open~=\"".concat(id, "\"], [data-close~=\"").concat(id, "\"], [data-toggle~=\"").concat(id, "\"]")); // - aria-expanded: according to the element visibility.

      $triggers.attr('aria-expanded', !this.$element.is(':hidden')); // - aria-controls: adding the element id to it if not already in it.

      $triggers.each(function (index, trigger) {
        var $trigger = (0, _jquery2.default)(trigger);
        var controls = $trigger.attr('aria-controls') || '';
        var containsId = new RegExp("\\b".concat(RegExpEscape(id), "\\b")).test(controls);
        if (!containsId) $trigger.attr('aria-controls', controls ? "".concat(controls, " ").concat(id) : id);
      });
    }
    /**
     * Initializes events for the toggle trigger.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this.$element.off('toggle.zf.trigger').on('toggle.zf.trigger', this.toggle.bind(this));
    }
    /**
     * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was "on" or "off".
     * @function
     * @fires Toggler#on
     * @fires Toggler#off
     */

  }, {
    key: "toggle",
    value: function toggle() {
      this[this.options.animate ? '_toggleAnimate' : '_toggleClass']();
    }
  }, {
    key: "_toggleClass",
    value: function _toggleClass() {
      this.$element.toggleClass(this.className);
      var isOn = this.$element.hasClass(this.className);

      if (isOn) {
        /**
         * Fires if the target element has the class after a toggle.
         * @event Toggler#on
         */
        this.$element.trigger('on.zf.toggler');
      } else {
        /**
         * Fires if the target element does not have the class after a toggle.
         * @event Toggler#off
         */
        this.$element.trigger('off.zf.toggler');
      }

      this._updateARIA(isOn);

      this.$element.find('[data-mutate]').trigger('mutateme.zf.trigger');
    }
  }, {
    key: "_toggleAnimate",
    value: function _toggleAnimate() {
      var _this = this;

      if (this.$element.is(':hidden')) {
        Motion.animateIn(this.$element, this.animationIn, function () {
          _this._updateARIA(true);

          this.trigger('on.zf.toggler');
          this.find('[data-mutate]').trigger('mutateme.zf.trigger');
        });
      } else {
        Motion.animateOut(this.$element, this.animationOut, function () {
          _this._updateARIA(false);

          this.trigger('off.zf.toggler');
          this.find('[data-mutate]').trigger('mutateme.zf.trigger');
        });
      }
    }
  }, {
    key: "_updateARIA",
    value: function _updateARIA(isOn) {
      var id = this.$element[0].id;
      (0, _jquery2.default)("[data-open=\"".concat(id, "\"], [data-close=\"").concat(id, "\"], [data-toggle=\"").concat(id, "\"]")).attr({
        'aria-expanded': isOn ? true : false
      });
    }
    /**
     * Destroys the instance of Toggler on the element.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.toggler');
    }
  }]);

  return Toggler;
}(Plugin);

Toggler.defaults = {
  /**
   * Tells the plugin if the element should animated when toggled.
   * @option
   * @type {boolean}
   * @default false
   */
  animate: false
};

/**
 * Tooltip module.
 * @module foundation.tooltip
 * @requires foundation.util.box
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.triggers
 */

var Tooltip =
/*#__PURE__*/
function (_Positionable) {
  _inherits(Tooltip, _Positionable);

  function Tooltip() {
    _classCallCheck(this, Tooltip);

    return _possibleConstructorReturn(this, _getPrototypeOf(Tooltip).apply(this, arguments));
  }

  _createClass(Tooltip, [{
    key: "_setup",

    /**
     * Creates a new instance of a Tooltip.
     * @class
     * @name Tooltip
     * @fires Tooltip#init
     * @param {jQuery} element - jQuery object to attach a tooltip to.
     * @param {Object} options - object to extend the default configuration.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Tooltip.defaults, this.$element.data(), options);
      this.className = 'Tooltip'; // ie9 back compat

      this.isActive = false;
      this.isClick = false; // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      this._init();
    }
    /**
     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init();

      var elemId = this.$element.attr('aria-describedby') || GetYoDigits(6, 'tooltip');
      this.options.tipText = this.options.tipText || this.$element.attr('title');
      this.template = this.options.template ? (0, _jquery2.default)(this.options.template) : this._buildTemplate(elemId);

      if (this.options.allowHtml) {
        this.template.appendTo(document.body).html(this.options.tipText).hide();
      } else {
        this.template.appendTo(document.body).text(this.options.tipText).hide();
      }

      this.$element.attr({
        'title': '',
        'aria-describedby': elemId,
        'data-yeti-box': elemId,
        'data-toggle': elemId,
        'data-resize': elemId
      }).addClass(this.options.triggerClass);

      _get(_getPrototypeOf(Tooltip.prototype), "_init", this).call(this);

      this._events();
    }
  }, {
    key: "_getDefaultPosition",
    value: function _getDefaultPosition() {
      // handle legacy classnames
      var position = this.$element[0].className.match(/\b(top|left|right|bottom)\b/g);
      return position ? position[0] : 'top';
    }
  }, {
    key: "_getDefaultAlignment",
    value: function _getDefaultAlignment() {
      return 'center';
    }
  }, {
    key: "_getHOffset",
    value: function _getHOffset() {
      if (this.position === 'left' || this.position === 'right') {
        return this.options.hOffset + this.options.tooltipWidth;
      } else {
        return this.options.hOffset;
      }
    }
  }, {
    key: "_getVOffset",
    value: function _getVOffset() {
      if (this.position === 'top' || this.position === 'bottom') {
        return this.options.vOffset + this.options.tooltipHeight;
      } else {
        return this.options.vOffset;
      }
    }
    /**
     * builds the tooltip element, adds attributes, and returns the template.
     * @private
     */

  }, {
    key: "_buildTemplate",
    value: function _buildTemplate(id) {
      var templateClasses = "".concat(this.options.tooltipClass, " ").concat(this.options.templateClasses).trim();
      var $template = (0, _jquery2.default)('<div></div>').addClass(templateClasses).attr({
        'role': 'tooltip',
        'aria-hidden': true,
        'data-is-active': false,
        'data-is-focus': false,
        'id': id
      });
      return $template;
    }
    /**
     * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.
     * if the tooltip is larger than the screen width, default to full width - any user selected margin
     * @private
     */

  }, {
    key: "_setPosition",
    value: function _setPosition() {
      _get(_getPrototypeOf(Tooltip.prototype), "_setPosition", this).call(this, this.$element, this.template);
    }
    /**
     * reveals the tooltip, and fires an event to close any other open tooltips on the page
     * @fires Tooltip#closeme
     * @fires Tooltip#show
     * @function
     */

  }, {
    key: "show",
    value: function show() {
      if (this.options.showOn !== 'all' && !MediaQuery.is(this.options.showOn)) {
        // console.error('The screen is too small to display this tooltip');
        return false;
      }

      var _this = this;

      this.template.css('visibility', 'hidden').show();

      this._setPosition();

      this.template.removeClass('top bottom left right').addClass(this.position);
      this.template.removeClass('align-top align-bottom align-left align-right align-center').addClass('align-' + this.alignment);
      /**
       * Fires to close all other open tooltips on the page
       * @event Closeme#tooltip
       */

      this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));
      this.template.attr({
        'data-is-active': true,
        'aria-hidden': false
      });
      _this.isActive = true; // console.log(this.template);

      this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function () {//maybe do stuff?
      });
      /**
       * Fires when the tooltip is shown
       * @event Tooltip#show
       */

      this.$element.trigger('show.zf.tooltip');
    }
    /**
     * Hides the current tooltip, and resets the positioning class if it was changed due to collision
     * @fires Tooltip#hide
     * @function
     */

  }, {
    key: "hide",
    value: function hide() {
      // console.log('hiding', this.$element.data('yeti-box'));
      var _this = this;

      this.template.stop().attr({
        'aria-hidden': true,
        'data-is-active': false
      }).fadeOut(this.options.fadeOutDuration, function () {
        _this.isActive = false;
        _this.isClick = false;
      });
      /**
       * fires when the tooltip is hidden
       * @event Tooltip#hide
       */

      this.$element.trigger('hide.zf.tooltip');
    }
    /**
     * adds event listeners for the tooltip and its anchor
     * TODO combine some of the listeners like focus and mouseenter, etc.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      var $template = this.template;
      var isFocus = false;

      if (!this.options.disableHover) {
        this.$element.on('mouseenter.zf.tooltip', function (e) {
          if (!_this.isActive) {
            _this.timeout = setTimeout(function () {
              _this.show();
            }, _this.options.hoverDelay);
          }
        }).on('mouseleave.zf.tooltip', ignoreMousedisappear(function (e) {
          clearTimeout(_this.timeout);

          if (!isFocus || _this.isClick && !_this.options.clickOpen) {
            _this.hide();
          }
        }));
      }

      if (this.options.clickOpen) {
        this.$element.on('mousedown.zf.tooltip', function (e) {
          e.stopImmediatePropagation();

          if (_this.isClick) ;else {
            _this.isClick = true;

            if ((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive) {
              _this.show();
            }
          }
        });
      } else {
        this.$element.on('mousedown.zf.tooltip', function (e) {
          e.stopImmediatePropagation();
          _this.isClick = true;
        });
      }

      if (!this.options.disableForTouch) {
        this.$element.on('tap.zf.tooltip touchend.zf.tooltip', function (e) {
          _this.isActive ? _this.hide() : _this.show();
        });
      }

      this.$element.on({
        // 'toggle.zf.trigger': this.toggle.bind(this),
        // 'close.zf.trigger': this.hide.bind(this)
        'close.zf.trigger': this.hide.bind(this)
      });
      this.$element.on('focus.zf.tooltip', function (e) {
        isFocus = true;

        if (_this.isClick) {
          // If we're not showing open on clicks, we need to pretend a click-launched focus isn't
          // a real focus, otherwise on hover and come back we get bad behavior
          if (!_this.options.clickOpen) {
            isFocus = false;
          }

          return false;
        } else {
          _this.show();
        }
      }).on('focusout.zf.tooltip', function (e) {
        isFocus = false;
        _this.isClick = false;

        _this.hide();
      }).on('resizeme.zf.trigger', function () {
        if (_this.isActive) {
          _this._setPosition();
        }
      });
    }
    /**
     * adds a toggle method, in addition to the static show() & hide() functions
     * @function
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this.isActive) {
        this.hide();
      } else {
        this.show();
      }
    }
    /**
     * Destroys an instance of tooltip, removes template element from the view.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.attr('title', this.template.text()).off('.zf.trigger .zf.tooltip').removeClass(this.options.triggerClass).removeClass('top right left bottom').removeAttr('aria-describedby data-disable-hover data-resize data-toggle data-tooltip data-yeti-box');
      this.template.remove();
    }
  }]);

  return Tooltip;
}(Positionable);

Tooltip.defaults = {
  disableForTouch: false,

  /**
   * Time, in ms, before a tooltip should open on hover.
   * @option
   * @type {number}
   * @default 200
   */
  hoverDelay: 200,

  /**
   * Time, in ms, a tooltip should take to fade into view.
   * @option
   * @type {number}
   * @default 150
   */
  fadeInDuration: 150,

  /**
   * Time, in ms, a tooltip should take to fade out of view.
   * @option
   * @type {number}
   * @default 150
   */
  fadeOutDuration: 150,

  /**
   * Disables hover events from opening the tooltip if set to true
   * @option
   * @type {boolean}
   * @default false
   */
  disableHover: false,

  /**
   * Optional addtional classes to apply to the tooltip template on init.
   * @option
   * @type {string}
   * @default ''
   */
  templateClasses: '',

  /**
   * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.
   * @option
   * @type {string}
   * @default 'tooltip'
   */
  tooltipClass: 'tooltip',

  /**
   * Class applied to the tooltip anchor element.
   * @option
   * @type {string}
   * @default 'has-tip'
   */
  triggerClass: 'has-tip',

  /**
   * Minimum breakpoint size at which to open the tooltip.
   * @option
   * @type {string}
   * @default 'small'
   */
  showOn: 'small',

  /**
   * Custom template to be used to generate markup for tooltip.
   * @option
   * @type {string}
   * @default ''
   */
  template: '',

  /**
   * Text displayed in the tooltip template on open.
   * @option
   * @type {string}
   * @default ''
   */
  tipText: '',
  touchCloseText: 'Tap to close.',

  /**
   * Allows the tooltip to remain open if triggered with a click or touch event.
   * @option
   * @type {boolean}
   * @default true
   */
  clickOpen: true,

  /**
   * Position of tooltip. Can be left, right, bottom, top, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  position: 'auto',

  /**
   * Alignment of tooltip relative to anchor. Can be left, right, bottom, top, center, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  alignment: 'auto',

  /**
   * Allow overlap of container/window. If false, tooltip will first try to
   * position as defined by data-position and data-alignment, but reposition if
   * it would cause an overflow.  @option
   * @type {boolean}
   * @default false
   */
  allowOverlap: false,

  /**
   * Allow overlap of only the bottom of the container. This is the most common
   * behavior for dropdowns, allowing the dropdown to extend the bottom of the
   * screen but not otherwise influence or break out of the container.
   * Less common for tooltips.
   * @option
   * @type {boolean}
   * @default false
   */
  allowBottomOverlap: false,

  /**
   * Distance, in pixels, the template should push away from the anchor on the Y axis.
   * @option
   * @type {number}
   * @default 0
   */
  vOffset: 0,

  /**
   * Distance, in pixels, the template should push away from the anchor on the X axis
   * @option
   * @type {number}
   * @default 0
   */
  hOffset: 0,

  /**
   * Distance, in pixels, the template spacing auto-adjust for a vertical tooltip
   * @option
   * @type {number}
   * @default 14
   */
  tooltipHeight: 14,

  /**
   * Distance, in pixels, the template spacing auto-adjust for a horizontal tooltip
   * @option
   * @type {number}
   * @default 12
   */
  tooltipWidth: 12,

  /**
  * Allow HTML in tooltip. Warning: If you are loading user-generated content into tooltips,
  * allowing HTML may open yourself up to XSS attacks.
  * @option
  * @type {boolean}
  * @default false
  */
  allowHtml: false
};

var MenuPlugins$1 = {
  tabs: {
    cssClass: 'tabs',
    plugin: Tabs
  },
  accordion: {
    cssClass: 'accordion',
    plugin: Accordion
  }
};
/**
 * ResponsiveAccordionTabs module.
 * @module foundation.responsiveAccordionTabs
 * @requires foundation.util.motion
 * @requires foundation.accordion
 * @requires foundation.tabs
 */

var ResponsiveAccordionTabs =
/*#__PURE__*/
function (_Plugin) {
  _inherits(ResponsiveAccordionTabs, _Plugin);

  function ResponsiveAccordionTabs() {
    _classCallCheck(this, ResponsiveAccordionTabs);

    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveAccordionTabs).apply(this, arguments));
  }

  _createClass(ResponsiveAccordionTabs, [{
    key: "_setup",

    /**
     * Creates a new instance of a responsive accordion tabs.
     * @class
     * @name ResponsiveAccordionTabs
     * @fires ResponsiveAccordionTabs#init
     * @param {jQuery} element - jQuery object to make into Responsive Accordion Tabs.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = (0, _jquery2.default)(element);
      this.options = _jquery2.default.extend({}, this.$element.data(), options);
      this.rules = this.$element.data('responsive-accordion-tabs');
      this.currentMq = null;
      this.currentPlugin = null;
      this.className = 'ResponsiveAccordionTabs'; // ie9 back compat

      if (!this.$element.attr('id')) {
        this.$element.attr('id', GetYoDigits(6, 'responsiveaccordiontabs'));
      }

      this._init();

      this._events();
    }
    /**
     * Initializes the Menu by parsing the classes from the 'data-responsive-accordion-tabs' attribute on the element.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init(); // The first time an Interchange plugin is initialized, this.rules is converted from a string of "classes" to an object of rules


      if (typeof this.rules === 'string') {
        var rulesTree = {}; // Parse rules from "classes" pulled from data attribute

        var rules = this.rules.split(' '); // Iterate through every rule found

        for (var i = 0; i < rules.length; i++) {
          var rule = rules[i].split('-');
          var ruleSize = rule.length > 1 ? rule[0] : 'small';
          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];

          if (MenuPlugins$1[rulePlugin] !== null) {
            rulesTree[ruleSize] = MenuPlugins$1[rulePlugin];
          }
        }

        this.rules = rulesTree;
      }

      this._getAllOptions();

      if (!_jquery2.default.isEmptyObject(this.rules)) {
        this._checkMediaQueries();
      }
    }
  }, {
    key: "_getAllOptions",
    value: function _getAllOptions() {
      //get all defaults and options
      var _this = this;

      _this.allOptions = {};

      for (var key in MenuPlugins$1) {
        if (MenuPlugins$1.hasOwnProperty(key)) {
          var obj = MenuPlugins$1[key];

          try {
            var dummyPlugin = (0, _jquery2.default)('<ul></ul>');
            var tmpPlugin = new obj.plugin(dummyPlugin, _this.options);

            for (var keyKey in tmpPlugin.options) {
              if (tmpPlugin.options.hasOwnProperty(keyKey) && keyKey !== 'zfPlugin') {
                var objObj = tmpPlugin.options[keyKey];
                _this.allOptions[keyKey] = objObj;
              }
            }

            tmpPlugin.destroy();
          } catch (e) {}
        }
      }
    }
    /**
     * Initializes events for the Menu.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this._changedZfMediaQueryHandler = this._checkMediaQueries.bind(this);
      (0, _jquery2.default)(window).on('changed.zf.mediaquery', this._changedZfMediaQueryHandler);
    }
    /**
     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.
     * @function
     * @private
     */

  }, {
    key: "_checkMediaQueries",
    value: function _checkMediaQueries() {
      var matchedMq,
          _this = this; // Iterate through each rule and find the last matching rule


      _jquery2.default.each(this.rules, function (key) {
        if (MediaQuery.atLeast(key)) {
          matchedMq = key;
        }
      }); // No match? No dice

      if (!matchedMq) return; // Plugin already initialized? We good

      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return; // Remove existing plugin-specific CSS classes

      _jquery2.default.each(MenuPlugins$1, function (key, value) {
        _this.$element.removeClass(value.cssClass);
      }); // Add the CSS class for the new plugin

      this.$element.addClass(this.rules[matchedMq].cssClass); // Create an instance of the new plugin

      if (this.currentPlugin) {
        //don't know why but on nested elements data zfPlugin get's lost
        if (!this.currentPlugin.$element.data('zfPlugin') && this.storezfData) this.currentPlugin.$element.data('zfPlugin', this.storezfData);
        this.currentPlugin.destroy();
      }

      this._handleMarkup(this.rules[matchedMq].cssClass);

      this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});
      this.storezfData = this.currentPlugin.$element.data('zfPlugin');
    }
  }, {
    key: "_handleMarkup",
    value: function _handleMarkup(toSet) {
      var _this = this,
          fromString = 'accordion';

      var $panels = (0, _jquery2.default)('[data-tabs-content=' + this.$element.attr('id') + ']');
      if ($panels.length) fromString = 'tabs';

      if (fromString === toSet) {
        return;
      }
      var tabsTitle = _this.allOptions.linkClass ? _this.allOptions.linkClass : 'tabs-title';
      var tabsPanel = _this.allOptions.panelClass ? _this.allOptions.panelClass : 'tabs-panel';
      this.$element.removeAttr('role');
      var $liHeads = this.$element.children('.' + tabsTitle + ',[data-accordion-item]').removeClass(tabsTitle).removeClass('accordion-item').removeAttr('data-accordion-item');
      var $liHeadsA = $liHeads.children('a').removeClass('accordion-title');

      if (fromString === 'tabs') {
        $panels = $panels.children('.' + tabsPanel).removeClass(tabsPanel).removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-labelledby');
        $panels.children('a').removeAttr('role').removeAttr('aria-controls').removeAttr('aria-selected');
      } else {
        $panels = $liHeads.children('[data-tab-content]').removeClass('accordion-content');
      }
      $panels.css({
        display: '',
        visibility: ''
      });
      $liHeads.css({
        display: '',
        visibility: ''
      });

      if (toSet === 'accordion') {
        $panels.each(function (key, value) {
          (0, _jquery2.default)(value).appendTo($liHeads.get(key)).addClass('accordion-content').attr('data-tab-content', '').removeClass('is-active').css({
            height: ''
          });
          (0, _jquery2.default)('[data-tabs-content=' + _this.$element.attr('id') + ']').after('<div id="tabs-placeholder-' + _this.$element.attr('id') + '"></div>').detach();
          $liHeads.addClass('accordion-item').attr('data-accordion-item', '');
          $liHeadsA.addClass('accordion-title');
        });
      } else if (toSet === 'tabs') {
        var $tabsContent = (0, _jquery2.default)('[data-tabs-content=' + _this.$element.attr('id') + ']');
        var $placeholder = (0, _jquery2.default)('#tabs-placeholder-' + _this.$element.attr('id'));

        if ($placeholder.length) {
          $tabsContent = (0, _jquery2.default)('<div class="tabs-content"></div>').insertAfter($placeholder).attr('data-tabs-content', _this.$element.attr('id'));
          $placeholder.remove();
        } else {
          $tabsContent = (0, _jquery2.default)('<div class="tabs-content"></div>').insertAfter(_this.$element).attr('data-tabs-content', _this.$element.attr('id'));
        }
        $panels.each(function (key, value) {
          var tempValue = (0, _jquery2.default)(value).appendTo($tabsContent).addClass(tabsPanel);
          var hash = $liHeadsA.get(key).hash.slice(1);
          var id = (0, _jquery2.default)(value).attr('id') || GetYoDigits(6, 'accordion');

          if (hash !== id) {
            if (hash !== '') {
              (0, _jquery2.default)(value).attr('id', hash);
            } else {
              hash = id;
              (0, _jquery2.default)(value).attr('id', hash);
              (0, _jquery2.default)($liHeadsA.get(key)).attr('href', (0, _jquery2.default)($liHeadsA.get(key)).attr('href').replace('#', '') + '#' + hash);
            }
          }
          var isActive = (0, _jquery2.default)($liHeads.get(key)).hasClass('is-active');

          if (isActive) {
            tempValue.addClass('is-active');
          }
        });
        $liHeads.addClass(tabsTitle);
      }
    }
    /**
     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      if (this.currentPlugin) this.currentPlugin.destroy();
      (0, _jquery2.default)(window).off('changed.zf.mediaquery', this._changedZfMediaQueryHandler);
    }
  }]);

  return ResponsiveAccordionTabs;
}(Plugin);

ResponsiveAccordionTabs.defaults = {};

Foundation.addToJquery(_jquery2.default); // Add Foundation Utils to Foundation global namespace for backwards
// compatibility.

Foundation.rtl = rtl;
Foundation.GetYoDigits = GetYoDigits;
Foundation.transitionend = transitionend;
Foundation.RegExpEscape = RegExpEscape;
Foundation.onLoad = onLoad;
Foundation.Box = Box;
Foundation.onImagesLoaded = onImagesLoaded;
Foundation.Keyboard = Keyboard;
Foundation.MediaQuery = MediaQuery;
Foundation.Motion = Motion;
Foundation.Move = Move;
Foundation.Nest = Nest;
Foundation.Timer = Timer; // Touch and Triggers previously were almost purely sede effect driven,
// so no need to add it to Foundation, just init them.

Touch.init(_jquery2.default);
Triggers.init(_jquery2.default, Foundation);

MediaQuery._init();

Foundation.plugin(Abide, 'Abide');
Foundation.plugin(Accordion, 'Accordion');
Foundation.plugin(AccordionMenu, 'AccordionMenu');
Foundation.plugin(Drilldown, 'Drilldown');
Foundation.plugin(Dropdown, 'Dropdown');
Foundation.plugin(DropdownMenu, 'DropdownMenu');
Foundation.plugin(Equalizer, 'Equalizer');
Foundation.plugin(Interchange, 'Interchange');
Foundation.plugin(Magellan, 'Magellan');
Foundation.plugin(OffCanvas, 'OffCanvas');
Foundation.plugin(Orbit, 'Orbit');
Foundation.plugin(ResponsiveMenu, 'ResponsiveMenu');
Foundation.plugin(ResponsiveToggle, 'ResponsiveToggle');
Foundation.plugin(Reveal, 'Reveal');
Foundation.plugin(Slider, 'Slider');
Foundation.plugin(SmoothScroll, 'SmoothScroll');
Foundation.plugin(Sticky, 'Sticky');
Foundation.plugin(Tabs, 'Tabs');
Foundation.plugin(Toggler, 'Toggler');
Foundation.plugin(Tooltip, 'Tooltip');
Foundation.plugin(ResponsiveAccordionTabs, 'ResponsiveAccordionTabs');

exports.default = Foundation;
exports.CoreUtils = foundation_core_utils;
exports.Core = Foundation;
exports.Box = Box;
exports.onImagesLoaded = onImagesLoaded;
exports.Keyboard = Keyboard;
exports.MediaQuery = MediaQuery;
exports.Motion = Motion;
exports.Move = Move;
exports.Nest = Nest;
exports.Timer = Timer;
exports.Touch = Touch;
exports.Triggers = Triggers;
exports.Abide = Abide;
exports.Accordion = Accordion;
exports.AccordionMenu = AccordionMenu;
exports.Drilldown = Drilldown;
exports.Dropdown = Dropdown;
exports.DropdownMenu = DropdownMenu;
exports.Equalizer = Equalizer;
exports.Interchange = Interchange;
exports.Magellan = Magellan;
exports.OffCanvas = OffCanvas;
exports.Orbit = Orbit;
exports.ResponsiveMenu = ResponsiveMenu;
exports.ResponsiveToggle = ResponsiveToggle;
exports.Reveal = Reveal;
exports.Slider = Slider;
exports.SmoothScroll = SmoothScroll;
exports.Sticky = Sticky;
exports.Tabs = Tabs;
exports.Toggler = Toggler;
exports.Tooltip = Tooltip;
exports.ResponsiveAccordionTabs = ResponsiveAccordionTabs;
exports.Foundation = Foundation;
//# sourceMappingURL=foundation.esm.js.map

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzQ0NjM2NDE3MGNlNDZhZTQxZTEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwialF1ZXJ5XCIiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2pzL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2hhdC1pbnB1dC9kaXN0L3doYXQtaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phcmFsbGF4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qYXJhbGxheC9zcmMvamFyYWxsYXguZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXRlLXJlYWR5L2xpdGVyZWFkeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFmbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamFyYWxsYXgvc3JjL2phcmFsbGF4LXZpZGVvLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlkZW8td29ya2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92aWRlby13b3JrZXIvc3JjL3ZpZGVvLXdvcmtlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phcmFsbGF4L3NyYy9qYXJhbGxheC1lbGVtZW50LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL2ZvdW5kYXRpb24uZXNtLmpzIl0sIm5hbWVzIjpbIndpbmRvdyIsIiQiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmb3VuZGF0aW9uIiwicXVlcnlTZWxlY3RvckFsbCIsInNwZWVkIiwiZ2V0RWxlbWVudEJ5SWQiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJxdWVyeVNlbGVjdG9yIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJ2YWx1ZSIsIl9zZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNhbGwiLCJfc3VwZXJQcm9wQmFzZSIsIm9iamVjdCIsInByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJfZ2V0IiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiZ2V0IiwiYmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJydGwiLCJhdHRyIiwiR2V0WW9EaWdpdHMiLCJuYW1lc3BhY2UiLCJNYXRoIiwicm91bmQiLCJwb3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiY29uY2F0IiwiUmVnRXhwRXNjYXBlIiwic3RyIiwicmVwbGFjZSIsInRyYW5zaXRpb25lbmQiLCIkZWxlbSIsInRyYW5zaXRpb25zIiwiZWxlbSIsImNyZWF0ZUVsZW1lbnQiLCJlbmQiLCJ0Iiwic3R5bGUiLCJzZXRUaW1lb3V0IiwidHJpZ2dlckhhbmRsZXIiLCJvbkxvYWQiLCJoYW5kbGVyIiwiZGlkTG9hZCIsInJlYWR5U3RhdGUiLCJldmVudFR5cGUiLCJjYiIsIm9uZSIsImlnbm9yZU1vdXNlZGlzYXBwZWFyIiwiX3JlZiIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIl9yZWYkaWdub3JlTGVhdmVXaW5kbyIsImlnbm9yZUxlYXZlV2luZG93IiwiX3JlZiRpZ25vcmVSZWFwcGVhciIsImlnbm9yZVJlYXBwZWFyIiwibGVhdmVFdmVudEhhbmRsZXIiLCJlTGVhdmUiLCJfbGVuIiwicmVzdCIsIkFycmF5IiwiX2tleSIsImNhbGxiYWNrIiwiYmluZCIsImFwcGx5IiwicmVsYXRlZFRhcmdldCIsImxlYXZlRXZlbnREZWJvdW5jZXIiLCJoYXNGb2N1cyIsInJlZW50ZXJFdmVudEhhbmRsZXIiLCJlUmVlbnRlciIsImN1cnJlbnRUYXJnZXQiLCJoYXMiLCJmb3VuZGF0aW9uX2NvcmVfdXRpbHMiLCJmcmVlemUiLCJtYXRjaE1lZGlhIiwic3R5bGVNZWRpYSIsIm1lZGlhIiwic2NyaXB0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbmZvIiwidHlwZSIsImlkIiwiaGVhZCIsImFwcGVuZENoaWxkIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsImdldENvbXB1dGVkU3R5bGUiLCJjdXJyZW50U3R5bGUiLCJtYXRjaE1lZGl1bSIsInRleHQiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCIsInRleHRDb250ZW50Iiwid2lkdGgiLCJtYXRjaGVzIiwiTWVkaWFRdWVyeSIsInF1ZXJpZXMiLCJjdXJyZW50IiwiX2luaXQiLCIkbWV0YSIsImFwcGVuZFRvIiwiZXh0cmFjdGVkU3R5bGVzIiwiY3NzIiwibmFtZWRRdWVyaWVzIiwicGFyc2VTdHlsZVRvT2JqZWN0IiwicHVzaCIsIm5hbWUiLCJfZ2V0Q3VycmVudFNpemUiLCJfd2F0Y2hlciIsImF0TGVhc3QiLCJzaXplIiwicXVlcnkiLCJpcyIsInRyaW0iLCJzcGxpdCIsIm1hdGNoZWQiLCJfdGhpcyIsIm9mZiIsIm9uIiwibmV3U2l6ZSIsImN1cnJlbnRTaXplIiwidHJpZ2dlciIsInN0eWxlT2JqZWN0IiwicmVkdWNlIiwicmV0IiwicGFyYW0iLCJwYXJ0cyIsInZhbCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlzQXJyYXkiLCJGT1VOREFUSU9OX1ZFUlNJT04iLCJGb3VuZGF0aW9uIiwidmVyc2lvbiIsIl9wbHVnaW5zIiwiX3V1aWRzIiwicGx1Z2luIiwiX3BsdWdpbiIsImNsYXNzTmFtZSIsImZ1bmN0aW9uTmFtZSIsImF0dHJOYW1lIiwiaHlwaGVuYXRlIiwicmVnaXN0ZXJQbHVnaW4iLCJwbHVnaW5OYW1lIiwidG9Mb3dlckNhc2UiLCJ1dWlkIiwiJGVsZW1lbnQiLCJkYXRhIiwidW5yZWdpc3RlclBsdWdpbiIsInNwbGljZSIsImluZGV4T2YiLCJyZW1vdmVBdHRyIiwicmVtb3ZlRGF0YSIsInByb3AiLCJyZUluaXQiLCJwbHVnaW5zIiwiaXNKUSIsImVhY2giLCJmbnMiLCJwbGdzIiwiZm9yRWFjaCIsInN0cmluZyIsImtleXMiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJyZWZsb3ciLCJmaW5kIiwiYWRkQmFjayIsIiRlbCIsIm9wdHMiLCJ3YXJuIiwidGhpbmciLCJlIiwib3B0IiwibWFwIiwiZWwiLCJwYXJzZVZhbHVlIiwiZXIiLCJnZXRGbk5hbWUiLCJhZGRUb0pxdWVyeSIsIiQkJDEiLCJtZXRob2QiLCIkbm9KUyIsInJlbW92ZUNsYXNzIiwiYXJncyIsInBsdWdDbGFzcyIsImZuIiwidXRpbCIsInRocm90dGxlIiwiZnVuYyIsImRlbGF5IiwidGltZXIiLCJjb250ZXh0IiwiRGF0ZSIsIm5vdyIsImdldFRpbWUiLCJ2ZW5kb3JzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidnAiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJsYXN0VGltZSIsIm5leHRUaW1lIiwibWF4IiwiY2xlYXJUaW1lb3V0IiwicGVyZm9ybWFuY2UiLCJzdGFydCIsIkZ1bmN0aW9uIiwib1RoaXMiLCJhQXJncyIsImZUb0JpbmQiLCJmTk9QIiwiZkJvdW5kIiwiZnVuY05hbWVSZWdleCIsInJlc3VsdHMiLCJleGVjIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwiQm94IiwiSW1Ob3RUb3VjaGluZ1lvdSIsIk92ZXJsYXBBcmVhIiwiR2V0RGltZW5zaW9ucyIsIkdldE9mZnNldHMiLCJHZXRFeHBsaWNpdE9mZnNldHMiLCJlbGVtZW50IiwicGFyZW50IiwibHJPbmx5IiwidGJPbmx5IiwiaWdub3JlQm90dG9tIiwiZWxlRGltcyIsInRvcE92ZXIiLCJib3R0b21PdmVyIiwibGVmdE92ZXIiLCJyaWdodE92ZXIiLCJwYXJEaW1zIiwiaGVpZ2h0Iiwib2Zmc2V0IiwidG9wIiwibGVmdCIsIndpbmRvd0RpbXMiLCJtaW4iLCJzcXJ0IiwiRXJyb3IiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicGFyUmVjdCIsIndpblJlY3QiLCJib2R5Iiwid2luWSIsInBhZ2VZT2Zmc2V0Iiwid2luWCIsInBhZ2VYT2Zmc2V0IiwicGFyZW50RGltcyIsImFuY2hvciIsInBvc2l0aW9uIiwidk9mZnNldCIsImhPZmZzZXQiLCJpc092ZXJmbG93IiwibG9nIiwiJGVsZURpbXMiLCIkYW5jaG9yRGltcyIsImFsaWdubWVudCIsInRvcFZhbCIsImxlZnRWYWwiLCJvbkltYWdlc0xvYWRlZCIsImltYWdlcyIsInVubG9hZGVkIiwiY29tcGxldGUiLCJuYXR1cmFsV2lkdGgiLCJzaW5nbGVJbWFnZUxvYWRlZCIsImltYWdlIiwiSW1hZ2UiLCJldmVudHMiLCJtZSIsImV2ZW50Iiwic3JjIiwia2V5Q29kZXMiLCJjb21tYW5kcyIsImZpbmRGb2N1c2FibGUiLCJmaWx0ZXIiLCJwYXJzZUtleSIsIndoaWNoIiwia2V5Q29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInRvVXBwZXJDYXNlIiwic2hpZnRLZXkiLCJjdHJsS2V5IiwiYWx0S2V5IiwiS2V5Ym9hcmQiLCJnZXRLZXlDb2RlcyIsImhhbmRsZUtleSIsImNvbXBvbmVudCIsImZ1bmN0aW9ucyIsImNvbW1hbmRMaXN0IiwiY21kcyIsImNvbW1hbmQiLCJsdHIiLCJleHRlbmQiLCJyZXR1cm5WYWx1ZSIsImhhbmRsZWQiLCJ1bmhhbmRsZWQiLCJyZWdpc3RlciIsImNvbXBvbmVudE5hbWUiLCJ0cmFwRm9jdXMiLCIkZm9jdXNhYmxlIiwiJGZpcnN0Rm9jdXNhYmxlIiwiZXEiLCIkbGFzdEZvY3VzYWJsZSIsInByZXZlbnREZWZhdWx0IiwiZm9jdXMiLCJyZWxlYXNlRm9jdXMiLCJrY3MiLCJrIiwia2MiLCJpbml0Q2xhc3NlcyIsImFjdGl2ZUNsYXNzZXMiLCJNb3Rpb24iLCJhbmltYXRlSW4iLCJhbmltYXRpb24iLCJhbmltYXRlIiwiYW5pbWF0ZU91dCIsIk1vdmUiLCJkdXJhdGlvbiIsImFuaW0iLCJwcm9nIiwibW92ZSIsInRzIiwiaXNJbiIsImluaXRDbGFzcyIsImFjdGl2ZUNsYXNzIiwicmVzZXQiLCJhZGRDbGFzcyIsInNob3ciLCJvZmZzZXRXaWR0aCIsImZpbmlzaCIsImhpZGUiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJOZXN0IiwiRmVhdGhlciIsIm1lbnUiLCJpdGVtcyIsInN1Yk1lbnVDbGFzcyIsInN1Ykl0ZW1DbGFzcyIsImhhc1N1YkNsYXNzIiwiYXBwbHlBcmlhIiwiJGl0ZW0iLCIkc3ViIiwiY2hpbGRyZW4iLCJCdXJuIiwiVGltZXIiLCJvcHRpb25zIiwibmFtZVNwYWNlIiwicmVtYWluIiwiaXNQYXVzZWQiLCJyZXN0YXJ0IiwiaW5maW5pdGUiLCJwYXVzZSIsIlRvdWNoIiwic3RhcnRQb3NYIiwic3RhcnRQb3NZIiwic3RhcnRUaW1lIiwiZWxhcHNlZFRpbWUiLCJzdGFydEV2ZW50IiwiaXNNb3ZpbmciLCJkaWRNb3ZlZCIsIm9uVG91Y2hFbmQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25Ub3VjaE1vdmUiLCJ0YXBFdmVudCIsIkV2ZW50Iiwic3BvdFN3aXBlIiwieCIsInRvdWNoZXMiLCJwYWdlWCIsInkiLCJwYWdlWSIsImR4IiwiZGlyIiwiYWJzIiwibW92ZVRocmVzaG9sZCIsInRpbWVUaHJlc2hvbGQiLCJvblRvdWNoU3RhcnQiLCJpbml0IiwiU3BvdFN3aXBlIiwiZW5hYmxlZCIsImRvY3VtZW50RWxlbWVudCIsInNwZWNpYWwiLCJzd2lwZSIsInNldHVwIiwidGFwIiwibm9vcCIsInNldHVwU3BvdFN3aXBlIiwic2V0dXBUb3VjaEhhbmRsZXIiLCJhZGRUb3VjaCIsImhhbmRsZVRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJmaXJzdCIsImV2ZW50VHlwZXMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJzaW11bGF0ZWRFdmVudCIsIk1vdXNlRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJNdXRhdGlvbk9ic2VydmVyIiwicHJlZml4ZXMiLCJ0cmlnZ2VycyIsIlRyaWdnZXJzIiwiTGlzdGVuZXJzIiwiQmFzaWMiLCJHbG9iYWwiLCJJbml0aWFsaXplcnMiLCJvcGVuTGlzdGVuZXIiLCJjbG9zZUxpc3RlbmVyIiwidG9nZ2xlTGlzdGVuZXIiLCJjbG9zZWFibGVMaXN0ZW5lciIsInN0b3BQcm9wYWdhdGlvbiIsImZhZGVPdXQiLCJ0b2dnbGVGb2N1c0xpc3RlbmVyIiwiYWRkT3Blbkxpc3RlbmVyIiwiYWRkQ2xvc2VMaXN0ZW5lciIsImFkZFRvZ2dsZUxpc3RlbmVyIiwiYWRkQ2xvc2VhYmxlTGlzdGVuZXIiLCJhZGRUb2dnbGVGb2N1c0xpc3RlbmVyIiwicmVzaXplTGlzdGVuZXIiLCIkbm9kZXMiLCJzY3JvbGxMaXN0ZW5lciIsImNsb3NlTWVMaXN0ZW5lciIsInBsdWdpbklkIiwibm90IiwiYWRkQ2xvc2VtZUxpc3RlbmVyIiwieWV0aUJveGVzIiwicGx1Z05hbWVzIiwibGlzdGVuZXJzIiwiam9pbiIsImRlYm91bmNlR2xvYmFsTGlzdGVuZXIiLCJkZWJvdW5jZSIsImxpc3RlbmVyIiwiYWRkUmVzaXplTGlzdGVuZXIiLCJhZGRTY3JvbGxMaXN0ZW5lciIsImFkZE11dGF0aW9uRXZlbnRzTGlzdGVuZXIiLCJsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uIiwibXV0YXRpb25SZWNvcmRzTGlzdCIsIiR0YXJnZXQiLCJhdHRyaWJ1dGVOYW1lIiwiY2xvc2VzdCIsImVsZW1lbnRPYnNlcnZlciIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsInN1YnRyZWUiLCJhdHRyaWJ1dGVGaWx0ZXIiLCJhZGRTaW1wbGVMaXN0ZW5lcnMiLCIkZG9jdW1lbnQiLCJhZGRHbG9iYWxMaXN0ZW5lcnMiLCJ0cmlnZ2Vyc0luaXRpYWxpemVkIiwiSUhlYXJZb3UiLCJQbHVnaW4iLCJfc2V0dXAiLCJnZXRQbHVnaW5OYW1lIiwiZGVzdHJveSIsIl9kZXN0cm95IiwiaHlwaGVuYXRlJDEiLCJBYmlkZSIsIl9QbHVnaW4iLCJkZWZhdWx0cyIsIl90aGlzMiIsIiRpbnB1dHMiLCJtZXJnZSIsIiRnbG9iYWxFcnJvcnMiLCJhMTF5QXR0cmlidXRlcyIsImlucHV0IiwiYWRkQTExeUF0dHJpYnV0ZXMiLCJhZGRHbG9iYWxFcnJvckExMXlBdHRyaWJ1dGVzIiwiX2V2ZW50cyIsIl90aGlzMyIsInJlc2V0Rm9ybSIsInZhbGlkYXRlRm9ybSIsInZhbGlkYXRlT24iLCJ2YWxpZGF0ZUlucHV0IiwibGl2ZVZhbGlkYXRlIiwidmFsaWRhdGVPbkJsdXIiLCJfcmVmbG93IiwicmVxdWlyZWRDaGVjayIsImlzR29vZCIsImNoZWNrZWQiLCJmaW5kRm9ybUVycm9yIiwiJGVycm9yIiwic2libGluZ3MiLCJmb3JtRXJyb3JTZWxlY3RvciIsImFkZCIsImZpbmRMYWJlbCIsIiRsYWJlbCIsImZpbmRSYWRpb0xhYmVscyIsIiRlbHMiLCJfdGhpczQiLCJsYWJlbHMiLCJhZGRFcnJvckNsYXNzZXMiLCIkZm9ybUVycm9yIiwibGFiZWxFcnJvckNsYXNzIiwiZm9ybUVycm9yQ2xhc3MiLCJpbnB1dEVycm9yQ2xhc3MiLCIkZXJyb3JzIiwiJGxhYmVscyIsImVycm9ySWQiLCJlbGVtSWQiLCJsYWJlbCIsImExMXlFcnJvckxldmVsIiwicmVtb3ZlUmFkaW9FcnJvckNsYXNzZXMiLCJncm91cE5hbWUiLCIkZm9ybUVycm9ycyIsInJlbW92ZUVycm9yQ2xhc3NlcyIsImNsZWFyUmVxdWlyZSIsInZhbGlkYXRlZCIsImN1c3RvbVZhbGlkYXRvciIsInZhbGlkYXRvciIsImVxdWFsVG8iLCJ2YWxpZGF0ZVJhZGlvIiwidmFsaWRhdGVUZXh0IiwibWF0Y2hWYWxpZGF0aW9uIiwidmFsaWRhdG9ycyIsImdvb2RUb0dvIiwibWVzc2FnZSIsImRlcGVuZGVudEVsZW1lbnRzIiwiX3RoaXM1IiwiYWNjIiwibm9FcnJvciIsInBhdHRlcm4iLCJpbnB1dFRleHQiLCJ2YWxpZCIsInBhdHRlcm5zIiwiUmVnRXhwIiwiJGdyb3VwIiwicmVxdWlyZWQiLCJfdGhpczYiLCJjbGVhciIsInYiLCIkZm9ybSIsImFscGhhIiwiYWxwaGFfbnVtZXJpYyIsImludGVnZXIiLCJudW1iZXIiLCJjYXJkIiwiY3Z2IiwiZW1haWwiLCJ1cmwiLCJkb21haW4iLCJkYXRldGltZSIsImRhdGUiLCJ0aW1lIiwiZGF0ZUlTTyIsIm1vbnRoX2RheV95ZWFyIiwiZGF5X21vbnRoX3llYXIiLCJjb2xvciIsIndlYnNpdGUiLCJBY2NvcmRpb24iLCJfaXNJbml0aWFsaXppbmciLCIkdGFicyIsImlkeCIsIiRjb250ZW50IiwibGlua0lkIiwiJGluaXRBY3RpdmUiLCJfaW5pdGlhbEFuY2hvciIsInByZXYiLCJfb3BlblNpbmdsZVRhYiIsIl9jaGVja0RlZXBMaW5rIiwibG9jYXRpb24iLCJoYXNoIiwiJGFuY2hvciIsIiRsaW5rIiwiaXNPd25BbmNob3IiLCJoYXNDbGFzcyIsIl9jbG9zZUFsbFRhYnMiLCJkZWVwTGlua1NtdWRnZSIsInNjcm9sbFRvcCIsImRlZXBMaW5rU211ZGdlRGVsYXkiLCJkZWVwTGluayIsIiR0YWJDb250ZW50IiwibmV4dCIsIiRhIiwibXVsdGlFeHBhbmQiLCJwcmV2aW91cyIsInVwIiwiZG93biIsInVwZGF0ZUhpc3RvcnkiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwicmVwbGFjZVN0YXRlIiwiX29wZW5UYWIiLCIkdGFyZ2V0SXRlbSIsIiRvdGhlcnNJdGVtcyIsImFsbG93QWxsQ2xvc2VkIiwiX2Nsb3NlVGFiIiwiJGFjdGl2ZUNvbnRlbnRzIiwidGFyZ2V0Q29udGVudElkIiwic2xpZGVEb3duIiwic2xpZGVTcGVlZCIsInNsaWRlVXAiLCIkYWN0aXZlVGFicyIsInN0b3AiLCJBY2NvcmRpb25NZW51IiwibXVsdGlPcGVuIiwiJG1lbnVMaW5rcyIsInN1YklkIiwiaXNBY3RpdmUiLCJwYXJlbnRMaW5rIiwiY2xvbmUiLCJwcmVwZW5kVG8iLCJ3cmFwIiwic3VibWVudVRvZ2dsZSIsImFmdGVyIiwic3VibWVudVRvZ2dsZVRleHQiLCJpbml0UGFuZXMiLCIkc3VibWVudSIsIiRlbGVtZW50cyIsIiRwcmV2RWxlbWVudCIsIiRuZXh0RWxlbWVudCIsInBhcmVudHMiLCJvcGVuIiwiY2xvc2UiLCJjbG9zZUFsbCIsImhpZGVBbGwiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJzaG93QWxsIiwicGFyZW50c1VudGlsIiwiJHN1Ym1lbnVzIiwiJGFsbG1lbnVzIiwiZGV0YWNoIiwicmVtb3ZlIiwiRHJpbGxkb3duIiwiYXV0b0FwcGx5Q2xhc3MiLCIkc3VibWVudUFuY2hvcnMiLCIkbWVudUl0ZW1zIiwiJGN1cnJlbnRNZW51IiwiX3ByZXBhcmVNZW51IiwiX3JlZ2lzdGVyRXZlbnRzIiwiX2tleWJvYXJkRXZlbnRzIiwiJG1lbnUiLCIkYmFjayIsImJhY2tCdXR0b25Qb3NpdGlvbiIsImFwcGVuZCIsImJhY2tCdXR0b24iLCJwcmVwZW5kIiwiX2JhY2siLCJhdXRvSGVpZ2h0IiwiJHdyYXBwZXIiLCJ3cmFwcGVyIiwiYW5pbWF0ZUhlaWdodCIsIl9nZXRNYXhEaW1zIiwiX3Jlc2l6ZSIsIl9zaG93IiwiY2xvc2VPbkNsaWNrIiwiJGJvZHkiLCJjb250YWlucyIsIl9oaWRlQWxsIiwiX2JpbmRIYW5kbGVyIiwiX3Njcm9sbFRvcCIsIiRzY3JvbGxUb3BFbGVtZW50Iiwic2Nyb2xsVG9wRWxlbWVudCIsInNjcm9sbFBvcyIsInBhcnNlSW50Iiwic2Nyb2xsVG9wT2Zmc2V0IiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25FYXNpbmciLCJfaGlkZSIsInBhcmVudFN1Yk1lbnUiLCJfbWVudUxpbmtFdmVudHMiLCJfc2V0U2hvd1N1Yk1lbnVDbGFzc2VzIiwiX3NldEhpZGVTdWJNZW51Q2xhc3NlcyIsIl9zaG93TWVudSIsImF1dG9Gb2N1cyIsIiRleHBhbmRlZFN1Ym1lbnVzIiwiaW5kZXgiLCJpc0xhc3RDaGlsZCIsImJsdXIiLCJtYXhIZWlnaHQiLCJyZXN1bHQiLCJudW1PZkVsZW1zIiwidW53cmFwIiwiUE9TSVRJT05TIiwiVkVSVElDQUxfQUxJR05NRU5UUyIsIkhPUklaT05UQUxfQUxJR05NRU5UUyIsIkFMSUdOTUVOVFMiLCJuZXh0SXRlbSIsIml0ZW0iLCJhcnJheSIsImN1cnJlbnRJZHgiLCJQb3NpdGlvbmFibGUiLCJ0cmllZFBvc2l0aW9ucyIsIl9nZXREZWZhdWx0UG9zaXRpb24iLCJfZ2V0RGVmYXVsdEFsaWdubWVudCIsIm9yaWdpbmFsUG9zaXRpb24iLCJvcmlnaW5hbEFsaWdubWVudCIsIl9yZXBvc2l0aW9uIiwiX2FsaWdubWVudHNFeGhhdXN0ZWQiLCJfcmVhbGlnbiIsIl9hZGRUcmllZFBvc2l0aW9uIiwiX3Bvc2l0aW9uc0V4aGF1c3RlZCIsImlzRXhoYXVzdGVkIiwiX2dldFZPZmZzZXQiLCJfZ2V0SE9mZnNldCIsIl9zZXRQb3NpdGlvbiIsIiRwYXJlbnQiLCJhbGxvd092ZXJsYXAiLCJtaW5PdmVybGFwIiwibWluQ29vcmRpbmF0ZXMiLCJvdmVybGFwIiwiYWxsb3dCb3R0b21PdmVybGFwIiwiRHJvcGRvd24iLCJfUG9zaXRpb25hYmxlIiwiJGlkIiwiJGFuY2hvcnMiLCJfc2V0Q3VycmVudEFuY2hvciIsInBhcmVudENsYXNzIiwiJGN1cnJlbnRBbmNob3IiLCJtYXRjaCIsImhvcml6b250YWxQb3NpdGlvbiIsImhvdmVyIiwiYm9keURhdGEiLCJ3aGF0aW5wdXQiLCJ0aW1lb3V0IiwiaG92ZXJEZWxheSIsImhvdmVyUGFuZSIsInZpc2libGVGb2N1c2FibGVFbGVtZW50cyIsIl9hZGRCb2R5SGFuZGxlciIsIkRyb3Bkb3duTWVudSIsInN1YnMiLCJ2ZXJ0aWNhbENsYXNzIiwicmlnaHRDbGFzcyIsImNoYW5nZWQiLCJfaXNWZXJ0aWNhbCIsIl9pc1J0bCIsImhhc1RvdWNoIiwib250b3VjaHN0YXJ0IiwicGFyQ2xhc3MiLCJoYW5kbGVDbGlja0ZuIiwiaGFzU3ViIiwiaGFzQ2xpY2tlZCIsImNsaWNrT3BlbiIsImZvcmNlRm9sbG93IiwiY2xvc2VPbkNsaWNrSW5zaWRlIiwiZGlzYWJsZUhvdmVyIiwiYXV0b2Nsb3NlIiwiY2xvc2luZ1RpbWUiLCJpc1RhYiIsIm5leHRTaWJsaW5nIiwicHJldlNpYmxpbmciLCJvcGVuU3ViIiwiY2xvc2VTdWIiLCIkc2licyIsIm9sZENsYXNzIiwiJHBhcmVudExpIiwiJHRvQ2xvc2UiLCJzb21ldGhpbmdUb0Nsb3NlIiwiRXF1YWxpemVyIiwiZXFJZCIsIiR3YXRjaGVkIiwiaGFzTmVzdGVkIiwiaXNOZXN0ZWQiLCJpc09uIiwib25SZXNpemVNZUJvdW5kIiwiX29uUmVzaXplTWUiLCJvblBvc3RFcXVhbGl6ZWRCb3VuZCIsIl9vblBvc3RFcXVhbGl6ZWQiLCJpbWdzIiwidG9vU21hbGwiLCJlcXVhbGl6ZU9uIiwiX2NoZWNrTVEiLCJfcGF1c2VFdmVudHMiLCJfa2lsbHN3aXRjaCIsImVxdWFsaXplT25TdGFjayIsIl9pc1N0YWNrZWQiLCJlcXVhbGl6ZUJ5Um93IiwiZ2V0SGVpZ2h0c0J5Um93IiwiYXBwbHlIZWlnaHRCeVJvdyIsImdldEhlaWdodHMiLCJhcHBseUhlaWdodCIsImhlaWdodHMiLCJsZW4iLCJvZmZzZXRIZWlnaHQiLCJsYXN0RWxUb3BPZmZzZXQiLCJncm91cHMiLCJncm91cCIsImVsT2Zmc2V0VG9wIiwiaiIsImxuIiwiZ3JvdXBzSUxlbmd0aCIsImxlbkoiLCJJbnRlcmNoYW5nZSIsInJ1bGVzIiwiY3VycmVudFBhdGgiLCJfYWRkQnJlYWtwb2ludHMiLCJfZ2VuZXJhdGVSdWxlcyIsInJ1bGUiLCJwYXRoIiwiU1BFQ0lBTF9RVUVSSUVTIiwicnVsZXNMaXN0Iiwibm9kZU5hbWUiLCJyZXNwb25zZSIsImh0bWwiLCJTbW9vdGhTY3JvbGwiLCJfaGFuZGxlTGlua0NsaWNrIiwiYXJyaXZhbCIsImdldEF0dHJpYnV0ZSIsIl9pblRyYW5zaXRpb24iLCJzY3JvbGxUb0xvYyIsImxvYyIsIiRsb2MiLCJ0aHJlc2hvbGQiLCJNYWdlbGxhbiIsImNhbGNQb2ludHMiLCIkdGFyZ2V0cyIsIiRsaW5rcyIsIiRhY3RpdmUiLCJwb2ludHMiLCJ3aW5IZWlnaHQiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImRvY0hlaWdodCIsInNjcm9sbEhlaWdodCIsIiR0YXIiLCJwdCIsInRhcmdldFBvaW50IiwiZWFzaW5nIiwiZGVlcExpbmtpbmciLCJfdXBkYXRlQWN0aXZlIiwib25Mb2FkTGlzdGVuZXIiLCJfZGVlcExpbmtTY3JvbGwiLCJuZXdTY3JvbGxQb3MiLCJpc1Njcm9sbGluZ1VwIiwiYWN0aXZlSWR4IiwidmlzaWJsZUxpbmtzIiwiJG9sZEFjdGl2ZSIsImFjdGl2ZUhhc2giLCJpc05ld0FjdGl2ZSIsImlzTmV3SGFzaCIsInBhdGhuYW1lIiwic2VhcmNoIiwiT2ZmQ2FudmFzIiwiY29udGVudENsYXNzZXMiLCJyZXZlYWwiLCIkbGFzdFRyaWdnZXIiLCIkdHJpZ2dlcnMiLCJuZXN0ZWQiLCJjb250ZW50SWQiLCJ0cmFuc2l0aW9uIiwiY29udGVudE92ZXJsYXkiLCJvdmVybGF5Iiwib3ZlcmxheVBvc2l0aW9uIiwic2V0QXR0cmlidXRlIiwiJG92ZXJsYXkiLCJpbnNlcnRBZnRlciIsInJldmVhbE9uUmVnRXhwIiwicmV2ZWFsQ2xhc3MiLCJyZXZlYWxPbkNsYXNzIiwiaXNSZXZlYWxlZCIsInJldmVhbE9uIiwiX3NldE1RQ2hlY2tlciIsInRyYW5zaXRpb25UaW1lIiwiX3JlbW92ZUNvbnRlbnRDbGFzc2VzIiwiX2hhbmRsZUtleWJvYXJkIiwiaGFzUmV2ZWFsIiwiX2FkZENvbnRlbnRDbGFzc2VzIiwiX3N0b3BTY3JvbGxpbmciLCJfcmVjb3JkU2Nyb2xsYWJsZSIsImFsbG93VXAiLCJhbGxvd0Rvd24iLCJsYXN0WSIsIm9yaWdpbmFsRXZlbnQiLCJfc3RvcFNjcm9sbFByb3BhZ2F0aW9uIiwiZm9yY2VUbyIsInNjcm9sbFRvIiwiY29udGVudFNjcm9sbCIsImNhbnZhc0ZvY3VzIiwiT3JiaXQiLCJfcmVzZXQiLCJjb250YWluZXJDbGFzcyIsIiRzbGlkZXMiLCJzbGlkZUNsYXNzIiwiJGltYWdlcyIsImluaXRBY3RpdmUiLCJ1c2VNVUkiLCJfcHJlcGFyZUZvck9yYml0IiwiYnVsbGV0cyIsIl9sb2FkQnVsbGV0cyIsImF1dG9QbGF5IiwiZ2VvU3luYyIsImFjY2Vzc2libGUiLCIkYnVsbGV0cyIsImJveE9mQnVsbGV0cyIsInRpbWVyRGVsYXkiLCJjaGFuZ2VTbGlkZSIsIl9zZXRXcmFwcGVySGVpZ2h0IiwidGVtcCIsImNvdW50ZXIiLCJfc2V0U2xpZGVIZWlnaHQiLCJwYXVzZU9uSG92ZXIiLCJuYXZCdXR0b25zIiwiJGNvbnRyb2xzIiwibmV4dENsYXNzIiwicHJldkNsYXNzIiwiJHNsaWRlIiwiX3VwZGF0ZUJ1bGxldHMiLCJpc0xUUiIsImNob3NlblNsaWRlIiwiJGN1clNsaWRlIiwiJGZpcnN0U2xpZGUiLCIkbGFzdFNsaWRlIiwibGFzdCIsImRpckluIiwiZGlyT3V0IiwiJG5ld1NsaWRlIiwiaW5maW5pdGVXcmFwIiwiJG9sZEJ1bGxldCIsInNwYW4iLCIkbmV3QnVsbGV0IiwiYW5pbUluRnJvbVJpZ2h0IiwiYW5pbU91dFRvUmlnaHQiLCJhbmltSW5Gcm9tTGVmdCIsImFuaW1PdXRUb0xlZnQiLCJNZW51UGx1Z2lucyIsImRyb3Bkb3duIiwiY3NzQ2xhc3MiLCJkcmlsbGRvd24iLCJhY2NvcmRpb24iLCJSZXNwb25zaXZlTWVudSIsImN1cnJlbnRNcSIsImN1cnJlbnRQbHVnaW4iLCJydWxlc1RyZWUiLCJydWxlU2l6ZSIsInJ1bGVQbHVnaW4iLCJpc0VtcHR5T2JqZWN0IiwiX2NoZWNrTWVkaWFRdWVyaWVzIiwibWF0Y2hlZE1xIiwiUmVzcG9uc2l2ZVRvZ2dsZSIsInRhcmdldElEIiwiJHRhcmdldE1lbnUiLCIkdG9nZ2xlciIsImFuaW1hdGlvbkluIiwiYW5pbWF0aW9uT3V0IiwiX3VwZGF0ZSIsIl91cGRhdGVNcUhhbmRsZXIiLCJ0b2dnbGVNZW51IiwiaGlkZUZvciIsIlJldmVhbCIsImNhY2hlZCIsIm1xIiwiZnVsbFNjcmVlbiIsIl9tYWtlT3ZlcmxheSIsImFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlcyIsIl91cGRhdGVQb3NpdGlvbiIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIm1hcmdpbiIsImNsb3NlWmZUcmlnZ2VyIiwicmVzaXplbWVaZlRyaWdnZXIiLCJfaGFuZGxlU3RhdGUiLCJfZGlzYWJsZVNjcm9sbCIsIl9lbmFibGVTY3JvbGwiLCIkYWN0aXZlQW5jaG9yIiwiYWN0aXZlRWxlbWVudCIsIm11bHRpcGxlT3BlbmVkIiwiYWZ0ZXJBbmltYXRpb24iLCJfYWRkR2xvYmFsQ2xhc3NlcyIsImZvY3VzYWJsZUVsZW1lbnRzIiwic2hvd0RlbGF5IiwiX2FkZEdsb2JhbExpc3RlbmVycyIsInVwZGF0ZVNjcm9sbGJhckNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJfcmVtb3ZlR2xvYmFsQ2xhc3NlcyIsImNsb3NlT25Fc2MiLCJmaW5pc2hVcCIsImhpZGVEZWxheSIsInJlc2V0T25DbG9zZSIsInVybFdpdGhvdXRIYXNoIiwidGl0bGUiLCJTbGlkZXIiLCJpbnB1dHMiLCJoYW5kbGVzIiwiJGhhbmRsZSIsIiRpbnB1dCIsIiRmaWxsIiwidmVydGljYWwiLCJkaXNhYmxlZCIsImRpc2FibGVkQ2xhc3MiLCJiaW5kaW5nIiwiX3NldEluaXRBdHRyIiwiZG91YmxlU2lkZWQiLCIkaGFuZGxlMiIsIiRpbnB1dDIiLCJzZXRIYW5kbGVzIiwiX3NldEhhbmRsZVBvcyIsIl9wY3RPZkJhciIsInBjdE9mQmFyIiwicGVyY2VudCIsInBvc2l0aW9uVmFsdWVGdW5jdGlvbiIsIl9sb2dUcmFuc2Zvcm0iLCJfcG93VHJhbnNmb3JtIiwidG9GaXhlZCIsIl92YWx1ZSIsImJhc2VMb2ciLCJub25MaW5lYXJCYXNlIiwiJGhuZGwiLCJub0ludmVydCIsImlzRGJsIiwiaDJWYWwiLCJzdGVwIiwiaDFWYWwiLCJ2ZXJ0IiwiaE9yVyIsImxPclQiLCJoYW5kbGVEaW0iLCJlbGVtRGltIiwicHhUb01vdmUiLCJtb3ZlbWVudCIsImRlY2ltYWwiLCJfc2V0VmFsdWVzIiwiaXNMZWZ0SG5kbCIsImRpbSIsImhhbmRsZVBjdCIsImhhbmRsZVBvcyIsImluaXRpYWxTdGFydCIsIm1vdmVUaW1lIiwiY2hhbmdlZERlbGF5IiwiaW5pdFZhbCIsImluaXRpYWxFbmQiLCJfaGFuZGxlRXZlbnQiLCJoYXNWYWwiLCJkaXJlY3Rpb24iLCJldmVudE9mZnNldCIsImhhbGZPZkhhbmRsZSIsImJhckRpbSIsIndpbmRvd1Njcm9sbCIsInNjcm9sbExlZnQiLCJlbGVtT2Zmc2V0IiwiZXZlbnRGcm9tQmFyIiwiYmFyWFkiLCJvZmZzZXRQY3QiLCJfYWRqdXN0VmFsdWUiLCJmaXJzdEhuZGxQb3MiLCJhYnNQb3NpdGlvbiIsInNlY25kSG5kbFBvcyIsImRpdiIsInByZXZfdmFsIiwibmV4dF92YWwiLCJfZXZlbnRzRm9ySGFuZGxlIiwiY3VySGFuZGxlIiwiaGFuZGxlQ2hhbmdlRXZlbnQiLCJjbGlja1NlbGVjdCIsImRyYWdnYWJsZSIsIl8kaGFuZGxlIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsImRlY3JlYXNlIiwiaW5jcmVhc2UiLCJkZWNyZWFzZV9mYXN0IiwiaW5jcmVhc2VfZmFzdCIsImludmVydFZlcnRpY2FsIiwiZnJhYyIsIm51bSIsImNsaWNrUG9zIiwiU3RpY2t5IiwiJGNvbnRhaW5lciIsIndhc1dyYXBwZWQiLCJjb250YWluZXIiLCJzdGlja3lDbGFzcyIsInNjcm9sbENvdW50IiwiY2hlY2tFdmVyeSIsImlzU3R1Y2siLCJjb250YWluZXJIZWlnaHQiLCJlbGVtSGVpZ2h0IiwiX3BhcnNlUG9pbnRzIiwiX3NldFNpemVzIiwic2Nyb2xsIiwiX2NhbGMiLCJfcmVtb3ZlU3RpY2t5IiwidG9wUG9pbnQiLCJyZXZlcnNlIiwidG9wQW5jaG9yIiwiYnRtIiwiYnRtQW5jaG9yIiwicHRzIiwiYnJlYWtzIiwicGxhY2UiLCJjYW5TdGljayIsIl9ldmVudHNIYW5kbGVyIiwiX3BhdXNlTGlzdGVuZXJzIiwiY2hlY2tTaXplcyIsImJvdHRvbVBvaW50IiwiX3NldFN0aWNreSIsInN0aWNrVG8iLCJtcmduIiwibm90U3R1Y2tUbyIsImlzVG9wIiwic3RpY2tUb1RvcCIsImFuY2hvclB0IiwiYW5jaG9ySGVpZ2h0IiwidG9wT3JCb3R0b20iLCJzdGlja3lPbiIsIm5ld0VsZW1XaWR0aCIsImNvbXAiLCJwZG5nbCIsInBkbmdyIiwibmV3Q29udGFpbmVySGVpZ2h0IiwiX3NldEJyZWFrUG9pbnRzIiwibVRvcCIsImVtQ2FsYyIsIm1hcmdpblRvcCIsIm1CdG0iLCJtYXJnaW5Cb3R0b20iLCJib3R0b20iLCJlbSIsImZvbnRTaXplIiwiVGFicyIsIiR0YWJUaXRsZXMiLCJsaW5rQ2xhc3MiLCJsaW5rQWN0aXZlQ2xhc3MiLCJtYXRjaEhlaWdodCIsIl9zZXRIZWlnaHQiLCJzZWxlY3RUYWIiLCJfY29sbGFwc2UiLCJfYWRkS2V5SGFuZGxlciIsIl9hZGRDbGlja0hhbmRsZXIiLCJfc2V0SGVpZ2h0TXFIYW5kbGVyIiwiX2hhbmRsZVRhYkNoYW5nZSIsIndyYXBPbktleXMiLCJoaXN0b3J5SGFuZGxlZCIsImFjdGl2ZUNvbGxhcHNlIiwiJG9sZFRhYiIsIiR0YWJMaW5rIiwiJHRhcmdldENvbnRlbnQiLCJfY29sbGFwc2VUYWIiLCJwYW5lbEFjdGl2ZUNsYXNzIiwiJHRhcmdldF9hbmNob3IiLCIkYWN0aXZlVGFiIiwiaWRTdHIiLCJwYW5lbENsYXNzIiwicGFuZWwiLCJUb2dnbGVyIiwiJHRyaWdnZXIiLCJjb250cm9scyIsImNvbnRhaW5zSWQiLCJfdG9nZ2xlQ2xhc3MiLCJfdXBkYXRlQVJJQSIsIl90b2dnbGVBbmltYXRlIiwiVG9vbHRpcCIsImlzQ2xpY2siLCJ0aXBUZXh0IiwidGVtcGxhdGUiLCJfYnVpbGRUZW1wbGF0ZSIsImFsbG93SHRtbCIsInRyaWdnZXJDbGFzcyIsInRvb2x0aXBXaWR0aCIsInRvb2x0aXBIZWlnaHQiLCJ0ZW1wbGF0ZUNsYXNzZXMiLCJ0b29sdGlwQ2xhc3MiLCIkdGVtcGxhdGUiLCJzaG93T24iLCJmYWRlSW4iLCJmYWRlSW5EdXJhdGlvbiIsImZhZGVPdXREdXJhdGlvbiIsImlzRm9jdXMiLCJkaXNhYmxlRm9yVG91Y2giLCJ0b3VjaENsb3NlVGV4dCIsIk1lbnVQbHVnaW5zJDEiLCJ0YWJzIiwiUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMiLCJfZ2V0QWxsT3B0aW9ucyIsImFsbE9wdGlvbnMiLCJkdW1teVBsdWdpbiIsInRtcFBsdWdpbiIsImtleUtleSIsIm9iak9iaiIsIl9jaGFuZ2VkWmZNZWRpYVF1ZXJ5SGFuZGxlciIsInN0b3JlemZEYXRhIiwiX2hhbmRsZU1hcmt1cCIsInRvU2V0IiwiZnJvbVN0cmluZyIsIiRwYW5lbHMiLCJ0YWJzVGl0bGUiLCJ0YWJzUGFuZWwiLCIkbGlIZWFkcyIsIiRsaUhlYWRzQSIsImRpc3BsYXkiLCJ2aXNpYmlsaXR5IiwiJHRhYnNDb250ZW50IiwiJHBsYWNlaG9sZGVyIiwidGVtcFZhbHVlIiwiQ29yZVV0aWxzIiwiQ29yZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsQ0FBQztBQUNELEM7Ozs7OztBQzNYQSxpQkFBaUIsbUJBQU8sQ0FBQyxDQUFvQjtBQUM3QyxzQkFBc0IsbUJBQU8sQ0FBQyxFQUEwQjtBQUN4RCx3QkFBd0IsbUJBQU8sQ0FBQyxFQUE0Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7Ozs7Ozs7QUNaQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFrQztBQUNYO0FBQ1M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFNO0FBQ2pCLFdBQVcsOENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUFNO0FBQ04sOENBQU07QUFDTiw4Q0FBTTtBQUNOLGtEQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw4Q0FBTTtBQUNkLGVBQWUsOENBQU07QUFDckIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDRDQUFHO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHFDQUFxQztBQUNyQyx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQU07QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsdUVBQXVFLGdCQUFnQjtBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCLG9CQUFvQiwwQkFBMEI7QUFDbEg7QUFDQSxhQUFhOztBQUViO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9ELGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGdCQUFnQjtBQUM5RCwwQkFBMEIsTUFBTSxLQUFLLE9BQU87QUFDNUMsMkJBQTJCLE1BQU0sTUFBTSxPQUFPO0FBQzlDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CLDBCQUEwQixTQUFTO0FBQ25DLHVEQUF1RCxVQUFVO0FBQ2pFLHNCQUFzQixXQUFXO0FBQ2pDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsVUFBVTtBQUMxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZSxxRUFBTSxFQUFDOzs7Ozs7OztBQ3R2QnRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQkEsYUFBYSxtQkFBTyxDQUFDLENBQVE7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNsQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXVDO0FBQ1g7O0FBRWIsa0NBQWtDLDhDQUFNO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QiwrQkFBK0IsR0FBRztBQUNsQywyQkFBMkIsRUFBRTtBQUM3Qiw4QkFBOEIsR0FBRztBQUNqQyxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsb0RBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSTtBQUM1RDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pPQSxpQkFBaUIsbUJBQU8sQ0FBQyxFQUF3Qjs7Ozs7Ozs7QUNBakQ7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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R0FBQUEsTTtRQUFRSyxJLEdBQUFBLEk7UUFBTWdCLEksR0FBQUEsSTtRQUFNWSxLLEdBQUFBLEs7UUFBT1EsSyxHQUFBQSxLO1FBQU93RCxRLEdBQUFBLFE7UUFBVXlELEssR0FBQUEsSztRQUFPNEYsUyxHQUFBQSxTO1FBQVc2QyxhLEdBQUFBLGE7UUFBZTZCLFMsR0FBQUEsUztRQUFXK0UsUSxHQUFBQSxRO1FBQVVpQixZLEdBQUFBLFk7UUFBYzZCLFMsR0FBQUEsUztRQUFXa0MsVyxHQUFBQSxXO1FBQWFxQixRLEdBQUFBLFE7UUFBVTZCLFMsR0FBQUEsUztRQUFXb0MsSyxHQUFBQSxLO1FBQU9tRCxjLEdBQUFBLGM7UUFBZ0JTLGdCLEdBQUFBLGdCO1FBQWtCVSxNLEdBQUFBLE07UUFBUWdDLE0sR0FBQUEsTTtRQUFRaEwsWSxHQUFBQSxZO1FBQWNxUSxNLEdBQUFBLE07UUFBUW9ELEksR0FBQUEsSTtRQUFNeUIsTyxHQUFBQSxPO1FBQVNPLE8sR0FBQUEsTztRQUFTcUIsdUIsR0FBQUEsdUI7UUFBeUJyaEMsVSxHQUFBQSxVO0FBQ3pZLDBDIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDM0NDYzNjQxNzBjZTQ2YWU0MWUxIiwidmFyIHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICB3aW4gPSBzZWxmO1xufSBlbHNlIHtcbiAgICB3aW4gPSB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0galF1ZXJ5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwialF1ZXJ5XCJcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgd2hhdElucHV0IGZyb20gJ3doYXQtaW5wdXQnO1xuaW1wb3J0IHtcbiAgamFyYWxsYXgsXG4gIGphcmFsbGF4RWxlbWVudCxcbiAgamFyYWxsYXhWaWRlb1xufSBmcm9tICdqYXJhbGxheCc7XG5cbndpbmRvdy4kID0gJDtcblxuaW1wb3J0IEZvdW5kYXRpb24gZnJvbSAnZm91bmRhdGlvbi1zaXRlcyc7XG4vLyBJZiB5b3Ugd2FudCB0byBwaWNrIGFuZCBjaG9vc2Ugd2hpY2ggbW9kdWxlcyB0byBpbmNsdWRlLCBjb21tZW50IG91dCB0aGUgYWJvdmUgYW5kIHVuY29tbWVudFxuLy8gdGhlIGxpbmUgYmVsb3dcbi8vaW1wb3J0ICcuL2xpYi9mb3VuZGF0aW9uLWV4cGxpY2l0LXBpZWNlcyc7XG5cblxuXG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgLy8gSGFuZGxlciB3aGVuIHRoZSBET00gaXMgZnVsbHkgbG9hZGVkXG4gICQoZG9jdW1lbnQpLmZvdW5kYXRpb24oKTtcbiAgamFyYWxsYXhFbGVtZW50KCk7XG5cbiAgamFyYWxsYXgoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmphcmFsbGF4JyksIHtcbiAgICBzcGVlZDogMC41XG4gIH0pO1xuXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoYW1idXJnZXItLWpzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QudG9nZ2xlKFwiaXMtYWN0aXZlXCIpO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZW51LW1haW4tbWVudS1jb250YWluZXInKS5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTtcbiAgfSk7XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXNzZXRzL2pzL2FwcC5qcyIsIi8qKlxuICogd2hhdC1pbnB1dCAtIEEgZ2xvYmFsIHV0aWxpdHkgZm9yIHRyYWNraW5nIHRoZSBjdXJyZW50IGlucHV0IG1ldGhvZCAobW91c2UsIGtleWJvYXJkIG9yIHRvdWNoKS5cbiAqIEB2ZXJzaW9uIHY0LjMuMVxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3RlbjFzZXZlbi93aGF0LWlucHV0XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJ3aGF0SW5wdXRcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wid2hhdElucHV0XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIndoYXRJbnB1dFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgLypcblx0ICAgKiB2YXJpYWJsZXNcblx0ICAgKi9cblxuXHQgIC8vIGxhc3QgdXNlZCBpbnB1dCB0eXBlXG5cdCAgdmFyIGN1cnJlbnRJbnB1dCA9ICdpbml0aWFsJztcblxuXHQgIC8vIGxhc3QgdXNlZCBpbnB1dCBpbnRlbnRcblx0ICB2YXIgY3VycmVudEludGVudCA9IG51bGw7XG5cblx0ICAvLyBjYWNoZSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcblx0ICB2YXIgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdCAgLy8gZm9ybSBpbnB1dCB0eXBlc1xuXHQgIHZhciBmb3JtSW5wdXRzID0gWydpbnB1dCcsICdzZWxlY3QnLCAndGV4dGFyZWEnXTtcblxuXHQgIHZhciBmdW5jdGlvbkxpc3QgPSBbXTtcblxuXHQgIC8vIGxpc3Qgb2YgbW9kaWZpZXIga2V5cyBjb21tb25seSB1c2VkIHdpdGggdGhlIG1vdXNlIGFuZFxuXHQgIC8vIGNhbiBiZSBzYWZlbHkgaWdub3JlZCB0byBwcmV2ZW50IGZhbHNlIGtleWJvYXJkIGRldGVjdGlvblxuXHQgIHZhciBpZ25vcmVNYXAgPSBbMTYsIC8vIHNoaWZ0XG5cdCAgMTcsIC8vIGNvbnRyb2xcblx0ICAxOCwgLy8gYWx0XG5cdCAgOTEsIC8vIFdpbmRvd3Mga2V5IC8gbGVmdCBBcHBsZSBjbWRcblx0ICA5MyAvLyBXaW5kb3dzIG1lbnUgLyByaWdodCBBcHBsZSBjbWRcblx0ICBdO1xuXG5cdCAgLy8gbGlzdCBvZiBrZXlzIGZvciB3aGljaCB3ZSBjaGFuZ2UgaW50ZW50IGV2ZW4gZm9yIGZvcm0gaW5wdXRzXG5cdCAgdmFyIGNoYW5nZUludGVudE1hcCA9IFs5IC8vIHRhYlxuXHQgIF07XG5cblx0ICAvLyBtYXBwaW5nIG9mIGV2ZW50cyB0byBpbnB1dCB0eXBlc1xuXHQgIHZhciBpbnB1dE1hcCA9IHtcblx0ICAgIGtleWRvd246ICdrZXlib2FyZCcsXG5cdCAgICBrZXl1cDogJ2tleWJvYXJkJyxcblx0ICAgIG1vdXNlZG93bjogJ21vdXNlJyxcblx0ICAgIG1vdXNlbW92ZTogJ21vdXNlJyxcblx0ICAgIE1TUG9pbnRlckRvd246ICdwb2ludGVyJyxcblx0ICAgIE1TUG9pbnRlck1vdmU6ICdwb2ludGVyJyxcblx0ICAgIHBvaW50ZXJkb3duOiAncG9pbnRlcicsXG5cdCAgICBwb2ludGVybW92ZTogJ3BvaW50ZXInLFxuXHQgICAgdG91Y2hzdGFydDogJ3RvdWNoJ1xuXHQgIH07XG5cblx0ICAvLyBhcnJheSBvZiBhbGwgdXNlZCBpbnB1dCB0eXBlc1xuXHQgIHZhciBpbnB1dFR5cGVzID0gW107XG5cblx0ICAvLyBib29sZWFuOiB0cnVlIGlmIHRvdWNoIGJ1ZmZlciBpcyBhY3RpdmVcblx0ICB2YXIgaXNCdWZmZXJpbmcgPSBmYWxzZTtcblxuXHQgIC8vIGJvb2xlYW46IHRydWUgaWYgdGhlIHBhZ2UgaXMgYmVpbmcgc2Nyb2xsZWRcblx0ICB2YXIgaXNTY3JvbGxpbmcgPSBmYWxzZTtcblxuXHQgIC8vIHN0b3JlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cblx0ICB2YXIgbW91c2VQb3MgPSB7XG5cdCAgICB4OiBudWxsLFxuXHQgICAgeTogbnVsbFxuXHQgIH07XG5cblx0ICAvLyBtYXAgb2YgSUUgMTAgcG9pbnRlciBldmVudHNcblx0ICB2YXIgcG9pbnRlck1hcCA9IHtcblx0ICAgIDI6ICd0b3VjaCcsXG5cdCAgICAzOiAndG91Y2gnLCAvLyB0cmVhdCBwZW4gbGlrZSB0b3VjaFxuXHQgICAgNDogJ21vdXNlJ1xuXHQgIH07XG5cblx0ICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cblx0ICB0cnkge1xuXHQgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcblx0ICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgLypcblx0ICAgKiBzZXQgdXBcblx0ICAgKi9cblxuXHQgIHZhciBzZXRVcCA9IGZ1bmN0aW9uIHNldFVwKCkge1xuXHQgICAgLy8gYWRkIGNvcnJlY3QgbW91c2Ugd2hlZWwgZXZlbnQgbWFwcGluZyB0byBgaW5wdXRNYXBgXG5cdCAgICBpbnB1dE1hcFtkZXRlY3RXaGVlbCgpXSA9ICdtb3VzZSc7XG5cblx0ICAgIGFkZExpc3RlbmVycygpO1xuXHQgICAgc2V0SW5wdXQoKTtcblx0ICB9O1xuXG5cdCAgLypcblx0ICAgKiBldmVudHNcblx0ICAgKi9cblxuXHQgIHZhciBhZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoKSB7XG5cdCAgICAvLyBgcG9pbnRlcm1vdmVgLCBgTVNQb2ludGVyTW92ZWAsIGBtb3VzZW1vdmVgIGFuZCBtb3VzZSB3aGVlbCBldmVudCBiaW5kaW5nXG5cdCAgICAvLyBjYW4gb25seSBkZW1vbnN0cmF0ZSBwb3RlbnRpYWwsIGJ1dCBub3QgYWN0dWFsLCBpbnRlcmFjdGlvblxuXHQgICAgLy8gYW5kIGFyZSB0cmVhdGVkIHNlcGFyYXRlbHlcblx0ICAgIHZhciBvcHRpb25zID0gc3VwcG9ydHNQYXNzaXZlID8geyBwYXNzaXZlOiB0cnVlIH0gOiBmYWxzZTtcblxuXHQgICAgLy8gcG9pbnRlciBldmVudHMgKG1vdXNlLCBwZW4sIHRvdWNoKVxuXHQgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcblx0ICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdXBkYXRlSW5wdXQpO1xuXHQgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBzZXRJbnRlbnQpO1xuXHQgICAgfSBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcblx0ICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlckRvd24nLCB1cGRhdGVJbnB1dCk7XG5cdCAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJNb3ZlJywgc2V0SW50ZW50KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIG1vdXNlIGV2ZW50c1xuXHQgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdXBkYXRlSW5wdXQpO1xuXHQgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc2V0SW50ZW50KTtcblxuXHQgICAgICAvLyB0b3VjaCBldmVudHNcblx0ICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xuXHQgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hCdWZmZXIsIG9wdGlvbnMpO1xuXHQgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoQnVmZmVyKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICAvLyBtb3VzZSB3aGVlbFxuXHQgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoZGV0ZWN0V2hlZWwoKSwgc2V0SW50ZW50LCBvcHRpb25zKTtcblxuXHQgICAgLy8ga2V5Ym9hcmQgZXZlbnRzXG5cdCAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHVwZGF0ZUlucHV0KTtcblx0ICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwZGF0ZUlucHV0KTtcblx0ICB9O1xuXG5cdCAgLy8gY2hlY2tzIGNvbmRpdGlvbnMgYmVmb3JlIHVwZGF0aW5nIG5ldyBpbnB1dFxuXHQgIHZhciB1cGRhdGVJbnB1dCA9IGZ1bmN0aW9uIHVwZGF0ZUlucHV0KGV2ZW50KSB7XG5cdCAgICAvLyBvbmx5IGV4ZWN1dGUgaWYgdGhlIHRvdWNoIGJ1ZmZlciB0aW1lciBpc24ndCBydW5uaW5nXG5cdCAgICBpZiAoIWlzQnVmZmVyaW5nKSB7XG5cdCAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LndoaWNoO1xuXHQgICAgICB2YXIgdmFsdWUgPSBpbnB1dE1hcFtldmVudC50eXBlXTtcblx0ICAgICAgaWYgKHZhbHVlID09PSAncG9pbnRlcicpIHZhbHVlID0gcG9pbnRlclR5cGUoZXZlbnQpO1xuXG5cdCAgICAgIGlmIChjdXJyZW50SW5wdXQgIT09IHZhbHVlIHx8IGN1cnJlbnRJbnRlbnQgIT09IHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIGFjdGl2ZUVsZW0gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHQgICAgICAgIHZhciBhY3RpdmVJbnB1dCA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBub3RGb3JtSW5wdXQgPSBhY3RpdmVFbGVtICYmIGFjdGl2ZUVsZW0ubm9kZU5hbWUgJiYgZm9ybUlucHV0cy5pbmRleE9mKGFjdGl2ZUVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xuXG5cdCAgICAgICAgaWYgKG5vdEZvcm1JbnB1dCB8fCBjaGFuZ2VJbnRlbnRNYXAuaW5kZXhPZihldmVudEtleSkgIT09IC0xKSB7XG5cdCAgICAgICAgICBhY3RpdmVJbnB1dCA9IHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHZhbHVlID09PSAndG91Y2gnIHx8XG5cdCAgICAgICAgLy8gaWdub3JlIG1vdXNlIG1vZGlmaWVyIGtleXNcblx0ICAgICAgICB2YWx1ZSA9PT0gJ21vdXNlJyB8fFxuXHQgICAgICAgIC8vIGRvbid0IHN3aXRjaCBpZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIGEgZm9ybSBpbnB1dFxuXHQgICAgICAgIHZhbHVlID09PSAna2V5Ym9hcmQnICYmIGV2ZW50S2V5ICYmIGFjdGl2ZUlucHV0ICYmIGlnbm9yZU1hcC5pbmRleE9mKGV2ZW50S2V5KSA9PT0gLTEpIHtcblx0ICAgICAgICAgIC8vIHNldCB0aGUgY3VycmVudCBhbmQgY2F0Y2gtYWxsIHZhcmlhYmxlXG5cdCAgICAgICAgICBjdXJyZW50SW5wdXQgPSBjdXJyZW50SW50ZW50ID0gdmFsdWU7XG5cblx0ICAgICAgICAgIHNldElucHV0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8vIHVwZGF0ZXMgdGhlIGRvYyBhbmQgYGlucHV0VHlwZXNgIGFycmF5IHdpdGggbmV3IGlucHV0XG5cdCAgdmFyIHNldElucHV0ID0gZnVuY3Rpb24gc2V0SW5wdXQoKSB7XG5cdCAgICBkb2Muc2V0QXR0cmlidXRlKCdkYXRhLXdoYXRpbnB1dCcsIGN1cnJlbnRJbnB1dCk7XG5cdCAgICBkb2Muc2V0QXR0cmlidXRlKCdkYXRhLXdoYXRpbnRlbnQnLCBjdXJyZW50SW5wdXQpO1xuXG5cdCAgICBpZiAoaW5wdXRUeXBlcy5pbmRleE9mKGN1cnJlbnRJbnB1dCkgPT09IC0xKSB7XG5cdCAgICAgIGlucHV0VHlwZXMucHVzaChjdXJyZW50SW5wdXQpO1xuXHQgICAgICBkb2MuY2xhc3NOYW1lICs9ICcgd2hhdGlucHV0LXR5cGVzLScgKyBjdXJyZW50SW5wdXQ7XG5cdCAgICB9XG5cblx0ICAgIGZpcmVGdW5jdGlvbnMoJ2lucHV0Jyk7XG5cdCAgfTtcblxuXHQgIC8vIHVwZGF0ZXMgaW5wdXQgaW50ZW50IGZvciBgbW91c2Vtb3ZlYCBhbmQgYHBvaW50ZXJtb3ZlYFxuXHQgIHZhciBzZXRJbnRlbnQgPSBmdW5jdGlvbiBzZXRJbnRlbnQoZXZlbnQpIHtcblx0ICAgIC8vIHRlc3QgdG8gc2VlIGlmIGBtb3VzZW1vdmVgIGhhcHBlbmVkIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW5cblx0ICAgIC8vIHRvIGRldGVjdCBzY3JvbGxpbmcgdmVyc3VzIG1vdXNlbW92ZVxuXHQgICAgaWYgKG1vdXNlUG9zWyd4J10gIT09IGV2ZW50LnNjcmVlblggfHwgbW91c2VQb3NbJ3knXSAhPT0gZXZlbnQuc2NyZWVuWSkge1xuXHQgICAgICBpc1Njcm9sbGluZyA9IGZhbHNlO1xuXG5cdCAgICAgIG1vdXNlUG9zWyd4J10gPSBldmVudC5zY3JlZW5YO1xuXHQgICAgICBtb3VzZVBvc1sneSddID0gZXZlbnQuc2NyZWVuWTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlzU2Nyb2xsaW5nID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gb25seSBleGVjdXRlIGlmIHRoZSB0b3VjaCBidWZmZXIgdGltZXIgaXNuJ3QgcnVubmluZ1xuXHQgICAgLy8gb3Igc2Nyb2xsaW5nIGlzbid0IGhhcHBlbmluZ1xuXHQgICAgaWYgKCFpc0J1ZmZlcmluZyAmJiAhaXNTY3JvbGxpbmcpIHtcblx0ICAgICAgdmFyIHZhbHVlID0gaW5wdXRNYXBbZXZlbnQudHlwZV07XG5cdCAgICAgIGlmICh2YWx1ZSA9PT0gJ3BvaW50ZXInKSB2YWx1ZSA9IHBvaW50ZXJUeXBlKGV2ZW50KTtcblxuXHQgICAgICBpZiAoY3VycmVudEludGVudCAhPT0gdmFsdWUpIHtcblx0ICAgICAgICBjdXJyZW50SW50ZW50ID0gdmFsdWU7XG5cblx0ICAgICAgICBkb2Muc2V0QXR0cmlidXRlKCdkYXRhLXdoYXRpbnRlbnQnLCBjdXJyZW50SW50ZW50KTtcblxuXHQgICAgICAgIGZpcmVGdW5jdGlvbnMoJ2ludGVudCcpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8vIGJ1ZmZlcnMgdG91Y2ggZXZlbnRzIGJlY2F1c2UgdGhleSBmcmVxdWVudGx5IGFsc28gZmlyZSBtb3VzZSBldmVudHNcblx0ICB2YXIgdG91Y2hCdWZmZXIgPSBmdW5jdGlvbiB0b3VjaEJ1ZmZlcihldmVudCkge1xuXHQgICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuXHQgICAgICBpc0J1ZmZlcmluZyA9IGZhbHNlO1xuXG5cdCAgICAgIC8vIHNldCB0aGUgY3VycmVudCBpbnB1dFxuXHQgICAgICB1cGRhdGVJbnB1dChldmVudCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpc0J1ZmZlcmluZyA9IHRydWU7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHZhciBmaXJlRnVuY3Rpb25zID0gZnVuY3Rpb24gZmlyZUZ1bmN0aW9ucyh0eXBlKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnVuY3Rpb25MaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGlmIChmdW5jdGlvbkxpc3RbaV0udHlwZSA9PT0gdHlwZSkge1xuXHQgICAgICAgIGZ1bmN0aW9uTGlzdFtpXS5mbi5jYWxsKHVuZGVmaW5lZCwgY3VycmVudEludGVudCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLypcblx0ICAgKiB1dGlsaXRpZXNcblx0ICAgKi9cblxuXHQgIHZhciBwb2ludGVyVHlwZSA9IGZ1bmN0aW9uIHBvaW50ZXJUeXBlKGV2ZW50KSB7XG5cdCAgICBpZiAodHlwZW9mIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXR1cm4gcG9pbnRlck1hcFtldmVudC5wb2ludGVyVHlwZV07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyB0cmVhdCBwZW4gbGlrZSB0b3VjaFxuXHQgICAgICByZXR1cm4gZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nID8gJ3RvdWNoJyA6IGV2ZW50LnBvaW50ZXJUeXBlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvLyBkZXRlY3QgdmVyc2lvbiBvZiBtb3VzZSB3aGVlbCBldmVudCB0byB1c2Vcblx0ICAvLyB2aWEgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXG5cdCAgdmFyIGRldGVjdFdoZWVsID0gZnVuY3Rpb24gZGV0ZWN0V2hlZWwoKSB7XG5cdCAgICB2YXIgd2hlZWxUeXBlID0gdm9pZCAwO1xuXG5cdCAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgc3VwcG9ydCBcIndoZWVsXCJcblx0ICAgIGlmICgnb253aGVlbCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpIHtcblx0ICAgICAgd2hlZWxUeXBlID0gJ3doZWVsJztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFdlYmtpdCBhbmQgSUUgc3VwcG9ydCBhdCBsZWFzdCBcIm1vdXNld2hlZWxcIlxuXHQgICAgICAvLyBvciBhc3N1bWUgdGhhdCByZW1haW5pbmcgYnJvd3NlcnMgYXJlIG9sZGVyIEZpcmVmb3hcblx0ICAgICAgd2hlZWxUeXBlID0gZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQgPyAnbW91c2V3aGVlbCcgOiAnRE9NTW91c2VTY3JvbGwnO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gd2hlZWxUeXBlO1xuXHQgIH07XG5cblx0ICB2YXIgb2JqUG9zID0gZnVuY3Rpb24gb2JqUG9zKG1hdGNoKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZnVuY3Rpb25MaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGlmIChmdW5jdGlvbkxpc3RbaV0uZm4gPT09IG1hdGNoKSB7XG5cdCAgICAgICAgcmV0dXJuIGk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLypcblx0ICAgKiBpbml0XG5cdCAgICovXG5cblx0ICAvLyBkb24ndCBzdGFydCBzY3JpcHQgdW5sZXNzIGJyb3dzZXIgY3V0cyB0aGUgbXVzdGFyZFxuXHQgIC8vIChhbHNvIHBhc3NlcyBpZiBwb2x5ZmlsbHMgYXJlIHVzZWQpXG5cdCAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiB3aW5kb3cgJiYgQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0ICAgIHNldFVwKCk7XG5cdCAgfVxuXG5cdCAgLypcblx0ICAgKiBhcGlcblx0ICAgKi9cblxuXHQgIHJldHVybiB7XG5cdCAgICAvLyByZXR1cm5zIHN0cmluZzogdGhlIGN1cnJlbnQgaW5wdXQgdHlwZVxuXHQgICAgLy8gb3B0OiAnbG9vc2UnfCdzdHJpY3QnXG5cdCAgICAvLyAnc3RyaWN0JyAoZGVmYXVsdCk6IHJldHVybnMgdGhlIHNhbWUgdmFsdWUgYXMgdGhlIGBkYXRhLXdoYXRpbnB1dGAgYXR0cmlidXRlXG5cdCAgICAvLyAnbG9vc2UnOiBpbmNsdWRlcyBgZGF0YS13aGF0aW50ZW50YCB2YWx1ZSBpZiBpdCdzIG1vcmUgY3VycmVudCB0aGFuIGBkYXRhLXdoYXRpbnB1dGBcblx0ICAgIGFzazogZnVuY3Rpb24gYXNrKG9wdCkge1xuXHQgICAgICByZXR1cm4gb3B0ID09PSAnbG9vc2UnID8gY3VycmVudEludGVudCA6IGN1cnJlbnRJbnB1dDtcblx0ICAgIH0sXG5cblx0ICAgIC8vIHJldHVybnMgYXJyYXk6IGFsbCB0aGUgZGV0ZWN0ZWQgaW5wdXQgdHlwZXNcblx0ICAgIHR5cGVzOiBmdW5jdGlvbiB0eXBlcygpIHtcblx0ICAgICAgcmV0dXJuIGlucHV0VHlwZXM7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBvdmVyd3JpdGVzIGlnbm9yZWQga2V5cyB3aXRoIHByb3ZpZGVkIGFycmF5XG5cdCAgICBpZ25vcmVLZXlzOiBmdW5jdGlvbiBpZ25vcmVLZXlzKGFycikge1xuXHQgICAgICBpZ25vcmVNYXAgPSBhcnI7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBhdHRhY2ggZnVuY3Rpb25zIHRvIGlucHV0IGFuZCBpbnRlbnQgXCJldmVudHNcIlxuXHQgICAgLy8gZnVuY3Q6IGZ1bmN0aW9uIHRvIGZpcmUgb24gY2hhbmdlXG5cdCAgICAvLyBldmVudFR5cGU6ICdpbnB1dCd8J2ludGVudCdcblx0ICAgIHJlZ2lzdGVyT25DaGFuZ2U6IGZ1bmN0aW9uIHJlZ2lzdGVyT25DaGFuZ2UoZm4sIGV2ZW50VHlwZSkge1xuXHQgICAgICBmdW5jdGlvbkxpc3QucHVzaCh7XG5cdCAgICAgICAgZm46IGZuLFxuXHQgICAgICAgIHR5cGU6IGV2ZW50VHlwZSB8fCAnaW5wdXQnXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblxuXHQgICAgdW5SZWdpc3Rlck9uQ2hhbmdlOiBmdW5jdGlvbiB1blJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcblx0ICAgICAgdmFyIHBvc2l0aW9uID0gb2JqUG9zKGZuKTtcblxuXHQgICAgICBpZiAocG9zaXRpb24pIHtcblx0ICAgICAgICBmdW5jdGlvbkxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdH0oKTtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3doYXQtaW5wdXQvZGlzdC93aGF0LWlucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IGphcmFsbGF4ID0gcmVxdWlyZSgnLi9zcmMvamFyYWxsYXguZXNtJykuZGVmYXVsdDtcbmNvbnN0IGphcmFsbGF4VmlkZW8gPSByZXF1aXJlKCcuL3NyYy9qYXJhbGxheC12aWRlby5lc20nKS5kZWZhdWx0O1xuY29uc3QgamFyYWxsYXhFbGVtZW50ID0gcmVxdWlyZSgnLi9zcmMvamFyYWxsYXgtZWxlbWVudC5lc20nKS5kZWZhdWx0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBqYXJhbGxheCxcbiAgICBqYXJhbGxheEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBqYXJhbGxheEVsZW1lbnQoamFyYWxsYXgpO1xuICAgIH0sXG4gICAgamFyYWxsYXhWaWRlbygpIHtcbiAgICAgICAgcmV0dXJuIGphcmFsbGF4VmlkZW8oamFyYWxsYXgpO1xuICAgIH0sXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvamFyYWxsYXgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRvbVJlYWR5IGZyb20gJ2xpdGUtcmVhZHknO1xuaW1wb3J0IHJhZiBmcm9tICdyYWZsJztcbmltcG9ydCB7IHdpbmRvdyB9IGZyb20gJ2dsb2JhbCc7XG5cbmNvbnN0IGlzSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUgJykgPiAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQvJykgPiAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UvJykgPiAtMTtcblxuY29uc3Qgc3VwcG9ydFRyYW5zZm9ybSA9ICgoKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ZXMgPSAndHJhbnNmb3JtIFdlYmtpdFRyYW5zZm9ybSBNb3pUcmFuc2Zvcm0nLnNwbGl0KCcgJyk7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGl2ICYmIGRpdi5zdHlsZVtwcmVmaXhlc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeGVzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn0pKCk7XG5cbi8vIFdpbmRvdyBkYXRhXG5sZXQgd25kVztcbmxldCB3bmRIO1xubGV0IHduZFk7XG5sZXQgZm9yY2VSZXNpemVQYXJhbGxheCA9IGZhbHNlO1xubGV0IGZvcmNlU2Nyb2xsUGFyYWxsYXggPSBmYWxzZTtcbmZ1bmN0aW9uIHVwZGF0ZVduZFZhcnMoZSkge1xuICAgIHduZFcgPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgd25kSCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIGlmICh0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgKGUudHlwZSA9PT0gJ2xvYWQnIHx8IGUudHlwZSA9PT0gJ2RvbS1sb2FkZWQnKSkge1xuICAgICAgICBmb3JjZVJlc2l6ZVBhcmFsbGF4ID0gdHJ1ZTtcbiAgICB9XG59XG51cGRhdGVXbmRWYXJzKCk7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlV25kVmFycyk7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB1cGRhdGVXbmRWYXJzKTtcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdXBkYXRlV25kVmFycyk7XG5kb21SZWFkeSgoKSA9PiB7XG4gICAgdXBkYXRlV25kVmFycyh7XG4gICAgICAgIHR5cGU6ICdkb20tbG9hZGVkJyxcbiAgICB9KTtcbn0pO1xuXG4vLyBsaXN0IHdpdGggYWxsIGphcmFsbGF4IGluc3RhbmNlc1xuLy8gbmVlZCB0byByZW5kZXIgYWxsIGluIG9uZSBzY3JvbGwvcmVzaXplIGV2ZW50XG5jb25zdCBqYXJhbGxheExpc3QgPSBbXTtcblxuLy8gQW5pbWF0ZSBpZiBjaGFuZ2VkIHdpbmRvdyBzaXplIG9yIHNjcm9sbGVkIHBhZ2VcbmxldCBvbGRQYWdlRGF0YSA9IGZhbHNlO1xuZnVuY3Rpb24gdXBkYXRlUGFyYWxsYXgoKSB7XG4gICAgaWYgKCFqYXJhbGxheExpc3QubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LnBhZ2VZT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd25kWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3bmRZID0gKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIGNvbnN0IGlzUmVzaXplZCA9IGZvcmNlUmVzaXplUGFyYWxsYXggfHwgIW9sZFBhZ2VEYXRhIHx8IG9sZFBhZ2VEYXRhLndpZHRoICE9PSB3bmRXIHx8IG9sZFBhZ2VEYXRhLmhlaWdodCAhPT0gd25kSDtcbiAgICBjb25zdCBpc1Njcm9sbGVkID0gZm9yY2VTY3JvbGxQYXJhbGxheCB8fCBpc1Jlc2l6ZWQgfHwgIW9sZFBhZ2VEYXRhIHx8IG9sZFBhZ2VEYXRhLnkgIT09IHduZFk7XG5cbiAgICBmb3JjZVJlc2l6ZVBhcmFsbGF4ID0gZmFsc2U7XG4gICAgZm9yY2VTY3JvbGxQYXJhbGxheCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzUmVzaXplZCB8fCBpc1Njcm9sbGVkKSB7XG4gICAgICAgIGphcmFsbGF4TGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNSZXNpemVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5vblJlc2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU2Nyb2xsZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLm9uU2Nyb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9sZFBhZ2VEYXRhID0ge1xuICAgICAgICAgICAgd2lkdGg6IHduZFcsXG4gICAgICAgICAgICBoZWlnaHQ6IHduZEgsXG4gICAgICAgICAgICB5OiB3bmRZLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJhZih1cGRhdGVQYXJhbGxheCk7XG59XG5cblxuLy8gUmVzaXplT2JzZXJ2ZXJcbmNvbnN0IHJlc2l6ZU9ic2VydmVyID0gZ2xvYmFsLlJlc2l6ZU9ic2VydmVyID8gbmV3IGdsb2JhbC5SZXNpemVPYnNlcnZlcigoZW50cnkpID0+IHtcbiAgICBpZiAoZW50cnkgJiYgZW50cnkubGVuZ3RoKSB7XG4gICAgICAgIHJhZigoKSA9PiB7XG4gICAgICAgICAgICBlbnRyeS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFyZ2V0ICYmIGl0ZW0udGFyZ2V0LmphcmFsbGF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZXNpemVQYXJhbGxheCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50YXJnZXQuamFyYWxsYXgub25SZXNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVNjcm9sbFBhcmFsbGF4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufSkgOiBmYWxzZTtcblxuXG5sZXQgaW5zdGFuY2VJRCA9IDA7XG5cbi8vIEphcmFsbGF4IGNsYXNzXG5jbGFzcyBKYXJhbGxheCB7XG4gICAgY29uc3RydWN0b3IoaXRlbSwgdXNlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgc2VsZi5pbnN0YW5jZUlEID0gaW5zdGFuY2VJRCsrO1xuXG4gICAgICAgIHNlbGYuJGl0ZW0gPSBpdGVtO1xuXG4gICAgICAgIHNlbGYuZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnc2Nyb2xsJywgLy8gdHlwZSBvZiBwYXJhbGxheDogc2Nyb2xsLCBzY2FsZSwgb3BhY2l0eSwgc2NhbGUtb3BhY2l0eSwgc2Nyb2xsLW9wYWNpdHlcbiAgICAgICAgICAgIHNwZWVkOiAwLjUsIC8vIHN1cHBvcnRlZCB2YWx1ZSBmcm9tIC0xIHRvIDJcbiAgICAgICAgICAgIGltZ1NyYzogbnVsbCxcbiAgICAgICAgICAgIGltZ0VsZW1lbnQ6ICcuamFyYWxsYXgtaW1nJyxcbiAgICAgICAgICAgIGltZ1NpemU6ICdjb3ZlcicsXG4gICAgICAgICAgICBpbWdQb3NpdGlvbjogJzUwJSA1MCUnLFxuICAgICAgICAgICAgaW1nUmVwZWF0OiAnbm8tcmVwZWF0JywgLy8gc3VwcG9ydGVkIG9ubHkgZm9yIGJhY2tncm91bmQsIG5vdCBmb3IgPGltZz4gdGFnXG4gICAgICAgICAgICBrZWVwSW1nOiBmYWxzZSwgLy8ga2VlcCA8aW1nPiB0YWcgaW4gaXQncyBkZWZhdWx0IHBsYWNlXG4gICAgICAgICAgICBlbGVtZW50SW5WaWV3cG9ydDogbnVsbCxcbiAgICAgICAgICAgIHpJbmRleDogLTEwMCxcbiAgICAgICAgICAgIGRpc2FibGVQYXJhbGxheDogZmFsc2UsXG4gICAgICAgICAgICBkaXNhYmxlVmlkZW86IGZhbHNlLFxuICAgICAgICAgICAgYXV0b21hdGljUmVzaXplOiB0cnVlLCAvLyB1c2UgUmVzaXplT2JzZXJ2ZXIgdG8gcmVjYWxjdWxhdGUgcG9zaXRpb24gYW5kIHNpemUgb2YgcGFyYWxsYXggaW1hZ2VcblxuICAgICAgICAgICAgLy8gdmlkZW9cbiAgICAgICAgICAgIHZpZGVvU3JjOiBudWxsLFxuICAgICAgICAgICAgdmlkZW9TdGFydFRpbWU6IDAsXG4gICAgICAgICAgICB2aWRlb0VuZFRpbWU6IDAsXG4gICAgICAgICAgICB2aWRlb1ZvbHVtZTogMCxcbiAgICAgICAgICAgIHZpZGVvTG9vcDogdHJ1ZSxcbiAgICAgICAgICAgIHZpZGVvUGxheU9ubHlWaXNpYmxlOiB0cnVlLFxuXG4gICAgICAgICAgICAvLyBldmVudHNcbiAgICAgICAgICAgIG9uU2Nyb2xsOiBudWxsLCAvLyBmdW5jdGlvbihjYWxjdWxhdGlvbnMpIHt9XG4gICAgICAgICAgICBvbkluaXQ6IG51bGwsIC8vIGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgIG9uRGVzdHJveTogbnVsbCwgLy8gZnVuY3Rpb24oKSB7fVxuICAgICAgICAgICAgb25Db3ZlckltYWdlOiBudWxsLCAvLyBmdW5jdGlvbigpIHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gREVQUkVDQVRFRDogb2xkIGRhdGEtb3B0aW9uc1xuICAgICAgICBjb25zdCBkZXByZWNhdGVkRGF0YUF0dHJpYnV0ZSA9IHNlbGYuJGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWphcmFsbGF4Jyk7XG4gICAgICAgIGNvbnN0IG9sZERhdGFPcHRpb25zID0gSlNPTi5wYXJzZShkZXByZWNhdGVkRGF0YUF0dHJpYnV0ZSB8fCAne30nKTtcbiAgICAgICAgaWYgKGRlcHJlY2F0ZWREYXRhQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXRlY3RlZCB1c2FnZSBvZiBkZXByZWNhdGVkIGRhdGEtamFyYWxsYXggSlNPTiBvcHRpb25zLCB5b3Ugc2hvdWxkIHVzZSBwdXJlIGRhdGEtYXR0cmlidXRlIG9wdGlvbnMuIFNlZSBpbmZvIGhlcmUgLSBodHRwczovL2dpdGh1Yi5jb20vbmstby9qYXJhbGxheC9pc3N1ZXMvNTMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXBhcmUgZGF0YS1vcHRpb25zXG4gICAgICAgIGNvbnN0IGRhdGFPcHRpb25zID0gc2VsZi4kaXRlbS5kYXRhc2V0IHx8IHt9O1xuICAgICAgICBjb25zdCBwdXJlRGF0YU9wdGlvbnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YU9wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG93ZUNhc2VPcHRpb24gPSBrZXkuc3Vic3RyKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBrZXkuc3Vic3RyKDEpO1xuICAgICAgICAgICAgaWYgKGxvd2VDYXNlT3B0aW9uICYmIHR5cGVvZiBzZWxmLmRlZmF1bHRzW2xvd2VDYXNlT3B0aW9uXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwdXJlRGF0YU9wdGlvbnNbbG93ZUNhc2VPcHRpb25dID0gZGF0YU9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VsZi5vcHRpb25zID0gc2VsZi5leHRlbmQoe30sIHNlbGYuZGVmYXVsdHMsIG9sZERhdGFPcHRpb25zLCBwdXJlRGF0YU9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgc2VsZi5wdXJlT3B0aW9ucyA9IHNlbGYuZXh0ZW5kKHt9LCBzZWxmLm9wdGlvbnMpO1xuXG4gICAgICAgIC8vIHByZXBhcmUgJ3RydWUnIGFuZCAnZmFsc2UnIHN0cmluZ3MgdG8gYm9vbGVhblxuICAgICAgICBPYmplY3Qua2V5cyhzZWxmLm9wdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9uc1trZXldID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYub3B0aW9uc1trZXldID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zW2tleV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZml4IHNwZWVkIG9wdGlvbiBbLTEuMCwgMi4wXVxuICAgICAgICBzZWxmLm9wdGlvbnMuc3BlZWQgPSBNYXRoLm1pbigyLCBNYXRoLm1heCgtMSwgcGFyc2VGbG9hdChzZWxmLm9wdGlvbnMuc3BlZWQpKSk7XG5cbiAgICAgICAgLy8gZGVwcmVjYXRlZCBub0FuZHJvaWQgYW5kIG5vSW9zIG9wdGlvbnNcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5ub0FuZHJvaWQgfHwgc2VsZi5vcHRpb25zLm5vSW9zKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXRlY3RlZCB1c2FnZSBvZiBkZXByZWNhdGVkIG5vQW5kcm9pZCBvciBub0lvcyBvcHRpb25zLCB5b3Ugc2hvdWxkIHVzZSBkaXNhYmxlUGFyYWxsYXggb3B0aW9uLiBTZWUgaW5mbyBoZXJlIC0gaHR0cHM6Ly9naXRodWIuY29tL25rLW8vamFyYWxsYXgvI2Rpc2FibGUtb24tbW9iaWxlLWRldmljZXMnKTtcblxuICAgICAgICAgICAgLy8gcHJlcGFyZSBmYWxsYmFjayBpZiBkaXNhYmxlUGFyYWxsYXggb3B0aW9uIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICBpZiAoIXNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLm5vSW9zICYmIHNlbGYub3B0aW9ucy5ub0FuZHJvaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLmRpc2FibGVQYXJhbGxheCA9IC9pUGFkfGlQaG9uZXxpUG9kfEFuZHJvaWQvO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5vcHRpb25zLm5vSW9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXggPSAvaVBhZHxpUGhvbmV8aVBvZC87XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLm9wdGlvbnMubm9BbmRyb2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXggPSAvQW5kcm9pZC87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlcGFyZSBkaXNhYmxlUGFyYWxsYXggY2FsbGJhY2tcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zLmRpc2FibGVQYXJhbGxheCA9IG5ldyBSZWdFeHAoc2VsZi5vcHRpb25zLmRpc2FibGVQYXJhbGxheCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2FibGVQYXJhbGxheFJlZ2V4cCA9IHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXg7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4ID0gKCkgPT4gZGlzYWJsZVBhcmFsbGF4UmVnZXhwLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4ID0gKCkgPT4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmVwYXJlIGRpc2FibGVWaWRlbyBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMuZGlzYWJsZVZpZGVvID0gbmV3IFJlZ0V4cChzZWxmLm9wdGlvbnMuZGlzYWJsZVZpZGVvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmRpc2FibGVWaWRlbyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgY29uc3QgZGlzYWJsZVZpZGVvUmVnZXhwID0gc2VsZi5vcHRpb25zLmRpc2FibGVWaWRlbztcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8gPSAoKSA9PiBkaXNhYmxlVmlkZW9SZWdleHAudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8gPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1c3RvbSBlbGVtZW50IHRvIGNoZWNrIGlmIHBhcmFsbGF4IGluIHZpZXdwb3J0XG4gICAgICAgIGxldCBlbGVtZW50SW5WUCA9IHNlbGYub3B0aW9ucy5lbGVtZW50SW5WaWV3cG9ydDtcbiAgICAgICAgLy8gZ2V0IGZpcnN0IGl0ZW0gZnJvbSBhcnJheVxuICAgICAgICBpZiAoZWxlbWVudEluVlAgJiYgdHlwZW9mIGVsZW1lbnRJblZQID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZWxlbWVudEluVlAubGVuZ3RoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgW2VsZW1lbnRJblZQXSA9IGVsZW1lbnRJblZQO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIGRvbSBlbGVtZW50XG4gICAgICAgIGlmICghKGVsZW1lbnRJblZQIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnRJblZQID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLm9wdGlvbnMuZWxlbWVudEluVmlld3BvcnQgPSBlbGVtZW50SW5WUDtcblxuICAgICAgICBzZWxmLmltYWdlID0ge1xuICAgICAgICAgICAgc3JjOiBzZWxmLm9wdGlvbnMuaW1nU3JjIHx8IG51bGwsXG4gICAgICAgICAgICAkY29udGFpbmVyOiBudWxsLFxuICAgICAgICAgICAgdXNlSW1nVGFnOiBmYWxzZSxcblxuICAgICAgICAgICAgLy8gcG9zaXRpb24gZml4ZWQgaXMgbmVlZGVkIGZvciB0aGUgbW9zdCBvZiBicm93c2VycyBiZWNhdXNlIGFic29sdXRlIHBvc2l0aW9uIGhhdmUgZ2xpdGNoZXNcbiAgICAgICAgICAgIC8vIG9uIE1hY09TIHdpdGggc21vb3RoIHNjcm9sbCB0aGVyZSBpcyBhIGh1Z2UgbGFncyB3aXRoIGFic29sdXRlIHBvc2l0aW9uIC0gaHR0cHM6Ly9naXRodWIuY29tL25rLW8vamFyYWxsYXgvaXNzdWVzLzc1XG4gICAgICAgICAgICAvLyBvbiBtb2JpbGUgZGV2aWNlcyBiZXR0ZXIgc2Nyb2xsZWQgd2l0aCBhYnNvbHV0ZSBwb3NpdGlvblxuICAgICAgICAgICAgcG9zaXRpb246IC9pUGFkfGlQaG9uZXxpUG9kfEFuZHJvaWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAnYWJzb2x1dGUnIDogJ2ZpeGVkJyxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc2VsZi5pbml0SW1nKCkgJiYgc2VsZi5jYW5Jbml0UGFyYWxsYXgoKSkge1xuICAgICAgICAgICAgc2VsZi5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgc3R5bGVzIHRvIGVsZW1lbnRcbiAgICBjc3MoZWwsIHN0eWxlcykge1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRyYW5zZm9ybSBwcm9wZXJ0eSB3aXRoIHZlbmRvciBwcmVmaXhcbiAgICAgICAgaWYgKHN0eWxlcy50cmFuc2Zvcm0gJiYgc3VwcG9ydFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgc3R5bGVzW3N1cHBvcnRUcmFuc2Zvcm1dID0gc3R5bGVzLnRyYW5zZm9ybTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZVtrZXldID0gc3R5bGVzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5kIGxpa2UgalF1ZXJ5LmV4dGVuZFxuICAgIGV4dGVuZChvdXQpIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhhcmd1bWVudHMpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXJndW1lbnRzW2ldKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBvdXRba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vIGdldCB3aW5kb3cgc2l6ZSBhbmQgc2Nyb2xsIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGV4dGVuc2lvbnNcbiAgICBnZXRXaW5kb3dEYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHduZFcsXG4gICAgICAgICAgICBoZWlnaHQ6IHduZEgsXG4gICAgICAgICAgICB5OiB3bmRZLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEphcmFsbGF4IGZ1bmN0aW9uc1xuICAgIGluaXRJbWcoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIGZpbmQgaW1hZ2UgZWxlbWVudFxuICAgICAgICBsZXQgJGltZ0VsZW1lbnQgPSBzZWxmLm9wdGlvbnMuaW1nRWxlbWVudDtcbiAgICAgICAgaWYgKCRpbWdFbGVtZW50ICYmIHR5cGVvZiAkaW1nRWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICRpbWdFbGVtZW50ID0gc2VsZi4kaXRlbS5xdWVyeVNlbGVjdG9yKCRpbWdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiBkb20gZWxlbWVudFxuICAgICAgICBpZiAoISgkaW1nRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAkaW1nRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGltZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMua2VlcEltZykge1xuICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2UuJGl0ZW0gPSAkaW1nRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2UuJGl0ZW0gPSAkaW1nRWxlbWVudDtcbiAgICAgICAgICAgICAgICBzZWxmLmltYWdlLiRpdGVtUGFyZW50ID0gJGltZ0VsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuaW1hZ2UudXNlSW1nVGFnID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRydWUgaWYgdGhlcmUgaXMgaW1nIHRhZ1xuICAgICAgICBpZiAoc2VsZi5pbWFnZS4kaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgaW1hZ2Ugc3JjXG4gICAgICAgIGlmIChzZWxmLmltYWdlLnNyYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS5zcmMgPSBzZWxmLmNzcyhzZWxmLiRpdGVtLCAnYmFja2dyb3VuZC1pbWFnZScpLnJlcGxhY2UoL151cmxcXChbJ1wiXT8vZywgJycpLnJlcGxhY2UoL1snXCJdP1xcKSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhKCFzZWxmLmltYWdlLnNyYyB8fCBzZWxmLmltYWdlLnNyYyA9PT0gJ25vbmUnKTtcbiAgICB9XG5cbiAgICBjYW5Jbml0UGFyYWxsYXgoKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0VHJhbnNmb3JtICYmICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4KCk7XG4gICAgfVxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGltYWdlU3R5bGVzID0ge307XG5cbiAgICAgICAgaWYgKCFzZWxmLm9wdGlvbnMua2VlcEltZykge1xuICAgICAgICAgICAgLy8gc2F2ZSBkZWZhdWx0IHVzZXIgc3R5bGVzXG4gICAgICAgICAgICBjb25zdCBjdXJTdHlsZSA9IHNlbGYuJGl0ZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgaWYgKGN1clN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi4kaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJywgY3VyU3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaW1hZ2UudXNlSW1nVGFnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VySW1nU3R5bGUgPSBzZWxmLmltYWdlLiRpdGVtLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VySW1nU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZS4kaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJywgY3VySW1nU3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCByZWxhdGl2ZSBwb3NpdGlvbiBhbmQgei1pbmRleCB0byB0aGUgcGFyZW50XG4gICAgICAgIGlmIChzZWxmLmNzcyhzZWxmLiRpdGVtLCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIHNlbGYuY3NzKHNlbGYuJGl0ZW0sIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmNzcyhzZWxmLiRpdGVtLCAnei1pbmRleCcpID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHNlbGYuY3NzKHNlbGYuJGl0ZW0sIHtcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRhaW5lciBmb3IgcGFyYWxsYXggaW1hZ2VcbiAgICAgICAgc2VsZi5pbWFnZS4kY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNlbGYuY3NzKHNlbGYuaW1hZ2UuJGNvbnRhaW5lciwgY29udGFpbmVyU3R5bGVzKTtcbiAgICAgICAgc2VsZi5jc3Moc2VsZi5pbWFnZS4kY29udGFpbmVyLCB7XG4gICAgICAgICAgICAnei1pbmRleCc6IHNlbGYub3B0aW9ucy56SW5kZXgsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpeCBmb3IgSUUgaHR0cHM6Ly9naXRodWIuY29tL25rLW8vamFyYWxsYXgvaXNzdWVzLzExMFxuICAgICAgICBpZiAoaXNJRSkge1xuICAgICAgICAgICAgc2VsZi5jc3Moc2VsZi5pbWFnZS4kY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC45OTk5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmltYWdlLiRjb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsIGBqYXJhbGxheC1jb250YWluZXItJHtzZWxmLmluc3RhbmNlSUR9YCk7XG4gICAgICAgIHNlbGYuJGl0ZW0uYXBwZW5kQ2hpbGQoc2VsZi5pbWFnZS4kY29udGFpbmVyKTtcblxuICAgICAgICAvLyB1c2UgaW1nIHRhZ1xuICAgICAgICBpZiAoc2VsZi5pbWFnZS51c2VJbWdUYWcpIHtcbiAgICAgICAgICAgIGltYWdlU3R5bGVzID0gc2VsZi5leHRlbmQoe1xuICAgICAgICAgICAgICAgICdvYmplY3QtZml0Jzogc2VsZi5vcHRpb25zLmltZ1NpemUsXG4gICAgICAgICAgICAgICAgJ29iamVjdC1wb3NpdGlvbic6IHNlbGYub3B0aW9ucy5pbWdQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBwbHVnaW4gaHR0cHM6Ly9naXRodWIuY29tL2JmcmVkLWl0L29iamVjdC1maXQtaW1hZ2VzXG4gICAgICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogYG9iamVjdC1maXQ6ICR7c2VsZi5vcHRpb25zLmltZ1NpemV9OyBvYmplY3QtcG9zaXRpb246ICR7c2VsZi5vcHRpb25zLmltZ1Bvc2l0aW9ufTtgLFxuICAgICAgICAgICAgICAgICdtYXgtd2lkdGgnOiAnbm9uZScsXG4gICAgICAgICAgICB9LCBjb250YWluZXJTdHlsZXMsIGltYWdlU3R5bGVzKTtcblxuICAgICAgICAvLyB1c2UgZGl2IHdpdGggYmFja2dyb3VuZCBpbWFnZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS4kaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaWYgKHNlbGYuaW1hZ2Uuc3JjKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VTdHlsZXMgPSBzZWxmLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzogc2VsZi5vcHRpb25zLmltZ1Bvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1zaXplJzogc2VsZi5vcHRpb25zLmltZ1NpemUsXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6IHNlbGYub3B0aW9ucy5pbWdSZXBlYXQsXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogYHVybChcIiR7c2VsZi5pbWFnZS5zcmN9XCIpYCxcbiAgICAgICAgICAgICAgICB9LCBjb250YWluZXJTdHlsZXMsIGltYWdlU3R5bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ29wYWNpdHknIHx8IHNlbGYub3B0aW9ucy50eXBlID09PSAnc2NhbGUnIHx8IHNlbGYub3B0aW9ucy50eXBlID09PSAnc2NhbGUtb3BhY2l0eScgfHwgc2VsZi5vcHRpb25zLnNwZWVkID09PSAxKSB7XG4gICAgICAgICAgICBzZWxmLmltYWdlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIG9uZSBvZiBwYXJlbnRzIGhhdmUgdHJhbnNmb3JtIHN0eWxlICh3aXRob3V0IHRoaXMgY2hlY2ssIHNjcm9sbCB0cmFuc2Zvcm0gd2lsbCBiZSBpbnZlcnRlZCBpZiB1c2VkIHBhcmFsbGF4IHdpdGggcG9zaXRpb24gZml4ZWQpXG4gICAgICAgIC8vIGRpc2N1c3Npb24gLSBodHRwczovL2dpdGh1Yi5jb20vbmstby9qYXJhbGxheC9pc3N1ZXMvOVxuICAgICAgICBpZiAoc2VsZi5pbWFnZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgbGV0IHBhcmVudFdpdGhUcmFuc2Zvcm0gPSAwO1xuICAgICAgICAgICAgbGV0ICRpdGVtUGFyZW50cyA9IHNlbGYuJGl0ZW07XG4gICAgICAgICAgICB3aGlsZSAoJGl0ZW1QYXJlbnRzICE9PSBudWxsICYmICRpdGVtUGFyZW50cyAhPT0gZG9jdW1lbnQgJiYgcGFyZW50V2l0aFRyYW5zZm9ybSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFRyYW5zZm9ybSA9IHNlbGYuY3NzKCRpdGVtUGFyZW50cywgJy13ZWJraXQtdHJhbnNmb3JtJykgfHwgc2VsZi5jc3MoJGl0ZW1QYXJlbnRzLCAnLW1vei10cmFuc2Zvcm0nKSB8fCBzZWxmLmNzcygkaXRlbVBhcmVudHMsICd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNmb3JtICYmIHBhcmVudFRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFdpdGhUcmFuc2Zvcm0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmltYWdlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGl0ZW1QYXJlbnRzID0gJGl0ZW1QYXJlbnRzLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcG9zaXRpb24gdG8gcGFyYWxsYXggYmxvY2tcbiAgICAgICAgaW1hZ2VTdHlsZXMucG9zaXRpb24gPSBzZWxmLmltYWdlLnBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGluc2VydCBwYXJhbGxheCBpbWFnZVxuICAgICAgICBzZWxmLmNzcyhzZWxmLmltYWdlLiRpdGVtLCBpbWFnZVN0eWxlcyk7XG4gICAgICAgIHNlbGYuaW1hZ2UuJGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmltYWdlLiRpdGVtKTtcblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAgICBzZWxmLm9uUmVzaXplKCk7XG4gICAgICAgIHNlbGYub25TY3JvbGwodHJ1ZSk7XG5cbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXJcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hdXRvbWF0aWNSZXNpemUgJiYgcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoc2VsZi4kaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsIG9uSW5pdCBldmVudFxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLm9uSW5pdCkge1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zLm9uSW5pdC5jYWxsKHNlbGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGRlZmF1bHQgdXNlciBiYWNrZ3JvdW5kXG4gICAgICAgIGlmIChzZWxmLmNzcyhzZWxmLiRpdGVtLCAnYmFja2dyb3VuZC1pbWFnZScpICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHNlbGYuY3NzKHNlbGYuJGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICdub25lJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5hZGRUb1BhcmFsbGF4TGlzdCgpO1xuICAgIH1cblxuICAgIC8vIGFkZCB0byBwYXJhbGxheCBpbnN0YW5jZXMgbGlzdFxuICAgIGFkZFRvUGFyYWxsYXhMaXN0KCkge1xuICAgICAgICBqYXJhbGxheExpc3QucHVzaCh0aGlzKTtcblxuICAgICAgICBpZiAoamFyYWxsYXhMaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdXBkYXRlUGFyYWxsYXgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBmcm9tIHBhcmFsbGF4IGluc3RhbmNlcyBsaXN0XG4gICAgcmVtb3ZlRnJvbVBhcmFsbGF4TGlzdCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgamFyYWxsYXhMaXN0LmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaW5zdGFuY2VJRCA9PT0gc2VsZi5pbnN0YW5jZUlEKSB7XG4gICAgICAgICAgICAgICAgamFyYWxsYXhMaXN0LnNwbGljZShrZXksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICBzZWxmLnJlbW92ZUZyb21QYXJhbGxheExpc3QoKTtcblxuICAgICAgICAvLyByZXR1cm4gc3R5bGVzIG9uIGNvbnRhaW5lciBhcyBiZWZvcmUgamFyYWxsYXggaW5pdFxuICAgICAgICBjb25zdCBvcmlnaW5hbFN0eWxlc1RhZyA9IHNlbGYuJGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWphcmFsbGF4LW9yaWdpbmFsLXN0eWxlcycpO1xuICAgICAgICBzZWxmLiRpdGVtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC1vcmlnaW5hbC1zdHlsZXMnKTtcbiAgICAgICAgLy8gbnVsbCBvY2N1cnMgaWYgdGhlcmUgaXMgbm8gc3R5bGUgdGFnIGJlZm9yZSBqYXJhbGxheCBpbml0XG4gICAgICAgIGlmICghb3JpZ2luYWxTdHlsZXNUYWcpIHtcbiAgICAgICAgICAgIHNlbGYuJGl0ZW0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi4kaXRlbS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgb3JpZ2luYWxTdHlsZXNUYWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuaW1hZ2UudXNlSW1nVGFnKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gc3R5bGVzIG9uIGltZyB0YWcgYXMgYmVmb3JlIGphcmFsbGF4IGluaXRcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3R5bGVzSW1nVGFnID0gc2VsZi5pbWFnZS4kaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJyk7XG4gICAgICAgICAgICBzZWxmLmltYWdlLiRpdGVtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC1vcmlnaW5hbC1zdHlsZXMnKTtcbiAgICAgICAgICAgIC8vIG51bGwgb2NjdXJzIGlmIHRoZXJlIGlzIG5vIHN0eWxlIHRhZyBiZWZvcmUgamFyYWxsYXggaW5pdFxuICAgICAgICAgICAgaWYgKCFvcmlnaW5hbFN0eWxlc0ltZ1RhZykge1xuICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2UuJGl0ZW0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmltYWdlLiRpdGVtLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBvcmlnaW5hbFN0eWxlc1RhZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1vdmUgaW1nIHRhZyB0byBpdHMgZGVmYXVsdCBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKHNlbGYuaW1hZ2UuJGl0ZW1QYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmltYWdlLiRpdGVtUGFyZW50LmFwcGVuZENoaWxkKHNlbGYuaW1hZ2UuJGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFkZGl0aW9uYWwgZG9tIGVsZW1lbnRzXG4gICAgICAgIGlmIChzZWxmLiRjbGlwU3R5bGVzKSB7XG4gICAgICAgICAgICBzZWxmLiRjbGlwU3R5bGVzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi4kY2xpcFN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuaW1hZ2UuJGNvbnRhaW5lcikge1xuICAgICAgICAgICAgc2VsZi5pbWFnZS4kY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5pbWFnZS4kY29udGFpbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGwgb25EZXN0cm95IGV2ZW50XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMub25EZXN0cm95KSB7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMub25EZXN0cm95LmNhbGwoc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWxldGUgamFyYWxsYXggZnJvbSBpdGVtXG4gICAgICAgIGRlbGV0ZSBzZWxmLiRpdGVtLmphcmFsbGF4O1xuICAgIH1cblxuICAgIC8vIGl0IHdpbGwgcmVtb3ZlIHNvbWUgaW1hZ2Ugb3ZlcmxhcHBpbmdcbiAgICAvLyBvdmVybGFwcGluZyBvY2N1ciBkdWUgdG8gYW4gaW1hZ2UgcG9zaXRpb24gZml4ZWQgaW5zaWRlIGFic29sdXRlIHBvc2l0aW9uIGVsZW1lbnRcbiAgICBjbGlwQ29udGFpbmVyKCkge1xuICAgICAgICAvLyBuZWVkZWQgb25seSB3aGVuIGJhY2tncm91bmQgaW4gZml4ZWQgcG9zaXRpb25cbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCByZWN0ID0gc2VsZi5pbWFnZS4kY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJlY3Q7XG5cbiAgICAgICAgaWYgKCFzZWxmLiRjbGlwU3R5bGVzKSB7XG4gICAgICAgICAgICBzZWxmLiRjbGlwU3R5bGVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHNlbGYuJGNsaXBTdHlsZXMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAgICAgICBzZWxmLiRjbGlwU3R5bGVzLnNldEF0dHJpYnV0ZSgnaWQnLCBgamFyYWxsYXgtY2xpcC0ke3NlbGYuaW5zdGFuY2VJRH1gKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHNlbGYuJGNsaXBTdHlsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3R5bGVzID0gYCNqYXJhbGxheC1jb250YWluZXItJHtzZWxmLmluc3RhbmNlSUR9IHtcbiAgICAgICAgICAgY2xpcDogcmVjdCgwICR7d2lkdGh9cHggJHtoZWlnaHR9cHggMCk7XG4gICAgICAgICAgIGNsaXA6IHJlY3QoMCwgJHt3aWR0aH1weCwgJHtoZWlnaHR9cHgsIDApO1xuICAgICAgICB9YDtcblxuICAgICAgICAvLyBhZGQgY2xpcCBzdHlsZXMgaW5saW5lICh0aGlzIG1ldGhvZCBuZWVkIGZvciBzdXBwb3J0IElFOCBhbmQgbGVzcyBicm93c2VycylcbiAgICAgICAgaWYgKHNlbGYuJGNsaXBTdHlsZXMuc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgc2VsZi4kY2xpcFN0eWxlcy5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLiRjbGlwU3R5bGVzLmlubmVySFRNTCA9IHN0eWxlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvdmVySW1hZ2UoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IHJlY3QgPSBzZWxmLmltYWdlLiRjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGNvbnRIID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHsgc3BlZWQgfSA9IHNlbGYub3B0aW9ucztcbiAgICAgICAgY29uc3QgaXNTY3JvbGwgPSBzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3Njcm9sbCcgfHwgc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY3JvbGwtb3BhY2l0eSc7XG4gICAgICAgIGxldCBzY3JvbGxEaXN0ID0gMDtcbiAgICAgICAgbGV0IHJlc3VsdEggPSBjb250SDtcbiAgICAgICAgbGV0IHJlc3VsdE1UID0gMDtcblxuICAgICAgICAvLyBzY3JvbGwgcGFyYWxsYXhcbiAgICAgICAgaWYgKGlzU2Nyb2xsKSB7XG4gICAgICAgICAgICAvLyBzY3JvbGwgZGlzdGFuY2UgYW5kIGhlaWdodCBmb3IgaW1hZ2VcbiAgICAgICAgICAgIGlmIChzcGVlZCA8IDApIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxEaXN0ID0gc3BlZWQgKiBNYXRoLm1heChjb250SCwgd25kSCk7XG5cbiAgICAgICAgICAgICAgICBpZiAod25kSCA8IGNvbnRIKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbERpc3QgLT0gc3BlZWQgKiAoY29udEggLSB3bmRIKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjcm9sbERpc3QgPSBzcGVlZCAqIChjb250SCArIHduZEgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzaXplIGZvciBzY3JvbGwgcGFyYWxsYXhcbiAgICAgICAgICAgIGlmIChzcGVlZCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRIID0gTWF0aC5hYnMoc2Nyb2xsRGlzdCAtIHduZEgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVlZCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRIID0gc2Nyb2xsRGlzdCAvIHNwZWVkICsgTWF0aC5hYnMoc2Nyb2xsRGlzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdEggKz0gKHduZEggLSBjb250SCkgKiAoMSAtIHNwZWVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2Nyb2xsRGlzdCAvPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgc2Nyb2xsIGRpc3RhbmNlXG4gICAgICAgIHNlbGYucGFyYWxsYXhTY3JvbGxEaXN0YW5jZSA9IHNjcm9sbERpc3Q7XG5cbiAgICAgICAgLy8gdmVydGljYWwgY2VudGVyXG4gICAgICAgIGlmIChpc1Njcm9sbCkge1xuICAgICAgICAgICAgcmVzdWx0TVQgPSAod25kSCAtIHJlc3VsdEgpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdE1UID0gKGNvbnRIIC0gcmVzdWx0SCkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgcmVzdWx0IHRvIGl0ZW1cbiAgICAgICAgc2VsZi5jc3Moc2VsZi5pbWFnZS4kaXRlbSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBgJHtyZXN1bHRIfXB4YCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogYCR7cmVzdWx0TVR9cHhgLFxuICAgICAgICAgICAgbGVmdDogc2VsZi5pbWFnZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyA/IGAke3JlY3QubGVmdH1weGAgOiAnMCcsXG4gICAgICAgICAgICB3aWR0aDogYCR7cmVjdC53aWR0aH1weGAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhbGwgb25Db3ZlckltYWdlIGV2ZW50XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMub25Db3ZlckltYWdlKSB7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMub25Db3ZlckltYWdlLmNhbGwoc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gc29tZSB1c2VmdWwgZGF0YS4gVXNlZCBpbiB0aGUgdmlkZW8gY292ZXIgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZXN1bHRILFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogcmVzdWx0TVQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGFpbmVyOiByZWN0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFbGVtZW50SW5WaWV3cG9ydCB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICBvblNjcm9sbChmb3JjZSkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICBjb25zdCByZWN0ID0gc2VsZi4kaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgY29udFQgPSByZWN0LnRvcDtcbiAgICAgICAgY29uc3QgY29udEggPSByZWN0LmhlaWdodDtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0ge307XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgaW4gdmlld3BvcnRcbiAgICAgICAgbGV0IHZpZXdwb3J0UmVjdCA9IHJlY3Q7XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZWxlbWVudEluVmlld3BvcnQpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0UmVjdCA9IHNlbGYub3B0aW9ucy5lbGVtZW50SW5WaWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmlzRWxlbWVudEluVmlld3BvcnQgPSB2aWV3cG9ydFJlY3QuYm90dG9tID49IDBcbiAgICAgICAgICAgICYmIHZpZXdwb3J0UmVjdC5yaWdodCA+PSAwXG4gICAgICAgICAgICAmJiB2aWV3cG9ydFJlY3QudG9wIDw9IHduZEhcbiAgICAgICAgICAgICYmIHZpZXdwb3J0UmVjdC5sZWZ0IDw9IHduZFc7XG5cbiAgICAgICAgLy8gc3RvcCBjYWxjdWxhdGlvbnMgaWYgaXRlbSBpcyBub3QgaW4gdmlld3BvcnRcbiAgICAgICAgaWYgKGZvcmNlID8gZmFsc2UgOiAhc2VsZi5pc0VsZW1lbnRJblZpZXdwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgcGFyYWxsYXggaGVscGluZyB2YXJpYWJsZXNcbiAgICAgICAgY29uc3QgYmVmb3JlVG9wID0gTWF0aC5tYXgoMCwgY29udFQpO1xuICAgICAgICBjb25zdCBiZWZvcmVUb3BFbmQgPSBNYXRoLm1heCgwLCBjb250SCArIGNvbnRUKTtcbiAgICAgICAgY29uc3QgYWZ0ZXJUb3AgPSBNYXRoLm1heCgwLCAtY29udFQpO1xuICAgICAgICBjb25zdCBiZWZvcmVCb3R0b20gPSBNYXRoLm1heCgwLCBjb250VCArIGNvbnRIIC0gd25kSCk7XG4gICAgICAgIGNvbnN0IGJlZm9yZUJvdHRvbUVuZCA9IE1hdGgubWF4KDAsIGNvbnRIIC0gKGNvbnRUICsgY29udEggLSB3bmRIKSk7XG4gICAgICAgIGNvbnN0IGFmdGVyQm90dG9tID0gTWF0aC5tYXgoMCwgLWNvbnRUICsgd25kSCAtIGNvbnRIKTtcbiAgICAgICAgY29uc3QgZnJvbVZpZXdwb3J0Q2VudGVyID0gMSAtIDIgKiAod25kSCAtIGNvbnRUKSAvICh3bmRIICsgY29udEgpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBvbiBob3cgcGVyY2VudCBvZiBzZWN0aW9uIGlzIHZpc2libGVcbiAgICAgICAgbGV0IHZpc2libGVQZXJjZW50ID0gMTtcbiAgICAgICAgaWYgKGNvbnRIIDwgd25kSCkge1xuICAgICAgICAgICAgdmlzaWJsZVBlcmNlbnQgPSAxIC0gKGFmdGVyVG9wIHx8IGJlZm9yZUJvdHRvbSkgLyBjb250SDtcbiAgICAgICAgfSBlbHNlIGlmIChiZWZvcmVUb3BFbmQgPD0gd25kSCkge1xuICAgICAgICAgICAgdmlzaWJsZVBlcmNlbnQgPSBiZWZvcmVUb3BFbmQgLyB3bmRIO1xuICAgICAgICB9IGVsc2UgaWYgKGJlZm9yZUJvdHRvbUVuZCA8PSB3bmRIKSB7XG4gICAgICAgICAgICB2aXNpYmxlUGVyY2VudCA9IGJlZm9yZUJvdHRvbUVuZCAvIHduZEg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvcGFjaXR5XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ29wYWNpdHknIHx8IHNlbGYub3B0aW9ucy50eXBlID09PSAnc2NhbGUtb3BhY2l0eScgfHwgc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY3JvbGwtb3BhY2l0eScpIHtcbiAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAgICAgICAgIHN0eWxlcy5vcGFjaXR5ID0gdmlzaWJsZVBlcmNlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2FsZVxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY2FsZScgfHwgc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY2FsZS1vcGFjaXR5Jykge1xuICAgICAgICAgICAgbGV0IHNjYWxlID0gMTtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuc3BlZWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgLT0gc2VsZi5vcHRpb25zLnNwZWVkICogdmlzaWJsZVBlcmNlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYWxlICs9IHNlbGYub3B0aW9ucy5zcGVlZCAqICgxIC0gdmlzaWJsZVBlcmNlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IGBzY2FsZSgke3NjYWxlfSkgdHJhbnNsYXRlM2QoMCwwLDApYDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjcm9sbFxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY3JvbGwnIHx8IHNlbGYub3B0aW9ucy50eXBlID09PSAnc2Nyb2xsLW9wYWNpdHknKSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25ZID0gc2VsZi5wYXJhbGxheFNjcm9sbERpc3RhbmNlICogZnJvbVZpZXdwb3J0Q2VudGVyO1xuXG4gICAgICAgICAgICAvLyBmaXggaWYgcGFyYWxsYXggYmxvY2sgaW4gYWJzb2x1dGUgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChzZWxmLmltYWdlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25ZIC09IGNvbnRUO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsJHtwb3NpdGlvbll9cHgsMClgO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5jc3Moc2VsZi5pbWFnZS4kaXRlbSwgc3R5bGVzKTtcblxuICAgICAgICAvLyBjYWxsIG9uU2Nyb2xsIGV2ZW50XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMub25TY3JvbGwpIHtcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy5vblNjcm9sbC5jYWxsKHNlbGYsIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uOiByZWN0LFxuXG4gICAgICAgICAgICAgICAgYmVmb3JlVG9wLFxuICAgICAgICAgICAgICAgIGJlZm9yZVRvcEVuZCxcbiAgICAgICAgICAgICAgICBhZnRlclRvcCxcbiAgICAgICAgICAgICAgICBiZWZvcmVCb3R0b20sXG4gICAgICAgICAgICAgICAgYmVmb3JlQm90dG9tRW5kLFxuICAgICAgICAgICAgICAgIGFmdGVyQm90dG9tLFxuXG4gICAgICAgICAgICAgICAgdmlzaWJsZVBlcmNlbnQsXG4gICAgICAgICAgICAgICAgZnJvbVZpZXdwb3J0Q2VudGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5jb3ZlckltYWdlKCk7XG4gICAgICAgIHRoaXMuY2xpcENvbnRhaW5lcigpO1xuICAgIH1cbn1cblxuXG4vLyBnbG9iYWwgZGVmaW5pdGlvblxuY29uc3QgcGx1Z2luID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgLy8gY2hlY2sgZm9yIGRvbSBlbGVtZW50XG4gICAgLy8gdGhhbmtzOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4NDI4Ni9qYXZhc2NyaXB0LWlzZG9tLWhvdy1kby15b3UtY2hlY2staWYtYS1qYXZhc2NyaXB0LW9iamVjdC1pcy1hLWRvbS1vYmplY3RcbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnb2JqZWN0JyA/IGl0ZW1zIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgOiBpdGVtcyAmJiB0eXBlb2YgaXRlbXMgPT09ICdvYmplY3QnICYmIGl0ZW1zICE9PSBudWxsICYmIGl0ZW1zLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBpdGVtcy5ub2RlTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaXRlbXMgPSBbaXRlbXNdO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgY29uc3QgbGVuID0gaXRlbXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcbiAgICBsZXQgcmV0O1xuXG4gICAgZm9yIChrOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICghaXRlbXNba10uamFyYWxsYXgpIHtcbiAgICAgICAgICAgICAgICBpdGVtc1trXS5qYXJhbGxheCA9IG5ldyBKYXJhbGxheChpdGVtc1trXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbXNba10uamFyYWxsYXgpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICAgICAgICByZXQgPSBpdGVtc1trXS5qYXJhbGxheFtvcHRpb25zXS5hcHBseShpdGVtc1trXS5qYXJhbGxheCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xufTtcbnBsdWdpbi5jb25zdHJ1Y3RvciA9IEphcmFsbGF4O1xuXG5leHBvcnQgZGVmYXVsdCBwbHVnaW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qYXJhbGxheC9zcmMvamFyYWxsYXguZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcblxyXG5cdGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScpIHtcclxuXHRcdC8vIEFscmVhZHkgcmVhZHkgb3IgaW50ZXJhY3RpdmUsIGV4ZWN1dGUgY2FsbGJhY2tcclxuXHRcdGNhbGxiYWNrLmNhbGwoKTtcclxuXHR9XHJcblx0ZWxzZSBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcclxuXHRcdC8vIE9sZCBicm93c2Vyc1xyXG5cdFx0ZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScpXHJcblx0XHRcdFx0Y2FsbGJhY2suY2FsbCgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdGVsc2UgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuXHRcdC8vIE1vZGVybiBicm93c2Vyc1xyXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGNhbGxiYWNrKTtcclxuXHR9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbGl0ZS1yZWFkeS9saXRlcmVhZHkuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJ2dsb2JhbCcpXG5cbi8qKlxuICogYHJlcXVlc3RBbmltYXRpb25GcmFtZSgpYFxuICovXG5cbnZhciByZXF1ZXN0ID0gZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICB8fCBnbG9iYWwud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIHx8IGdsb2JhbC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfHwgZmFsbGJhY2tcblxudmFyIHByZXYgPSArbmV3IERhdGVcbmZ1bmN0aW9uIGZhbGxiYWNrIChmbikge1xuICB2YXIgY3VyciA9ICtuZXcgRGF0ZVxuICB2YXIgbXMgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyIC0gcHJldikpXG4gIHZhciByZXEgPSBzZXRUaW1lb3V0KGZuLCBtcylcbiAgcmV0dXJuIHByZXYgPSBjdXJyLCByZXFcbn1cblxuLyoqXG4gKiBgY2FuY2VsQW5pbWF0aW9uRnJhbWUoKWBcbiAqL1xuXG52YXIgY2FuY2VsID0gZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gIHx8IGdsb2JhbC53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZVxuICB8fCBnbG9iYWwubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgfHwgY2xlYXJUaW1lb3V0XG5cbmlmIChGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICByZXF1ZXN0ID0gcmVxdWVzdC5iaW5kKGdsb2JhbClcbiAgY2FuY2VsID0gY2FuY2VsLmJpbmQoZ2xvYmFsKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0XG5leHBvcnRzLmNhbmNlbCA9IGNhbmNlbFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmFmbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgVmlkZW9Xb3JrZXIgZnJvbSAndmlkZW8td29ya2VyJztcbmltcG9ydCBnbG9iYWwgZnJvbSAnZ2xvYmFsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gamFyYWxsYXhWaWRlbyhqYXJhbGxheCA9IGdsb2JhbC5qYXJhbGxheCkge1xuICAgIGlmICh0eXBlb2YgamFyYWxsYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBKYXJhbGxheCA9IGphcmFsbGF4LmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gYXBwZW5kIHZpZGVvIGFmdGVyIGluaXQgSmFyYWxsYXhcbiAgICBjb25zdCBkZWZJbml0ID0gSmFyYWxsYXgucHJvdG90eXBlLmluaXQ7XG4gICAgSmFyYWxsYXgucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGRlZkluaXQuYXBwbHkoc2VsZik7XG5cbiAgICAgICAgaWYgKHNlbGYudmlkZW8gJiYgIXNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8oKSkge1xuICAgICAgICAgICAgc2VsZi52aWRlby5nZXRWaWRlbygodmlkZW8pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCAkcGFyZW50ID0gdmlkZW8ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBzZWxmLmNzcyh2aWRlbywge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc2VsZi5pbWFnZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAnMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogJzBweCcsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiAnMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIG1heEhlaWdodDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogLTEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi4kdmlkZW8gPSB2aWRlbztcbiAgICAgICAgICAgICAgICBzZWxmLmltYWdlLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodmlkZW8pO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBhcmVudCB2aWRlbyBlbGVtZW50IChjcmVhdGVkIGJ5IFZpZGVvV29ya2VyKVxuICAgICAgICAgICAgICAgICRwYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCgkcGFyZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNvdmVyIHZpZGVvXG4gICAgY29uc3QgZGVmQ292ZXJJbWFnZSA9IEphcmFsbGF4LnByb3RvdHlwZS5jb3ZlckltYWdlO1xuICAgIEphcmFsbGF4LnByb3RvdHlwZS5jb3ZlckltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gZGVmQ292ZXJJbWFnZS5hcHBseShzZWxmKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHNlbGYuaW1hZ2UuJGl0ZW0gPyBzZWxmLmltYWdlLiRpdGVtLm5vZGVOYW1lIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKGltYWdlRGF0YSAmJiBzZWxmLnZpZGVvICYmIG5vZGUgJiYgKG5vZGUgPT09ICdJRlJBTUUnIHx8IG5vZGUgPT09ICdWSURFTycpKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGltYWdlRGF0YS5pbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICBsZXQgdyA9IGggKiBzZWxmLmltYWdlLndpZHRoIC8gc2VsZi5pbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICBsZXQgbWwgPSAoaW1hZ2VEYXRhLmNvbnRhaW5lci53aWR0aCAtIHcpIC8gMjtcbiAgICAgICAgICAgIGxldCBtdCA9IGltYWdlRGF0YS5pbWFnZS5tYXJnaW5Ub3A7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZURhdGEuY29udGFpbmVyLndpZHRoID4gdykge1xuICAgICAgICAgICAgICAgIHcgPSBpbWFnZURhdGEuY29udGFpbmVyLndpZHRoO1xuICAgICAgICAgICAgICAgIGggPSB3ICogc2VsZi5pbWFnZS5oZWlnaHQgLyBzZWxmLmltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIG1sID0gMDtcbiAgICAgICAgICAgICAgICBtdCArPSAoaW1hZ2VEYXRhLmltYWdlLmhlaWdodCAtIGgpIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHZpZGVvIGhlaWdodCBvdmVyIHRoYW4gbmVlZCB0byBoaWRlIGNvbnRyb2xzXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gJ0lGUkFNRScpIHtcbiAgICAgICAgICAgICAgICBoICs9IDQwMDtcbiAgICAgICAgICAgICAgICBtdCAtPSAyMDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuY3NzKHNlbGYuJHZpZGVvLCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGAke3d9cHhgLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IGAke21sfXB4YCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2h9cHhgLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogYCR7bXR9cHhgLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW1hZ2VEYXRhO1xuICAgIH07XG5cbiAgICAvLyBpbml0IHZpZGVvXG4gICAgY29uc3QgZGVmSW5pdEltZyA9IEphcmFsbGF4LnByb3RvdHlwZS5pbml0SW1nO1xuICAgIEphcmFsbGF4LnByb3RvdHlwZS5pbml0SW1nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgZGVmYXVsdFJlc3VsdCA9IGRlZkluaXRJbWcuYXBwbHkoc2VsZik7XG5cbiAgICAgICAgaWYgKCFzZWxmLm9wdGlvbnMudmlkZW9TcmMpIHtcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy52aWRlb1NyYyA9IHNlbGYuJGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWphcmFsbGF4LXZpZGVvJykgfHwgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMudmlkZW9TcmMpIHtcbiAgICAgICAgICAgIHNlbGYuZGVmYXVsdEluaXRJbWdSZXN1bHQgPSBkZWZhdWx0UmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdFJlc3VsdDtcbiAgICB9O1xuXG4gICAgY29uc3QgZGVmQ2FuSW5pdFBhcmFsbGF4ID0gSmFyYWxsYXgucHJvdG90eXBlLmNhbkluaXRQYXJhbGxheDtcbiAgICBKYXJhbGxheC5wcm90b3R5cGUuY2FuSW5pdFBhcmFsbGF4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgZGVmYXVsdFJlc3VsdCA9IGRlZkNhbkluaXRQYXJhbGxheC5hcHBseShzZWxmKTtcblxuICAgICAgICBpZiAoIXNlbGYub3B0aW9ucy52aWRlb1NyYykge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2aWRlbyA9IG5ldyBWaWRlb1dvcmtlcihzZWxmLm9wdGlvbnMudmlkZW9TcmMsIHtcbiAgICAgICAgICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgICAgICAgICAgbG9vcDogc2VsZi5vcHRpb25zLnZpZGVvTG9vcCxcbiAgICAgICAgICAgIHNob3dDb250b2xzOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogc2VsZi5vcHRpb25zLnZpZGVvU3RhcnRUaW1lIHx8IDAsXG4gICAgICAgICAgICBlbmRUaW1lOiBzZWxmLm9wdGlvbnMudmlkZW9FbmRUaW1lIHx8IDAsXG4gICAgICAgICAgICBtdXRlOiBzZWxmLm9wdGlvbnMudmlkZW9Wb2x1bWUgPyAwIDogMSxcbiAgICAgICAgICAgIHZvbHVtZTogc2VsZi5vcHRpb25zLnZpZGVvVm9sdW1lIHx8IDAsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh2aWRlby5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHBhcmFsbGF4IHdpbGwgbm90IGJlIGluaXRlZCwgd2UgY2FuIGFkZCB0aHVtYm5haWwgb24gYmFja2dyb3VuZC5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5kZWZhdWx0SW5pdEltZ1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB2aWRlby5nZXRJbWFnZVVSTCgodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIGRlZmF1bHQgdXNlciBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clN0eWxlID0gc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLiRpdGVtLnNldEF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC1vcmlnaW5hbC1zdHlsZXMnLCBjdXJTdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBuZXcgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jc3Moc2VsZi4kaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogYHVybChcIiR7dXJsfVwiKWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1zaXplJzogJ2NvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpbml0IHZpZGVvXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpZGVvLm9uKCdyZWFkeScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy52aWRlb1BsYXlPbmx5VmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkT25TY3JvbGwgPSBzZWxmLm9uU2Nyb2xsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vblNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRPblNjcm9sbC5hcHBseShzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnZpZGVvTG9vcCB8fCAoIXNlbGYub3B0aW9ucy52aWRlb0xvb3AgJiYgIXNlbGYudmlkZW9FbmRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2aWRlby5vbignc3RhcnRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtID0gc2VsZi5pbWFnZS4kaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZS4kaXRlbSA9IHNlbGYuJHZpZGVvO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB2aWRlbyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2Uud2lkdGggPSBzZWxmLnZpZGVvLnZpZGVvV2lkdGggfHwgMTI4MDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZS5oZWlnaHQgPSBzZWxmLnZpZGVvLnZpZGVvSGVpZ2h0IHx8IDcyMDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb3ZlckltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xpcENvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uU2Nyb2xsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGlkZSBpbWFnZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmltYWdlLiRkZWZhdWx0X2l0ZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmlkZW8ub24oJ2VuZGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZpZGVvRW5kZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5vcHRpb25zLnZpZGVvTG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdyBpbWFnZSBpZiBMb29wIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZS4kaXRlbSA9IHNlbGYuaW1hZ2UuJGRlZmF1bHRfaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmltYWdlLiRpdGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGltYWdlIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvdmVySW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsaXBDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9uU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNlbGYudmlkZW8gPSB2aWRlbztcblxuICAgICAgICAgICAgICAgIC8vIHNldCBpbWFnZSBpZiBub3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmRlZmF1bHRJbml0SW1nUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWRlby50eXBlICE9PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlby5nZXRJbWFnZVVSTCgodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbWFnZS5zcmMgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGVtcHR5IGltYWdlIG9uIGxvY2FsIHZpZGVvIGlmIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBNyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBEZXN0cm95IHZpZGVvIHBhcmFsbGF4XG4gICAgY29uc3QgZGVmRGVzdHJveSA9IEphcmFsbGF4LnByb3RvdHlwZS5kZXN0cm95O1xuICAgIEphcmFsbGF4LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtKSB7XG4gICAgICAgICAgICBzZWxmLmltYWdlLiRpdGVtID0gc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtO1xuICAgICAgICAgICAgZGVsZXRlIHNlbGYuaW1hZ2UuJGRlZmF1bHRfaXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZkRlc3Ryb3kuYXBwbHkoc2VsZik7XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2phcmFsbGF4L3NyYy9qYXJhbGxheC12aWRlby5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvdmlkZW8td29ya2VyLmVzbScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdmlkZW8td29ya2VyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBEZWZlcnJlZFxuLy8gdGhhbmtzIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgwOTY3MTUvaW1wbGVtZW50LWRlZmVycmVkLW9iamVjdC13aXRob3V0LXVzaW5nLWpxdWVyeVxuZnVuY3Rpb24gRGVmZXJyZWQoKSB7XG4gICAgdGhpcy5fZG9uZSA9IFtdO1xuICAgIHRoaXMuX2ZhaWwgPSBbXTtcbn1cbkRlZmVycmVkLnByb3RvdHlwZSA9IHtcbiAgICBleGVjdXRlKGxpc3QsIGFyZ3MpIHtcbiAgICAgICAgbGV0IGkgPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBsaXN0W2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZXNvbHZlKCkge1xuICAgICAgICB0aGlzLmV4ZWN1dGUodGhpcy5fZG9uZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlamVjdCgpIHtcbiAgICAgICAgdGhpcy5leGVjdXRlKHRoaXMuX2ZhaWwsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBkb25lKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2RvbmUucHVzaChjYWxsYmFjayk7XG4gICAgfSxcbiAgICBmYWlsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2ZhaWwucHVzaChjYWxsYmFjayk7XG4gICAgfSxcbn07XG5cbmxldCBJRCA9IDA7XG5sZXQgWW91dHViZUFQSWFkZGVkID0gMDtcbmxldCBWaW1lb0FQSWFkZGVkID0gMDtcbmxldCBsb2FkaW5nWW91dHViZVBsYXllciA9IDA7XG5sZXQgbG9hZGluZ1ZpbWVvUGxheWVyID0gMDtcbmNvbnN0IGxvYWRpbmdZb3V0dWJlRGVmZXIgPSBuZXcgRGVmZXJyZWQoKTtcbmNvbnN0IGxvYWRpbmdWaW1lb0RlZmVyID0gbmV3IERlZmVycmVkKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZGVvV29ya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgc2VsZi51cmwgPSB1cmw7XG5cbiAgICAgICAgc2VsZi5vcHRpb25zX2RlZmF1bHQgPSB7XG4gICAgICAgICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgICAgIG11dGU6IGZhbHNlLFxuICAgICAgICAgICAgdm9sdW1lOiAxMDAsXG4gICAgICAgICAgICBzaG93Q29udG9sczogdHJ1ZSxcblxuICAgICAgICAgICAgLy8gc3RhcnQgLyBlbmQgdmlkZW8gdGltZSBpbiBzZWNvbmRzXG4gICAgICAgICAgICBzdGFydFRpbWU6IDAsXG4gICAgICAgICAgICBlbmRUaW1lOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYub3B0aW9ucyA9IHNlbGYuZXh0ZW5kKHt9LCBzZWxmLm9wdGlvbnNfZGVmYXVsdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gY2hlY2sgVVJMXG4gICAgICAgIHNlbGYudmlkZW9JRCA9IHNlbGYucGFyc2VVUkwodXJsKTtcblxuICAgICAgICAvLyBpbml0XG4gICAgICAgIGlmIChzZWxmLnZpZGVvSUQpIHtcbiAgICAgICAgICAgIHNlbGYuSUQgPSBJRCsrO1xuICAgICAgICAgICAgc2VsZi5sb2FkQVBJKCk7XG4gICAgICAgICAgICBzZWxmLmluaXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4dGVuZCBsaWtlIGpRdWVyeS5leHRlbmRcbiAgICBleHRlbmQob3V0KSB7XG4gICAgICAgIG91dCA9IG91dCB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXJndW1lbnRzKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ3VtZW50c1tpXSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0W2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBwYXJzZVVSTCh1cmwpIHtcbiAgICAgICAgLy8gcGFyc2UgeW91dHViZSBJRFxuICAgICAgICBmdW5jdGlvbiBnZXRZb3V0dWJlSUQoeXRVcmwpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgICAgICAgICAgY29uc3QgcmVnRXhwID0gLy4qKD86eW91dHUuYmVcXC98dlxcL3x1XFwvXFx3XFwvfGVtYmVkXFwvfHdhdGNoXFw/dj0pKFteI1xcJlxcP10qKS4qLztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0geXRVcmwubWF0Y2gocmVnRXhwKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXS5sZW5ndGggPT09IDExID8gbWF0Y2hbMV0gOiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcnNlIHZpbWVvIElEXG4gICAgICAgIGZ1bmN0aW9uIGdldFZpbWVvSUQodm1VcmwpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgICAgICAgICAgY29uc3QgcmVnRXhwID0gL2h0dHBzPzpcXC9cXC8oPzp3d3dcXC58cGxheWVyXFwuKT92aW1lby5jb21cXC8oPzpjaGFubmVsc1xcLyg/OlxcdytcXC8pP3xncm91cHNcXC8oW15cXC9dKilcXC92aWRlb3NcXC98YWxidW1cXC8oXFxkKylcXC92aWRlb1xcL3x2aWRlb1xcL3wpKFxcZCspKD86JHxcXC98XFw/KS87XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZtVXJsLm1hdGNoKHJlZ0V4cCk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbM10gPyBtYXRjaFszXSA6IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2UgbG9jYWwgc3RyaW5nXG4gICAgICAgIGZ1bmN0aW9uIGdldExvY2FsVmlkZW9zKGxvY1VybCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICAgICAgICBjb25zdCB2aWRlb0Zvcm1hdHMgPSBsb2NVcmwuc3BsaXQoLywoPz1tcDRcXDp8d2VibVxcOnxvZ3ZcXDp8b2dnXFw6KS8pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBsZXQgcmVhZHkgPSAwO1xuICAgICAgICAgICAgdmlkZW9Gb3JtYXRzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsLm1hdGNoKC9eKG1wNHx3ZWJtfG9ndnxvZ2cpXFw6KC4qKS8pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSAmJiBtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W21hdGNoWzFdID09PSAnb2d2JyA/ICdvZ2cnIDogbWF0Y2hbMV1dID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZWFkeSA/IHJlc3VsdCA6IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgWW91dHViZSA9IGdldFlvdXR1YmVJRCh1cmwpO1xuICAgICAgICBjb25zdCBWaW1lbyA9IGdldFZpbWVvSUQodXJsKTtcbiAgICAgICAgY29uc3QgTG9jYWwgPSBnZXRMb2NhbFZpZGVvcyh1cmwpO1xuXG4gICAgICAgIGlmIChZb3V0dWJlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAneW91dHViZSc7XG4gICAgICAgICAgICByZXR1cm4gWW91dHViZTtcbiAgICAgICAgfSBlbHNlIGlmIChWaW1lbykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ3ZpbWVvJztcbiAgICAgICAgICAgIHJldHVybiBWaW1lbztcbiAgICAgICAgfSBlbHNlIGlmIChMb2NhbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ2xvY2FsJztcbiAgICAgICAgICAgIHJldHVybiBMb2NhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnZpZGVvSUQ7XG4gICAgfVxuXG4gICAgLy8gZXZlbnRzXG4gICAgb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnRzTGlzdCA9IHRoaXMudXNlckV2ZW50c0xpc3QgfHwgW107XG5cbiAgICAgICAgLy8gYWRkIG5ldyBjYWxsYmFjayBpbiBldmVudHMgbGlzdFxuICAgICAgICAodGhpcy51c2VyRXZlbnRzTGlzdFtuYW1lXSB8fCAodGhpcy51c2VyRXZlbnRzTGlzdFtuYW1lXSA9IFtdKSkucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIG9mZihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMudXNlckV2ZW50c0xpc3QgfHwgIXRoaXMudXNlckV2ZW50c0xpc3RbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVzZXJFdmVudHNMaXN0W25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51c2VyRXZlbnRzTGlzdFtuYW1lXS5mb3JFYWNoKCh2YWwsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlckV2ZW50c0xpc3RbbmFtZV1ba2V5XSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpcmUobmFtZSkge1xuICAgICAgICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBpZiAodGhpcy51c2VyRXZlbnRzTGlzdCAmJiB0eXBlb2YgdGhpcy51c2VyRXZlbnRzTGlzdFtuYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckV2ZW50c0xpc3RbbmFtZV0uZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCB3aXRoIGFsbCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBsYXkoc3RhcnQpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5wbGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICd5b3V0dWJlJyAmJiBzZWxmLnBsYXllci5wbGF5VmlkZW8pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIuc2Vla1RvKHN0YXJ0IHx8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFlULlBsYXllclN0YXRlLlBMQVlJTkcgIT09IHNlbGYucGxheWVyLmdldFBsYXllclN0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5wbGF5VmlkZW8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICd2aW1lbycpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIuc2V0Q3VycmVudFRpbWUoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5wbGF5ZXIuZ2V0UGF1c2VkKCkudGhlbigocGF1c2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHNlbGYucGxheWVyLmN1cnJlbnRUaW1lID0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5wbGF5ZXIucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAneW91dHViZScgJiYgc2VsZi5wbGF5ZXIucGF1c2VWaWRlbykge1xuICAgICAgICAgICAgaWYgKFlULlBsYXllclN0YXRlLlBMQVlJTkcgPT09IHNlbGYucGxheWVyLmdldFBsYXllclN0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5wYXVzZVZpZGVvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAndmltZW8nKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXllci5nZXRQYXVzZWQoKS50aGVuKChwYXVzZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYudHlwZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgaWYgKCFzZWxmLnBsYXllci5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbXV0ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5wbGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICd5b3V0dWJlJyAmJiBzZWxmLnBsYXllci5tdXRlKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXllci5tdXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAndmltZW8nICYmIHNlbGYucGxheWVyLnNldFZvbHVtZSkge1xuICAgICAgICAgICAgc2VsZi5wbGF5ZXIuc2V0Vm9sdW1lKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYudHlwZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgc2VsZi4kdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdW5tdXRlKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYudHlwZSA9PT0gJ3lvdXR1YmUnICYmIHNlbGYucGxheWVyLm11dGUpIHtcbiAgICAgICAgICAgIHNlbGYucGxheWVyLnVuTXV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYudHlwZSA9PT0gJ3ZpbWVvJyAmJiBzZWxmLnBsYXllci5zZXRWb2x1bWUpIHtcbiAgICAgICAgICAgIHNlbGYucGxheWVyLnNldFZvbHVtZShzZWxmLm9wdGlvbnMudm9sdW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHNlbGYuJHZpZGVvLm11dGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRWb2x1bWUodm9sdW1lID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgIXZvbHVtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYudHlwZSA9PT0gJ3lvdXR1YmUnICYmIHNlbGYucGxheWVyLnNldFZvbHVtZSkge1xuICAgICAgICAgICAgc2VsZi5wbGF5ZXIuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAndmltZW8nICYmIHNlbGYucGxheWVyLnNldFZvbHVtZSkge1xuICAgICAgICAgICAgc2VsZi5wbGF5ZXIuc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICBzZWxmLiR2aWRlby52b2x1bWUgPSB2b2x1bWUgLyAxMDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRWb2x1bWUoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5wbGF5ZXIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICd5b3V0dWJlJyAmJiBzZWxmLnBsYXllci5nZXRWb2x1bWUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYucGxheWVyLmdldFZvbHVtZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICd2aW1lbycgJiYgc2VsZi5wbGF5ZXIuZ2V0Vm9sdW1lKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXllci5nZXRWb2x1bWUoKS50aGVuKCh2b2x1bWUpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh2b2x1bWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzZWxmLiR2aWRlby52b2x1bWUgKiAxMDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TXV0ZWQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICghc2VsZi5wbGF5ZXIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYudHlwZSA9PT0gJ3lvdXR1YmUnICYmIHNlbGYucGxheWVyLmlzTXV0ZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYucGxheWVyLmlzTXV0ZWQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAndmltZW8nICYmIHNlbGYucGxheWVyLmdldFZvbHVtZSkge1xuICAgICAgICAgICAgc2VsZi5wbGF5ZXIuZ2V0Vm9sdW1lKCkudGhlbigodm9sdW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soISF2b2x1bWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzZWxmLiR2aWRlby5tdXRlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJbWFnZVVSTChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoc2VsZi52aWRlb0ltYWdlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzZWxmLnZpZGVvSW1hZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYudHlwZSA9PT0gJ3lvdXR1YmUnKSB7XG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGVTaXplcyA9IFtcbiAgICAgICAgICAgICAgICAnbWF4cmVzZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgJ3NkZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgJ2hxZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgJzAnLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBzdGVwID0gMDtcblxuICAgICAgICAgICAgY29uc3QgdGVtcEltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdGVtcEltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gdGh1bWJuYWlsLCB5b3V0dWJlIGFkZCB0aGVpciBvd24gaW1hZ2Ugd2l0aCB3aWR0aCA9IDEyMHB4XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLm5hdHVyYWxXaWR0aCB8fCB0aGlzLndpZHRoKSAhPT0gMTIwIHx8IHN0ZXAgPT09IGF2YWlsYWJsZVNpemVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb2tcbiAgICAgICAgICAgICAgICAgICAgc2VsZi52aWRlb0ltYWdlID0gYGh0dHBzOi8vaW1nLnlvdXR1YmUuY29tL3ZpLyR7c2VsZi52aWRlb0lEfS8ke2F2YWlsYWJsZVNpemVzW3N0ZXBdfS5qcGdgO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzZWxmLnZpZGVvSW1hZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSBhbm90aGVyIHNpemVcbiAgICAgICAgICAgICAgICAgICAgc3RlcCsrO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNyYyA9IGBodHRwczovL2ltZy55b3V0dWJlLmNvbS92aS8ke3NlbGYudmlkZW9JRH0vJHthdmFpbGFibGVTaXplc1tzdGVwXX0uanBnYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGVtcEltZy5zcmMgPSBgaHR0cHM6Ly9pbWcueW91dHViZS5jb20vdmkvJHtzZWxmLnZpZGVvSUR9LyR7YXZhaWxhYmxlU2l6ZXNbc3RlcF19LmpwZ2A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAndmltZW8nKSB7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBgaHR0cHM6Ly92aW1lby5jb20vYXBpL3YyL3ZpZGVvLyR7c2VsZi52aWRlb0lEfS5qc29uYCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IEpTT04ucGFyc2UodGhpcy5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi52aWRlb0ltYWdlID0gcmVzcG9uc2VbMF0udGh1bWJuYWlsX2xhcmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc2VsZi52aWRlb0ltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVycm9yIDooXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZhbGxiYWNrIHRvIHRoZSBvbGQgdmVyc2lvbi5cbiAgICBnZXRJZnJhbWUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nZXRWaWRlbyhjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZ2V0VmlkZW8oY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gcmV0dXJuIGdlbmVyYXRlZCB2aWRlbyBibG9ja1xuICAgICAgICBpZiAoc2VsZi4kdmlkZW8pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHNlbGYuJHZpZGVvKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdlbmVyYXRlIG5ldyB2aWRlbyBibG9ja1xuICAgICAgICBzZWxmLm9uQVBJcmVhZHkoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGhpZGRlbkRpdjtcbiAgICAgICAgICAgIGlmICghc2VsZi4kdmlkZW8pIHtcbiAgICAgICAgICAgICAgICBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBoaWRkZW5EaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gWW91dHViZVxuICAgICAgICAgICAgaWYgKHNlbGYudHlwZSA9PT0gJ3lvdXR1YmUnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLnZpZGVvSWQgPSBzZWxmLnZpZGVvSUQ7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLnBsYXllclZhcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9oaWRlOiAxLFxuICAgICAgICAgICAgICAgICAgICByZWw6IDAsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9wbGF5OiAwLFxuICAgICAgICAgICAgICAgICAgICAvLyBhdXRvcGxheSBlbmFibGUgb24gbW9iaWxlIGRldmljZXNcbiAgICAgICAgICAgICAgICAgICAgcGxheXNpbmxpbmU6IDEsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGhpZGUgY29udHJvbHNcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYub3B0aW9ucy5zaG93Q29udG9scykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXllck9wdGlvbnMucGxheWVyVmFycy5pdl9sb2FkX3BvbGljeSA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5wbGF5ZXJWYXJzLm1vZGVzdGJyYW5kaW5nID0gMTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLnBsYXllclZhcnMuY29udHJvbHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXllck9wdGlvbnMucGxheWVyVmFycy5zaG93aW5mbyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5wbGF5ZXJWYXJzLmRpc2FibGVrYiA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZXZlbnRzXG4gICAgICAgICAgICAgICAgbGV0IHl0U3RhcnRlZDtcbiAgICAgICAgICAgICAgICBsZXQgeXRQcm9ncmVzc0ludGVydmFsO1xuICAgICAgICAgICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5ldmVudHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVhZHkoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbXV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5tdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQubXV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLm9wdGlvbnMudm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuc2V0Vm9sdW1lKHNlbGYub3B0aW9ucy52b2x1bWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhdXRvcGxheVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hdXRvcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGxheShzZWxmLm9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgncmVhZHknLCBlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHNlYW1sZXNzIGxvb3BzLCBzZXQgdGhlIGVuZFRpbWUgdG8gMC4xIHNlY29uZHMgbGVzcyB0aGFuIHRoZSB2aWRlbydzIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbmstby92aWRlby13b3JrZXIvaXNzdWVzLzJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMubG9vcCAmJiAhc2VsZi5vcHRpb25zLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWNvbmRzT2Zmc2V0ID0gMC4xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5lbmRUaW1lID0gc2VsZi5wbGF5ZXIuZ2V0RHVyYXRpb24oKSAtIHNlY29uZHNPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZvbHVtZWNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0Vm9sdW1lKCh2b2x1bWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy52b2x1bWUgIT09IHZvbHVtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgndm9sdW1lY2hhbmdlJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uU3RhdGVDaGFuZ2UoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5sb29wICYmIGUuZGF0YSA9PT0gWVQuUGxheWVyU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXkoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXl0U3RhcnRlZCAmJiBlLmRhdGEgPT09IFlULlBsYXllclN0YXRlLlBMQVlJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5dFN0YXJ0ZWQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgnc3RhcnRlZCcsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YSA9PT0gWVQuUGxheWVyU3RhdGUuUExBWUlORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgncGxheScsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YSA9PT0gWVQuUGxheWVyU3RhdGUuUEFVU0VEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlKCdwYXVzZScsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YSA9PT0gWVQuUGxheWVyU3RhdGUuRU5ERUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZpcmUoJ2VuZGVkJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhID09PSBZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeXRQcm9ncmVzc0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZpcmUoJ3RpbWV1cGRhdGUnLCBlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZW5kIG9mIHZpZGVvIGFuZCBwbGF5IGFnYWluIG9yIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5lbmRUaW1lICYmIHNlbGYucGxheWVyLmdldEN1cnJlbnRUaW1lKCkgPj0gc2VsZi5vcHRpb25zLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGxheShzZWxmLm9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh5dFByb2dyZXNzSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEluaXQgPSAhc2VsZi4kdmlkZW87XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0SW5pdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnaWQnLCBzZWxmLnBsYXllcklEKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGlkZGVuRGl2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIgPSBzZWxmLnBsYXllciB8fCBuZXcgd2luZG93LllULlBsYXllcihzZWxmLnBsYXllcklELCBzZWxmLnBsYXllck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kdmlkZW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLnBsYXllcklEKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdmlkZW8gd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnZpZGVvV2lkdGggPSBwYXJzZUludChzZWxmLiR2aWRlby5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIDEwKSB8fCAxMjgwO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZpZGVvSGVpZ2h0ID0gcGFyc2VJbnQoc2VsZi4kdmlkZW8uZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSwgMTApIHx8IDcyMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZpbWVvXG4gICAgICAgICAgICBpZiAoc2VsZi50eXBlID09PSAndmltZW8nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogc2VsZi52aWRlb0lELFxuICAgICAgICAgICAgICAgICAgICBhdXRvcGF1c2U6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICBhdXRvcGxheTogc2VsZi5vcHRpb25zLmF1dG9wbGF5ID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxvb3A6IHNlbGYub3B0aW9ucy5sb29wID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgICAgIG11dGVkOiBzZWxmLm9wdGlvbnMubXV0ZSA/IDEgOiAwLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnZvbHVtZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXllck9wdGlvbnMudm9sdW1lID0gc2VsZi5vcHRpb25zLnZvbHVtZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBoaWRlIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLm9wdGlvbnMuc2hvd0NvbnRvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLmJhZGdlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLmJ5bGluZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5wb3J0cmFpdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy50aXRsZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuJHZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbGF5ZXJPcHRpb25zU3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNlbGYucGxheWVyT3B0aW9ucykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxheWVyT3B0aW9uc1N0cmluZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXJPcHRpb25zU3RyaW5nICs9ICcmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllck9wdGlvbnNTdHJpbmcgKz0gYCR7a2V5fT0ke2VuY29kZVVSSUNvbXBvbmVudChzZWxmLnBsYXllck9wdGlvbnNba2V5XSl9YDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBjcmVhdGUgaWZyYW1lIG1hbnVhbGx5IGJlY2F1c2Ugd2hlbiB3ZSBjcmVhdGUgaXQgdXNpbmcgQVBJXG4gICAgICAgICAgICAgICAgICAgIC8vIGpzIGV2ZW50cyB3b24ndCB0cmlnZ2VycyBhZnRlciBpZnJhbWUgbW92ZWQgdG8gYW5vdGhlciBwbGFjZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLiR2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ2lkJywgc2VsZi5wbGF5ZXJJRCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnc3JjJywgYGh0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8ke3NlbGYudmlkZW9JRH0/JHtwbGF5ZXJPcHRpb25zU3RyaW5nfWApO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ2ZyYW1lYm9yZGVyJywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdtb3phbGxvd2Z1bGxzY3JlZW4nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnYWxsb3dmdWxsc2NyZWVuJywgJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5hcHBlbmRDaGlsZChzZWxmLiR2aWRlbyk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGlkZGVuRGl2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIgPSBzZWxmLnBsYXllciB8fCBuZXcgVmltZW8uUGxheWVyKHNlbGYuJHZpZGVvLCBzZWxmLnBsYXllck9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQgdGltZSBmb3IgYXV0b3BsYXlcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSAmJiBzZWxmLm9wdGlvbnMuYXV0b3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIuc2V0Q3VycmVudFRpbWUoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHZpZGVvIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5nZXRWaWRlb1dpZHRoKCkudGhlbigod2lkdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi52aWRlb1dpZHRoID0gd2lkdGggfHwgMTI4MDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5nZXRWaWRlb0hlaWdodCgpLnRoZW4oKGhlaWdodCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnZpZGVvSGVpZ2h0ID0gaGVpZ2h0IHx8IDcyMDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGV2ZW50c1xuICAgICAgICAgICAgICAgIGxldCB2bVN0YXJ0ZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIub24oJ3RpbWV1cGRhdGUnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZtU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlKCdzdGFydGVkJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2bVN0YXJ0ZWQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlKCd0aW1ldXBkYXRlJywgZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVuZCBvZiB2aWRlbyBhbmQgcGxheSBhZ2FpbiBvciBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5lbmRUaW1lICYmIGUuc2Vjb25kcyA+PSBzZWxmLm9wdGlvbnMuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXkoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYucGxheWVyLm9uKCdwbGF5JywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlKCdwbGF5JywgZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSBzdGFydCB0aW1lIGFuZCBzdGFydCB3aXRoIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuc3RhcnRUaW1lICYmIGUuc2Vjb25kcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5KHNlbGYub3B0aW9ucy5zdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIub24oJ3BhdXNlJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlKCdwYXVzZScsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYucGxheWVyLm9uKCdlbmRlZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgnZW5kZWQnLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5vbignbG9hZGVkJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maXJlKCdyZWFkeScsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYucGxheWVyLm9uKCd2b2x1bWVjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpcmUoJ3ZvbHVtZWNoYW5nZScsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb2NhbFxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkU291cmNlVG9Mb2NhbChlbGVtZW50LCBzcmMsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgIHNvdXJjZS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLiR2aWRlbykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLiR2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdyBjb250cm9sc1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnNob3dDb250b2xzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLiR2aWRlby5jb250cm9scyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBtdXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMubXV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi4kdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuJHZpZGVvLnZvbHVtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi4kdmlkZW8udm9sdW1lID0gc2VsZi5vcHRpb25zLnZvbHVtZSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5sb29wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLiR2aWRlby5sb29wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGF1dG9wbGF5IGVuYWJsZSBvbiBtb2JpbGUgZGV2aWNlc1xuICAgICAgICAgICAgICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ3dlYmtpdC1wbGF5c2lubGluZScsICcnKTtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ2lkJywgc2VsZi5wbGF5ZXJJRCk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5hcHBlbmRDaGlsZChzZWxmLiR2aWRlbyk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGlkZGVuRGl2KTtcblxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzZWxmLnZpZGVvSUQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU291cmNlVG9Mb2NhbChzZWxmLiR2aWRlbywgc2VsZi52aWRlb0lEW2tleV0sIGB2aWRlby8ke2tleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIgPSBzZWxmLnBsYXllciB8fCBzZWxmLiR2aWRlbztcblxuICAgICAgICAgICAgICAgIGxldCBsb2NTdGFydGVkO1xuICAgICAgICAgICAgICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgnc3RhcnRlZCcsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvY1N0YXJ0ZWQgPSAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpcmUoJ3RpbWV1cGRhdGUnLCBlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZW5kIG9mIHZpZGVvIGFuZCBwbGF5IGFnYWluIG9yIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5lbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmVuZFRpbWUgJiYgdGhpcy5jdXJyZW50VGltZSA+PSBzZWxmLm9wdGlvbnMuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBsYXkoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpcmUoJ3BsYXknLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgncGF1c2UnLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgnZW5kZWQnLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHZpZGVvIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgc2VsZi52aWRlb1dpZHRoID0gdGhpcy52aWRlb1dpZHRoIHx8IDEyODA7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudmlkZW9IZWlnaHQgPSB0aGlzLnZpZGVvSGVpZ2h0IHx8IDcyMDtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpcmUoJ3JlYWR5Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXV0b3BsYXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5hdXRvcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5KHNlbGYub3B0aW9ucy5zdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndm9sdW1lY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXRWb2x1bWUoKHZvbHVtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZSgndm9sdW1lY2hhbmdlJywgZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhzZWxmLiR2aWRlbyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHNlbGYucGxheWVySUQgPSBgVmlkZW9Xb3JrZXItJHtzZWxmLklEfWA7XG4gICAgfVxuXG4gICAgbG9hZEFQSSgpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKFlvdXR1YmVBUElhZGRlZCAmJiBWaW1lb0FQSWFkZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3JjID0gJyc7XG5cbiAgICAgICAgLy8gbG9hZCBZb3V0dWJlIEFQSVxuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAneW91dHViZScgJiYgIVlvdXR1YmVBUElhZGRlZCkge1xuICAgICAgICAgICAgWW91dHViZUFQSWFkZGVkID0gMTtcbiAgICAgICAgICAgIHNyYyA9ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS9pZnJhbWVfYXBpJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvYWQgVmltZW8gQVBJXG4gICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICd2aW1lbycgJiYgIVZpbWVvQVBJYWRkZWQpIHtcbiAgICAgICAgICAgIFZpbWVvQVBJYWRkZWQgPSAxO1xuICAgICAgICAgICAgc3JjID0gJ2h0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS9hcGkvcGxheWVyLmpzJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2NyaXB0IGluIGhlYWQgc2VjdGlvblxuICAgICAgICBsZXQgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIGxldCBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgdGFnLnNyYyA9IHNyYztcblxuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG5cbiAgICAgICAgaGVhZCA9IG51bGw7XG4gICAgICAgIHRhZyA9IG51bGw7XG4gICAgfVxuXG4gICAgb25BUElyZWFkeShjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBZb3V0dWJlXG4gICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICd5b3V0dWJlJykge1xuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBnbG9iYWwgWVQgcGxheWVyIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBZVCA9PT0gJ3VuZGVmaW5lZCcgfHwgWVQubG9hZGVkID09PSAwKSAmJiAhbG9hZGluZ1lvdXR1YmVQbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBSZWFkeSBldmVudCBmcm9tIGJlaW5nIGNhbGxlZCB0d2ljZVxuICAgICAgICAgICAgICAgIGxvYWRpbmdZb3V0dWJlUGxheWVyID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZXMgZGVmZXJyZWQgc28sIG90aGVyIHBsYXllcnMga25vdyB3aGVuIHRvIHdhaXQuXG4gICAgICAgICAgICAgICAgd2luZG93Lm9uWW91VHViZUlmcmFtZUFQSVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nWW91dHViZURlZmVyLnJlc29sdmUoJ2RvbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgWVQgPT09ICdvYmplY3QnICYmIFlULmxvYWRlZCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdZb3V0dWJlRGVmZXIuZG9uZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWaW1lb1xuICAgICAgICBpZiAoc2VsZi50eXBlID09PSAndmltZW8nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFZpbWVvID09PSAndW5kZWZpbmVkJyAmJiAhbG9hZGluZ1ZpbWVvUGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZ1ZpbWVvUGxheWVyID0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aW1lb0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFZpbWVvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh2aW1lb0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmdWaW1lb0RlZmVyLnJlc29sdmUoJ2RvbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBWaW1lbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nVmltZW9EZWZlci5kb25lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvY2FsXG4gICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92aWRlby13b3JrZXIvc3JjL3ZpZGVvLXdvcmtlci5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGVzbGludCBuby1jYXNlLWRlY2xhcmF0aW9uczogXCJvZmZcIiAqL1xuaW1wb3J0IGdsb2JhbCBmcm9tICdnbG9iYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBqYXJhbGxheEVsZW1lbnQoamFyYWxsYXggPSBnbG9iYWwuamFyYWxsYXgpIHtcbiAgICBpZiAodHlwZW9mIGphcmFsbGF4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgSmFyYWxsYXggPSBqYXJhbGxheC5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIHJlZGVmaW5lIGRlZmF1bHQgbWV0aG9kc1xuICAgIFtcbiAgICAgICAgJ2luaXRJbWcnLFxuICAgICAgICAnY2FuSW5pdFBhcmFsbGF4JyxcbiAgICAgICAgJ2luaXQnLFxuICAgICAgICAnZGVzdHJveScsXG4gICAgICAgICdjbGlwQ29udGFpbmVyJyxcbiAgICAgICAgJ2NvdmVySW1hZ2UnLFxuICAgICAgICAnaXNWaXNpYmxlJyxcbiAgICAgICAgJ29uU2Nyb2xsJyxcbiAgICAgICAgJ29uUmVzaXplJyxcbiAgICBdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBkZWYgPSBKYXJhbGxheC5wcm90b3R5cGVba2V5XTtcbiAgICAgICAgSmFyYWxsYXgucHJvdG90eXBlW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHMgfHwgW107XG5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdpbml0SW1nJyAmJiBzZWxmLiRpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC1lbGVtZW50JykgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMudHlwZSA9ICdlbGVtZW50JztcbiAgICAgICAgICAgICAgICBzZWxmLnB1cmVPcHRpb25zLnNwZWVkID0gc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtZWxlbWVudCcpIHx8IHNlbGYucHVyZU9wdGlvbnMuc3BlZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnR5cGUgIT09ICdlbGVtZW50Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYucHVyZU9wdGlvbnMudGhyZXNob2xkID0gc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGhyZXNob2xkJykgfHwgJyc7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgICAgICAgICBjb25zdCBzcGVlZEFyciA9IHNlbGYucHVyZU9wdGlvbnMuc3BlZWQuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMuc3BlZWQgPSBzZWxmLnB1cmVPcHRpb25zLnNwZWVkIHx8IDA7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnNwZWVkWSA9IHNwZWVkQXJyWzBdID8gcGFyc2VGbG9hdChzcGVlZEFyclswXSkgOiAwO1xuICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5zcGVlZFggPSBzcGVlZEFyclsxXSA/IHBhcnNlRmxvYXQoc3BlZWRBcnJbMV0pIDogMDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZEFyciA9IHNlbGYucHVyZU9wdGlvbnMudGhyZXNob2xkLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnRocmVzaG9sZFkgPSB0aHJlc2hvbGRBcnJbMF0gPyBwYXJzZUZsb2F0KHRocmVzaG9sZEFyclswXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy50aHJlc2hvbGRYID0gdGhyZXNob2xkQXJyWzFdID8gcGFyc2VGbG9hdCh0aHJlc2hvbGRBcnJbMV0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29uUmVzaXplJzpcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZUcmFuc2Zvcm0gPSBzZWxmLmNzcyhzZWxmLiRpdGVtLCAndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgc2VsZi5jc3Moc2VsZi4kaXRlbSwgeyB0cmFuc2Zvcm06ICcnIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBzZWxmLiRpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuaXRlbURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB5OiByZWN0LnRvcCArIHNlbGYuZ2V0V2luZG93RGF0YSgpLnksXG4gICAgICAgICAgICAgICAgICAgIHg6IHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlbGYuY3NzKHNlbGYuJGl0ZW0sIHsgdHJhbnNmb3JtOiBkZWZUcmFuc2Zvcm0gfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvblNjcm9sbCc6XG4gICAgICAgICAgICAgICAgY29uc3Qgd25kID0gc2VsZi5nZXRXaW5kb3dEYXRhKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyUGVyY2VudCA9ICh3bmQueSArIHduZC5oZWlnaHQgLyAyIC0gc2VsZi5pdGVtRGF0YS55IC0gc2VsZi5pdGVtRGF0YS5oZWlnaHQgLyAyKSAvICh3bmQuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgY29uc3QgbW92ZVkgPSBjZW50ZXJQZXJjZW50ICogc2VsZi5vcHRpb25zLnNwZWVkWTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3ZlWCA9IGNlbnRlclBlcmNlbnQgKiBzZWxmLm9wdGlvbnMuc3BlZWRYO1xuICAgICAgICAgICAgICAgIGxldCBteSA9IG1vdmVZO1xuICAgICAgICAgICAgICAgIGxldCBteCA9IG1vdmVYO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMudGhyZXNob2xkWSAhPT0gbnVsbCAmJiBtb3ZlWSA+IHNlbGYub3B0aW9ucy50aHJlc2hvbGRZKSBteSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy50aHJlc2hvbGRYICE9PSBudWxsICYmIG1vdmVYID4gc2VsZi5vcHRpb25zLnRocmVzaG9sZFgpIG14ID0gMDtcbiAgICAgICAgICAgICAgICBzZWxmLmNzcyhzZWxmLiRpdGVtLCB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7bXh9cHgsJHtteX1weCwwKWAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbml0SW1nJzpcbiAgICAgICAgICAgIGNhc2UgJ2lzVmlzaWJsZSc6XG4gICAgICAgICAgICBjYXNlICdjbGlwQ29udGFpbmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvdmVySW1hZ2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgLy8gbm8gZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2phcmFsbGF4L3NyYy9qYXJhbGxheC1lbGVtZW50LmVzbS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gIH0gZWxzZSB7XG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGJvb2xlYW4gZm9yIFJUTCBzdXBwb3J0XG4gKi9cblxuZnVuY3Rpb24gcnRsKCkge1xuICByZXR1cm4gJCgnaHRtbCcpLmF0dHIoJ2RpcicpID09PSAncnRsJztcbn1cbi8qKlxuICogcmV0dXJucyBhIHJhbmRvbSBiYXNlLTM2IHVpZCB3aXRoIG5hbWVzcGFjaW5nXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBudW1iZXIgb2YgcmFuZG9tIGJhc2UtMzYgZGlnaXRzIGRlc2lyZWQuIEluY3JlYXNlIGZvciBtb3JlIHJhbmRvbSBzdHJpbmdzLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIG5hbWUgb2YgcGx1Z2luIHRvIGJlIGluY29ycG9yYXRlZCBpbiB1aWQsIG9wdGlvbmFsLlxuICogQGRlZmF1bHQge1N0cmluZ30gJycgLSBpZiBubyBwbHVnaW4gbmFtZSBpcyBwcm92aWRlZCwgbm90aGluZyBpcyBhcHBlbmRlZCB0byB0aGUgdWlkLlxuICogQHJldHVybnMge1N0cmluZ30gLSB1bmlxdWUgaWRcbiAqL1xuXG5cbmZ1bmN0aW9uIEdldFlvRGlnaXRzKGxlbmd0aCwgbmFtZXNwYWNlKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCB8fCA2O1xuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnBvdygzNiwgbGVuZ3RoICsgMSkgLSBNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMzYsIGxlbmd0aCkpLnRvU3RyaW5nKDM2KS5zbGljZSgxKSArIChuYW1lc3BhY2UgPyBcIi1cIi5jb25jYXQobmFtZXNwYWNlKSA6ICcnKTtcbn1cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGFzIGEgcmVnZXhwIHBhdHRlcm5cbiAqIEBmdW5jdGlvblxuICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTMxMDc1Mi80MzE3Mzg0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIGVzY2FwZWQgc3RyaW5nXG4gKi9cblxuXG5mdW5jdGlvbiBSZWdFeHBFc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbmVuZCgkZWxlbSkge1xuICB2YXIgdHJhbnNpdGlvbnMgPSB7XG4gICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogJ290cmFuc2l0aW9uZW5kJ1xuICB9O1xuICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgZW5kO1xuXG4gIGZvciAodmFyIHQgaW4gdHJhbnNpdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGVsZW0uc3R5bGVbdF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSB0cmFuc2l0aW9uc1t0XTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcmV0dXJuIGVuZDtcbiAgfSBlbHNlIHtcbiAgICBlbmQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICRlbGVtLnRyaWdnZXJIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgWyRlbGVtXSk7XG4gICAgfSwgMSk7XG4gICAgcmV0dXJuICd0cmFuc2l0aW9uZW5kJztcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm4gYW4gZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yIHdpbmRvdyBsb2FkLlxuICpcbiAqIElmIGAkZWxlbWAgaXMgcGFzc2VkLCBhbiBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBvbiBgJGVsZW1gLiBJZiB3aW5kb3cgaXMgYWxyZWFkeSBsb2FkZWQsIHRoZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZC5cbiAqIElmIGBoYW5kbGVyYCBpcyBwYXNzZWQsIGF0dGFjaCBpdCB0byB0aGUgZXZlbnQgb24gYCRlbGVtYC5cbiAqIENhbGxpbmcgYG9uTG9hZGAgd2l0aG91dCBoYW5kbGVyIGFsbG93cyB5b3UgdG8gZ2V0IHRoZSBldmVudCB0eXBlIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgYmVmb3JlIGF0dGFjaGluZyB0aGUgaGFuZGxlciBieSB5b3Vyc2VsZi5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbXSAkZWxlbSAtIGpRdWVyeSBlbGVtZW50IG9uIHdoaWNoIHRoZSBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBpZiBwYXNzZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbXSBoYW5kbGVyIC0gZnVuY3Rpb24gdG8gYXR0YWNoIHRvIHRoZSBldmVudC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IC0gZXZlbnQgdHlwZSB0aGF0IHNob3VsZCBvciB3aWxsIGJlIHRyaWdnZXJlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9uTG9hZCgkZWxlbSwgaGFuZGxlcikge1xuICB2YXIgZGlkTG9hZCA9IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZSc7XG4gIHZhciBldmVudFR5cGUgPSAoZGlkTG9hZCA/ICdfZGlkTG9hZCcgOiAnbG9hZCcpICsgJy56Zi51dGlsLm9uTG9hZCc7XG5cbiAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgcmV0dXJuICRlbGVtLnRyaWdnZXJIYW5kbGVyKGV2ZW50VHlwZSk7XG4gIH07XG5cbiAgaWYgKCRlbGVtKSB7XG4gICAgaWYgKGhhbmRsZXIpICRlbGVtLm9uZShldmVudFR5cGUsIGhhbmRsZXIpO1xuICAgIGlmIChkaWRMb2FkKSBzZXRUaW1lb3V0KGNiKTtlbHNlICQod2luZG93KS5vbmUoJ2xvYWQnLCBjYik7XG4gIH1cblxuICByZXR1cm4gZXZlbnRUeXBlO1xufVxuLyoqXG4gKiBSZXR1bnMgYW4gaGFuZGxlciBmb3IgdGhlIGBtb3VzZWxlYXZlYCB0aGF0IGlnbm9yZSBkaXNhcHBlYXJlZCBtb3VzZXMuXG4gKlxuICogSWYgdGhlIG1vdXNlIFwiZGlzYXBwZWFyZWRcIiBmcm9tIHRoZSBkb2N1bWVudCAobGlrZSB3aGVuIGdvaW5nIG9uIGEgYnJvd3NlciBVSSBlbGVtZW50LCBTZWUgaHR0cHM6Ly9naXQuaW8vemYtMTE0MTApLFxuICogdGhlIGV2ZW50IGlzIGlnbm9yZWQuXG4gKiAtIElmIHRoZSBgaWdub3JlTGVhdmVXaW5kb3dgIGlzIGB0cnVlYCwgdGhlIGV2ZW50IGlzIGlnbm9yZWQgd2hlbiB0aGUgdXNlciBhY3R1YWxseSBsZWZ0IHRoZSB3aW5kb3dcbiAqICAgKGxpa2UgYnkgc3dpdGNoaW5nIHRvIGFuIG90aGVyIHdpbmRvdyB3aXRoIFtBbHRdK1tUYWJdKS5cbiAqIC0gSWYgdGhlIGBpZ25vcmVSZWFwcGVhcmAgaXMgYHRydWVgLCB0aGUgZXZlbnQgd2lsbCBiZSBpZ25vcmVkIHdoZW4gdGhlIG1vdXNlIHdpbGwgcmVhcHBlYXIgbGF0ZXIgb24gdGhlIGRvY3VtZW50XG4gKiAgIG91dHNpZGUgb2YgdGhlIGVsZW1lbnQgaXQgbGVmdC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbXSBoYW5kbGVyIC0gaGFuZGxlciBmb3IgdGhlIGZpbHRlcmVkIGBtb3VzZWxlYXZlYCBldmVudCB0byB3YXRjaC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbXSBvcHRpb25zIC0gb2JqZWN0IG9mIG9wdGlvbnM6XG4gKiAtIHtCb29sZWFufSBbZmFsc2VdIGlnbm9yZUxlYXZlV2luZG93IC0gYWxzbyBpZ25vcmUgd2hlbiB0aGUgdXNlciBzd2l0Y2hlZCB3aW5kb3dzLlxuICogLSB7Qm9vbGVhbn0gW2ZhbHNlXSBpZ25vcmVSZWFwcGVhciAtIGFsc28gaWdub3JlIHdoZW4gdGhlIG1vdXNlIHJlYXBwZWFyZWQgb3V0c2lkZSBvZiB0aGUgZWxlbWVudCBpdCBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIGZpbHRlcmVkIGhhbmRsZXIgdG8gdXNlIHRvIGxpc3RlbiBvbiB0aGUgYG1vdXNlbGVhdmVgIGV2ZW50LlxuICovXG5cblxuZnVuY3Rpb24gaWdub3JlTW91c2VkaXNhcHBlYXIoaGFuZGxlcikge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICBfcmVmJGlnbm9yZUxlYXZlV2luZG8gPSBfcmVmLmlnbm9yZUxlYXZlV2luZG93LFxuICAgICAgaWdub3JlTGVhdmVXaW5kb3cgPSBfcmVmJGlnbm9yZUxlYXZlV2luZG8gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpZ25vcmVMZWF2ZVdpbmRvLFxuICAgICAgX3JlZiRpZ25vcmVSZWFwcGVhciA9IF9yZWYuaWdub3JlUmVhcHBlYXIsXG4gICAgICBpZ25vcmVSZWFwcGVhciA9IF9yZWYkaWdub3JlUmVhcHBlYXIgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpZ25vcmVSZWFwcGVhcjtcblxuICByZXR1cm4gZnVuY3Rpb24gbGVhdmVFdmVudEhhbmRsZXIoZUxlYXZlKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrID0gaGFuZGxlci5iaW5kLmFwcGx5KGhhbmRsZXIsIFt0aGlzLCBlTGVhdmVdLmNvbmNhdChyZXN0KSk7IC8vIFRoZSBtb3VzZSBsZWZ0OiBjYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBpZiB0aGUgbW91c2UgZW50ZXJlZCBlbHNld2hlcmVcblxuICAgIGlmIChlTGVhdmUucmVsYXRlZFRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIHRoZSBtb3VzZSBhY3R1YWxseSBsZWZ0IHRoZSB3aW5kb3cuXG4gICAgLy8gSW4gZmlyZWZveCBpZiB0aGUgdXNlciBzd2l0Y2hlZCBiZXR3ZWVuIHdpbmRvd3MsIHRoZSB3aW5kb3cgc2lsbCBoYXZlIHRoZSBmb2N1cyBieSB0aGUgdGltZVxuICAgIC8vIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuIFdlIGhhdmUgdG8gZGVib3VuY2UgdGhlIGV2ZW50IHRvIHRlc3QgdGhpcyBjYXNlLlxuXG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGxlYXZlRXZlbnREZWJvdW5jZXIoKSB7XG4gICAgICBpZiAoIWlnbm9yZUxlYXZlV2luZG93ICYmIGRvY3VtZW50Lmhhc0ZvY3VzICYmICFkb2N1bWVudC5oYXNGb2N1cygpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSAvLyBPdGhlcndpc2UsIHdhaXQgZm9yIHRoZSBtb3VzZSB0byByZWVhcGVhciBvdXRzaWRlIG9mIHRoZSBlbGVtZW50LFxuXG5cbiAgICAgIGlmICghaWdub3JlUmVhcHBlYXIpIHtcbiAgICAgICAgJChkb2N1bWVudCkub25lKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gcmVlbnRlckV2ZW50SGFuZGxlcihlUmVlbnRlcikge1xuICAgICAgICAgIGlmICghJChlTGVhdmUuY3VycmVudFRhcmdldCkuaGFzKGVSZWVudGVyLnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBGaWxsIHdoZXJlIHRoZSBtb3VzZSBmaW5hbGx5IGVudGVyZWQuXG4gICAgICAgICAgICBlTGVhdmUucmVsYXRlZFRhcmdldCA9IGVSZWVudGVyLnRhcmdldDtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfTtcbn1cblxudmFyIGZvdW5kYXRpb25fY29yZV91dGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgcnRsOiBydGwsXG4gIEdldFlvRGlnaXRzOiBHZXRZb0RpZ2l0cyxcbiAgUmVnRXhwRXNjYXBlOiBSZWdFeHBFc2NhcGUsXG4gIHRyYW5zaXRpb25lbmQ6IHRyYW5zaXRpb25lbmQsXG4gIG9uTG9hZDogb25Mb2FkLFxuICBpZ25vcmVNb3VzZWRpc2FwcGVhcjogaWdub3JlTW91c2VkaXNhcHBlYXJcbn0pO1xuXG4vLyBBdXRob3JzICYgY29weXJpZ2h0KGMpIDIwMTI6IFNjb3R0IEplaGwsIFBhdWwgSXJpc2gsIE5pY2hvbGFzIFpha2FzLCBEYXZpZCBLbmlnaHQuIE1JVCBsaWNlbnNlXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbndpbmRvdy5tYXRjaE1lZGlhIHx8ICh3aW5kb3cubWF0Y2hNZWRpYSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgc3R5bGVNZWRpYSA9IHdpbmRvdy5zdHlsZU1lZGlhIHx8IHdpbmRvdy5tZWRpYTsgLy8gRm9yIHRob3NlIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtYXRjaE1lZGl1bVxuXG4gIGlmICghc3R5bGVNZWRpYSkge1xuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksXG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXSxcbiAgICAgICAgaW5mbyA9IG51bGw7XG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgc3R5bGUuaWQgPSAnbWF0Y2htZWRpYWpzLXRlc3QnO1xuXG4gICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHNjcmlwdCk7XG4gICAgfSAvLyAnc3R5bGUuY3VycmVudFN0eWxlJyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICd3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZScgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuXG5cbiAgICBpbmZvID0gJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdyAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSwgbnVsbCkgfHwgc3R5bGUuY3VycmVudFN0eWxlO1xuICAgIHN0eWxlTWVkaWEgPSB7XG4gICAgICBtYXRjaE1lZGl1bTogZnVuY3Rpb24gbWF0Y2hNZWRpdW0obWVkaWEpIHtcbiAgICAgICAgdmFyIHRleHQgPSAnQG1lZGlhICcgKyBtZWRpYSArICd7ICNtYXRjaG1lZGlhanMtdGVzdCB7IHdpZHRoOiAxcHg7IH0gfSc7IC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuXG4gICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIH0gLy8gVGVzdCBpZiBtZWRpYSBxdWVyeSBpcyB0cnVlIG9yIGZhbHNlXG5cblxuICAgICAgICByZXR1cm4gaW5mby53aWR0aCA9PT0gJzFweCc7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAobWVkaWEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hlczogc3R5bGVNZWRpYS5tYXRjaE1lZGl1bShtZWRpYSB8fCAnYWxsJyksXG4gICAgICBtZWRpYTogbWVkaWEgfHwgJ2FsbCdcbiAgICB9O1xuICB9O1xufSgpKTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIE1lZGlhUXVlcnkgPSB7XG4gIHF1ZXJpZXM6IFtdLFxuICBjdXJyZW50OiAnJyxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1lZGlhIHF1ZXJ5IGhlbHBlciwgYnkgZXh0cmFjdGluZyB0aGUgYnJlYWtwb2ludCBsaXN0IGZyb20gdGhlIENTUyBhbmQgYWN0aXZhdGluZyB0aGUgYnJlYWtwb2ludCB3YXRjaGVyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0OiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyICRtZXRhID0gJCgnbWV0YS5mb3VuZGF0aW9uLW1xJyk7XG5cbiAgICBpZiAoISRtZXRhLmxlbmd0aCkge1xuICAgICAgJCgnPG1ldGEgY2xhc3M9XCJmb3VuZGF0aW9uLW1xXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCk7XG4gICAgfVxuXG4gICAgdmFyIGV4dHJhY3RlZFN0eWxlcyA9ICQoJy5mb3VuZGF0aW9uLW1xJykuY3NzKCdmb250LWZhbWlseScpO1xuICAgIHZhciBuYW1lZFF1ZXJpZXM7XG4gICAgbmFtZWRRdWVyaWVzID0gcGFyc2VTdHlsZVRvT2JqZWN0KGV4dHJhY3RlZFN0eWxlcyk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZWRRdWVyaWVzKSB7XG4gICAgICBpZiAobmFtZWRRdWVyaWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgc2VsZi5xdWVyaWVzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB2YWx1ZTogXCJvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogXCIuY29uY2F0KG5hbWVkUXVlcmllc1trZXldLCBcIilcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcblxuICAgIHRoaXMuX3dhdGNoZXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gaXMgYXQgbGVhc3QgYXMgd2lkZSBhcyBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGJyZWFrcG9pbnQgbWF0Y2hlcywgYGZhbHNlYCBpZiBpdCdzIHNtYWxsZXIuXG4gICAqL1xuICBhdExlYXN0OiBmdW5jdGlvbiBhdExlYXN0KHNpemUpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLmdldChzaXplKTtcblxuICAgIGlmIChxdWVyeSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KS5tYXRjaGVzO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gbWF0Y2hlcyB0byBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gY2hlY2ssIGVpdGhlciAnc21hbGwgb25seScgb3IgJ3NtYWxsJy4gT21pdHRpbmcgJ29ubHknIGZhbGxzIGJhY2sgdG8gdXNpbmcgYXRMZWFzdCgpIG1ldGhvZC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYnJlYWtwb2ludCBtYXRjaGVzLCBgZmFsc2VgIGlmIGl0IGRvZXMgbm90LlxuICAgKi9cbiAgaXM6IGZ1bmN0aW9uIGlzKHNpemUpIHtcbiAgICBzaXplID0gc2l6ZS50cmltKCkuc3BsaXQoJyAnKTtcblxuICAgIGlmIChzaXplLmxlbmd0aCA+IDEgJiYgc2l6ZVsxXSA9PT0gJ29ubHknKSB7XG4gICAgICBpZiAoc2l6ZVswXSA9PT0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKSkgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmF0TGVhc3Qoc2l6ZVswXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtZWRpYSBxdWVyeSBvZiBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IC0gVGhlIG1lZGlhIHF1ZXJ5IG9mIHRoZSBicmVha3BvaW50LCBvciBgbnVsbGAgaWYgdGhlIGJyZWFrcG9pbnQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGdldDogZnVuY3Rpb24gZ2V0KHNpemUpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucXVlcmllcykge1xuICAgICAgaWYgKHRoaXMucXVlcmllcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJpZXNbaV07XG4gICAgICAgIGlmIChzaXplID09PSBxdWVyeS5uYW1lKSByZXR1cm4gcXVlcnkudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCBuYW1lIGJ5IHRlc3RpbmcgZXZlcnkgYnJlYWtwb2ludCBhbmQgcmV0dXJuaW5nIHRoZSBsYXN0IG9uZSB0byBtYXRjaCAodGhlIGJpZ2dlc3Qgb25lKS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGN1cnJlbnQgYnJlYWtwb2ludC5cbiAgICovXG4gIF9nZXRDdXJyZW50U2l6ZTogZnVuY3Rpb24gX2dldEN1cnJlbnRTaXplKCkge1xuICAgIHZhciBtYXRjaGVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnF1ZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1tpXTtcblxuICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5LnZhbHVlKS5tYXRjaGVzKSB7XG4gICAgICAgIG1hdGNoZWQgPSBxdWVyeTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZihtYXRjaGVkKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtYXRjaGVkLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBicmVha3BvaW50IHdhdGNoZXIsIHdoaWNoIGZpcmVzIGFuIGV2ZW50IG9uIHRoZSB3aW5kb3cgd2hlbmV2ZXIgdGhlIGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd2F0Y2hlcjogZnVuY3Rpb24gX3dhdGNoZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS56Zi5tZWRpYXF1ZXJ5Jykub24oJ3Jlc2l6ZS56Zi5tZWRpYXF1ZXJ5JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5ld1NpemUgPSBfdGhpcy5fZ2V0Q3VycmVudFNpemUoKSxcbiAgICAgICAgICBjdXJyZW50U2l6ZSA9IF90aGlzLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChuZXdTaXplICE9PSBjdXJyZW50U2l6ZSkge1xuICAgICAgICAvLyBDaGFuZ2UgdGhlIGN1cnJlbnQgbWVkaWEgcXVlcnlcbiAgICAgICAgX3RoaXMuY3VycmVudCA9IG5ld1NpemU7IC8vIEJyb2FkY2FzdCB0aGUgbWVkaWEgcXVlcnkgY2hhbmdlIG9uIHRoZSB3aW5kb3dcblxuICAgICAgICAkKHdpbmRvdykudHJpZ2dlcignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgW25ld1NpemUsIGN1cnJlbnRTaXplXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07IC8vIFRoYW5rIHlvdTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmdcblxuZnVuY3Rpb24gcGFyc2VTdHlsZVRvT2JqZWN0KHN0cikge1xuICB2YXIgc3R5bGVPYmplY3QgPSB7fTtcblxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gIH1cblxuICBzdHIgPSBzdHIudHJpbSgpLnNsaWNlKDEsIC0xKTsgLy8gYnJvd3NlcnMgcmUtcXVvdGUgc3RyaW5nIHN0eWxlIHZhbHVlc1xuXG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG5cbiAgc3R5bGVPYmplY3QgPSBzdHIuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgcGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBwYXJ0c1swXTtcbiAgICB2YXIgdmFsID0gcGFydHNbMV07XG4gICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7IC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG4gICAgLy8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuXG4gICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG5cbiAgICBpZiAoIXJldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXRba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0W2tleV0pKSB7XG4gICAgICByZXRba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtrZXldID0gW3JldFtrZXldLCB2YWxdO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIHN0eWxlT2JqZWN0O1xufVxuXG52YXIgRk9VTkRBVElPTl9WRVJTSU9OID0gJzYuNS4xJzsgLy8gR2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XG4vLyBUaGlzIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3csIG9yIHVzZWQgYXMgYSBtb2R1bGUgZm9yIEFNRC9Ccm93c2VyaWZ5XG5cbnZhciBGb3VuZGF0aW9uID0ge1xuICB2ZXJzaW9uOiBGT1VOREFUSU9OX1ZFUlNJT04sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBpbml0aWFsaXplZCBwbHVnaW5zLlxuICAgKi9cbiAgX3BsdWdpbnM6IHt9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgZ2VuZXJhdGVkIHVuaXF1ZSBpZHMgZm9yIHBsdWdpbiBpbnN0YW5jZXNcbiAgICovXG4gIF91dWlkczogW10sXG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBGb3VuZGF0aW9uIHBsdWdpbiwgYWRkaW5nIGl0IHRvIHRoZSBgRm91bmRhdGlvbmAgbmFtZXNwYWNlIGFuZCB0aGUgbGlzdCBvZiBwbHVnaW5zIHRvIGluaXRpYWxpemUgd2hlbiByZWZsb3dpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHBsdWdpbi5cbiAgICovXG4gIHBsdWdpbjogZnVuY3Rpb24gcGx1Z2luKF9wbHVnaW4sIG5hbWUpIHtcbiAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIGFkZGluZyB0byBnbG9iYWwgRm91bmRhdGlvbiBvYmplY3RcbiAgICAvLyBFeGFtcGxlczogRm91bmRhdGlvbi5SZXZlYWwsIEZvdW5kYXRpb24uT2ZmQ2FudmFzXG4gICAgdmFyIGNsYXNzTmFtZSA9IG5hbWUgfHwgZnVuY3Rpb25OYW1lKF9wbHVnaW4pOyAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIHN0b3JpbmcgdGhlIHBsdWdpbiwgYWxzbyB1c2VkIHRvIGNyZWF0ZSB0aGUgaWRlbnRpZnlpbmcgZGF0YSBhdHRyaWJ1dGUgZm9yIHRoZSBwbHVnaW5cbiAgICAvLyBFeGFtcGxlczogZGF0YS1yZXZlYWwsIGRhdGEtb2ZmLWNhbnZhc1xuXG4gICAgdmFyIGF0dHJOYW1lID0gaHlwaGVuYXRlKGNsYXNzTmFtZSk7IC8vIEFkZCB0byB0aGUgRm91bmRhdGlvbiBvYmplY3QgYW5kIHRoZSBwbHVnaW5zIGxpc3QgKGZvciByZWZsb3dpbmcpXG5cbiAgICB0aGlzLl9wbHVnaW5zW2F0dHJOYW1lXSA9IHRoaXNbY2xhc3NOYW1lXSA9IF9wbHVnaW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBQb3B1bGF0ZXMgdGhlIF91dWlkcyBhcnJheSB3aXRoIHBvaW50ZXJzIHRvIGVhY2ggaW5kaXZpZHVhbCBwbHVnaW4gaW5zdGFuY2UuXG4gICAqIEFkZHMgdGhlIGB6ZlBsdWdpbmAgZGF0YS1hdHRyaWJ1dGUgdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGVkIHBsdWdpbnMgdG8gYWxsb3cgdXNlIG9mICQoc2VsZWN0b3IpLmZvdW5kYXRpb24obWV0aG9kKSBjYWxscy5cbiAgICogQWxzbyBmaXJlcyB0aGUgaW5pdGlhbGl6YXRpb24gZXZlbnQgZm9yIGVhY2ggcGx1Z2luLCBjb25zb2xpZGF0aW5nIHJlcGV0aXRpdmUgY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4sIHBhc3NlZCBhcyBhIGNhbWVsQ2FzZWQgc3RyaW5nLlxuICAgKiBAZmlyZXMgUGx1Z2luI2luaXRcbiAgICovXG4gIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiByZWdpc3RlclBsdWdpbihwbHVnaW4sIG5hbWUpIHtcbiAgICB2YXIgcGx1Z2luTmFtZSA9IG5hbWUgPyBoeXBoZW5hdGUobmFtZSkgOiBmdW5jdGlvbk5hbWUocGx1Z2luLmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO1xuICAgIHBsdWdpbi51dWlkID0gR2V0WW9EaWdpdHMoNiwgcGx1Z2luTmFtZSk7XG5cbiAgICBpZiAoIXBsdWdpbi4kZWxlbWVudC5hdHRyKFwiZGF0YS1cIi5jb25jYXQocGx1Z2luTmFtZSkpKSB7XG4gICAgICBwbHVnaW4uJGVsZW1lbnQuYXR0cihcImRhdGEtXCIuY29uY2F0KHBsdWdpbk5hbWUpLCBwbHVnaW4udXVpZCk7XG4gICAgfVxuXG4gICAgaWYgKCFwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nKSkge1xuICAgICAgcGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgcGx1Z2luKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBpbml0aWFsaXplZC5cbiAgICAgKiBAZXZlbnQgUGx1Z2luI2luaXRcbiAgICAgKi9cblxuXG4gICAgcGx1Z2luLiRlbGVtZW50LnRyaWdnZXIoXCJpbml0LnpmLlwiLmNvbmNhdChwbHVnaW5OYW1lKSk7XG5cbiAgICB0aGlzLl91dWlkcy5wdXNoKHBsdWdpbi51dWlkKTtcblxuICAgIHJldHVybjtcbiAgfSxcblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIFJlbW92ZXMgdGhlIHBsdWdpbnMgdXVpZCBmcm9tIHRoZSBfdXVpZHMgYXJyYXkuXG4gICAqIFJlbW92ZXMgdGhlIHpmUGx1Z2luIGRhdGEgYXR0cmlidXRlLCBhcyB3ZWxsIGFzIHRoZSBkYXRhLXBsdWdpbi1uYW1lIGF0dHJpYnV0ZS5cbiAgICogQWxzbyBmaXJlcyB0aGUgZGVzdHJveWVkIGV2ZW50IGZvciB0aGUgcGx1Z2luLCBjb25zb2xpZGF0aW5nIHJlcGV0aXRpdmUgY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxuICAgKiBAZmlyZXMgUGx1Z2luI2Rlc3Ryb3llZFxuICAgKi9cbiAgdW5yZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gdW5yZWdpc3RlclBsdWdpbihwbHVnaW4pIHtcbiAgICB2YXIgcGx1Z2luTmFtZSA9IGh5cGhlbmF0ZShmdW5jdGlvbk5hbWUocGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykuY29uc3RydWN0b3IpKTtcblxuICAgIHRoaXMuX3V1aWRzLnNwbGljZSh0aGlzLl91dWlkcy5pbmRleE9mKHBsdWdpbi51dWlkKSwgMSk7XG5cbiAgICBwbHVnaW4uJGVsZW1lbnQucmVtb3ZlQXR0cihcImRhdGEtXCIuY29uY2F0KHBsdWdpbk5hbWUpKS5yZW1vdmVEYXRhKCd6ZlBsdWdpbicpXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAgICAgKiBAZXZlbnQgUGx1Z2luI2Rlc3Ryb3llZFxuICAgICAqL1xuICAgIC50cmlnZ2VyKFwiZGVzdHJveWVkLnpmLlwiLmNvbmNhdChwbHVnaW5OYW1lKSk7XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHBsdWdpbikge1xuICAgICAgcGx1Z2luW3Byb3BdID0gbnVsbDsgLy9jbGVhbiB1cCBzY3JpcHQgdG8gcHJlcCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSxcblxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIENhdXNlcyBvbmUgb3IgbW9yZSBhY3RpdmUgcGx1Z2lucyB0byByZS1pbml0aWFsaXplLCByZXNldHRpbmcgZXZlbnQgbGlzdGVuZXJzLCByZWNhbGN1bGF0aW5nIHBvc2l0aW9ucywgZXRjLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGx1Z2lucyAtIG9wdGlvbmFsIHN0cmluZyBvZiBhbiBpbmRpdmlkdWFsIHBsdWdpbiBrZXksIGF0dGFpbmVkIGJ5IGNhbGxpbmcgYCQoZWxlbWVudCkuZGF0YSgncGx1Z2luTmFtZScpYCwgb3Igc3RyaW5nIG9mIGEgcGx1Z2luIGNsYXNzIGkuZS4gYCdkcm9wZG93bidgXG4gICAqIEBkZWZhdWx0IElmIG5vIGFyZ3VtZW50IGlzIHBhc3NlZCwgcmVmbG93IGFsbCBjdXJyZW50bHkgYWN0aXZlIHBsdWdpbnMuXG4gICAqL1xuICByZUluaXQ6IGZ1bmN0aW9uIHJlSW5pdChwbHVnaW5zKSB7XG4gICAgdmFyIGlzSlEgPSBwbHVnaW5zIGluc3RhbmNlb2YgJDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNKUSkge1xuICAgICAgICBwbHVnaW5zLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQodGhpcykuZGF0YSgnemZQbHVnaW4nKS5faW5pdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0eXBlID0gX3R5cGVvZihwbHVnaW5zKSxcbiAgICAgICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgIGZucyA9IHtcbiAgICAgICAgICAnb2JqZWN0JzogZnVuY3Rpb24gb2JqZWN0KHBsZ3MpIHtcbiAgICAgICAgICAgIHBsZ3MuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICBwID0gaHlwaGVuYXRlKHApO1xuICAgICAgICAgICAgICAkKCdbZGF0YS0nICsgcCArICddJykuZm91bmRhdGlvbignX2luaXQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ3N0cmluZyc6IGZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICAgICAgICAgIHBsdWdpbnMgPSBoeXBoZW5hdGUocGx1Z2lucyk7XG4gICAgICAgICAgICAkKCdbZGF0YS0nICsgcGx1Z2lucyArICddJykuZm91bmRhdGlvbignX2luaXQnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICd1bmRlZmluZWQnOiBmdW5jdGlvbiB1bmRlZmluZWQoKSB7XG4gICAgICAgICAgICB0aGlzWydvYmplY3QnXShPYmplY3Qua2V5cyhfdGhpcy5fcGx1Z2lucykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmbnNbdHlwZV0ocGx1Z2lucyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBwbHVnaW5zIG9uIGFueSBlbGVtZW50cyB3aXRoaW4gYGVsZW1gIChhbmQgYGVsZW1gIGl0c2VsZikgdGhhdCBhcmVuJ3QgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgdG8gY2hlY2sgaW5zaWRlLiBBbHNvIGNoZWNrcyB0aGUgZWxlbWVudCBpdHNlbGYsIHVubGVzcyBpdCdzIHRoZSBgZG9jdW1lbnRgIG9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBsdWdpbnMgLSBBIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplLiBMZWF2ZSB0aGlzIG91dCB0byBpbml0aWFsaXplIGV2ZXJ5dGhpbmcuXG4gICAqL1xuICByZWZsb3c6IGZ1bmN0aW9uIHJlZmxvdyhlbGVtLCBwbHVnaW5zKSB7XG4gICAgLy8gSWYgcGx1Z2lucyBpcyB1bmRlZmluZWQsIGp1c3QgZ3JhYiBldmVyeXRoaW5nXG4gICAgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcGx1Z2lucyA9IE9iamVjdC5rZXlzKHRoaXMuX3BsdWdpbnMpO1xuICAgIH0gLy8gSWYgcGx1Z2lucyBpcyBhIHN0cmluZywgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIG9uZSBpdGVtXG4gICAgZWxzZSBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBsdWdpbnMgPSBbcGx1Z2luc107XG4gICAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBwbHVnaW5cblxuXG4gICAgJC5lYWNoKHBsdWdpbnMsIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGx1Z2luXG4gICAgICB2YXIgcGx1Z2luID0gX3RoaXMuX3BsdWdpbnNbbmFtZV07IC8vIExvY2FsaXplIHRoZSBzZWFyY2ggdG8gYWxsIGVsZW1lbnRzIGluc2lkZSBlbGVtLCBhcyB3ZWxsIGFzIGVsZW0gaXRzZWxmLCB1bmxlc3MgZWxlbSA9PT0gZG9jdW1lbnRcblxuICAgICAgdmFyICRlbGVtID0gJChlbGVtKS5maW5kKCdbZGF0YS0nICsgbmFtZSArICddJykuYWRkQmFjaygnW2RhdGEtJyArIG5hbWUgKyAnXScpOyAvLyBGb3IgZWFjaCBwbHVnaW4gZm91bmQsIGluaXRpYWxpemUgaXRcblxuICAgICAgJGVsZW0uZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWwgPSAkKHRoaXMpLFxuICAgICAgICAgICAgb3B0cyA9IHt9OyAvLyBEb24ndCBkb3VibGUtZGlwIG9uIHBsdWdpbnNcblxuICAgICAgICBpZiAoJGVsLmRhdGEoJ3pmUGx1Z2luJykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byBpbml0aWFsaXplIFwiICsgbmFtZSArIFwiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpKSB7XG4gICAgICAgICAgdmFyIHRoaW5nID0gJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IGUuc3BsaXQoJzonKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbC50cmltKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcHRbMF0pIG9wdHNbb3B0WzBdXSA9IHBhcnNlVmFsdWUob3B0WzFdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgJGVsLmRhdGEoJ3pmUGx1Z2luJywgbmV3IHBsdWdpbigkKHRoaXMpLCBvcHRzKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0Rm5OYW1lOiBmdW5jdGlvbk5hbWUsXG4gIGFkZFRvSnF1ZXJ5OiBmdW5jdGlvbiBhZGRUb0pxdWVyeSgkJCQxKSB7XG4gICAgLy8gVE9ETzogY29uc2lkZXIgbm90IG1ha2luZyB0aGlzIGEgalF1ZXJ5IGZ1bmN0aW9uXG4gICAgLy8gVE9ETzogbmVlZCB3YXkgdG8gcmVmbG93IHZzLiByZS1pbml0aWFsaXplXG5cbiAgICAvKipcbiAgICAgKiBUaGUgRm91bmRhdGlvbiBqUXVlcnkgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBtZXRob2QgLSBBbiBhY3Rpb24gdG8gcGVyZm9ybSBvbiB0aGUgY3VycmVudCBqUXVlcnkgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBmb3VuZGF0aW9uID0gZnVuY3Rpb24gZm91bmRhdGlvbihtZXRob2QpIHtcbiAgICAgIHZhciB0eXBlID0gX3R5cGVvZihtZXRob2QpLFxuICAgICAgICAgICRub0pTID0gJCQkMSgnLm5vLWpzJyk7XG5cbiAgICAgIGlmICgkbm9KUy5sZW5ndGgpIHtcbiAgICAgICAgJG5vSlMucmVtb3ZlQ2xhc3MoJ25vLWpzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvL25lZWRzIHRvIGluaXRpYWxpemUgdGhlIEZvdW5kYXRpb24gb2JqZWN0LCBvciBhbiBpbmRpdmlkdWFsIHBsdWdpbi5cbiAgICAgICAgTWVkaWFRdWVyeS5faW5pdCgpO1xuXG4gICAgICAgIEZvdW5kYXRpb24ucmVmbG93KHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvL2FuIGluZGl2aWR1YWwgbWV0aG9kIHRvIGludm9rZSBvbiBhIHBsdWdpbiBvciBncm91cCBvZiBwbHVnaW5zXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy9jb2xsZWN0IGFsbCB0aGUgYXJndW1lbnRzLCBpZiBuZWNlc3NhcnlcblxuICAgICAgICB2YXIgcGx1Z0NsYXNzID0gdGhpcy5kYXRhKCd6ZlBsdWdpbicpOyAvL2RldGVybWluZSB0aGUgY2xhc3Mgb2YgcGx1Z2luXG5cbiAgICAgICAgaWYgKHR5cGVvZiBwbHVnQ2xhc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwbHVnQ2xhc3NbbWV0aG9kXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvL21ha2Ugc3VyZSBib3RoIHRoZSBjbGFzcyBhbmQgbWV0aG9kIGV4aXN0XG4gICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvL2lmIHRoZXJlJ3Mgb25seSBvbmUsIGNhbGwgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseShwbHVnQ2xhc3MsIGFyZ3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGxvb3AgdGhyb3VnaCB0aGUgalF1ZXJ5IGNvbGxlY3Rpb24gYW5kIGludm9rZSB0aGUgbWV0aG9kIG9uIGVhY2hcbiAgICAgICAgICAgICAgcGx1Z0NsYXNzW21ldGhvZF0uYXBwbHkoJCQkMShlbCkuZGF0YSgnemZQbHVnaW4nKSwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9lcnJvciBmb3Igbm8gY2xhc3Mgb3Igbm8gbWV0aG9kXG4gICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiV2UncmUgc29ycnksICdcIiArIG1ldGhvZCArIFwiJyBpcyBub3QgYW4gYXZhaWxhYmxlIG1ldGhvZCBmb3IgXCIgKyAocGx1Z0NsYXNzID8gZnVuY3Rpb25OYW1lKHBsdWdDbGFzcykgOiAndGhpcyBlbGVtZW50JykgKyAnLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2Vycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50IHR5cGVcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIldlJ3JlIHNvcnJ5LCBcIi5jb25jYXQodHlwZSwgXCIgaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyLiBZb3UgbXVzdCB1c2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBtZXRob2QgeW91IHdpc2ggdG8gaW52b2tlLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAkJCQxLmZuLmZvdW5kYXRpb24gPSBmb3VuZGF0aW9uO1xuICAgIHJldHVybiAkJCQxO1xuICB9XG59O1xuRm91bmRhdGlvbi51dGlsID0ge1xuICAvKipcbiAgICogRnVuY3Rpb24gZm9yIGFwcGx5aW5nIGEgZGVib3VuY2UgZWZmZWN0IHRvIGEgZnVuY3Rpb24gY2FsbC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYXQgZW5kIG9mIHRpbWVvdXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRpbWUgaW4gbXMgdG8gZGVsYXkgdGhlIGNhbGwgb2YgYGZ1bmNgLlxuICAgKiBAcmV0dXJucyBmdW5jdGlvblxuICAgKi9cbiAgdGhyb3R0bGU6IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIGRlbGF5KSB7XG4gICAgdmFyIHRpbWVyID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIGlmICh0aW1lciA9PT0gbnVsbCkge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbndpbmRvdy5Gb3VuZGF0aW9uID0gRm91bmRhdGlvbjsgLy8gUG9seWZpbGwgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuXG4oZnVuY3Rpb24gKCkge1xuICBpZiAoIURhdGUubm93IHx8ICF3aW5kb3cuRGF0ZS5ub3cpIHdpbmRvdy5EYXRlLm5vdyA9IERhdGUubm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcbiAgdmFyIHZlbmRvcnMgPSBbJ3dlYmtpdCcsICdtb3onXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK2kpIHtcbiAgICB2YXIgdnAgPSB2ZW5kb3JzW2ldO1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdnAgKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZwICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd2luZG93W3ZwICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICB9XG5cbiAgaWYgKC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIHZhciBuZXh0VGltZSA9IE1hdGgubWF4KGxhc3RUaW1lICsgMTYsIG5vdyk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKGxhc3RUaW1lID0gbmV4dFRpbWUpO1xuICAgICAgfSwgbmV4dFRpbWUgLSBub3cpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjbGVhclRpbWVvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIFBvbHlmaWxsIGZvciBwZXJmb3JtYW5jZS5ub3csIHJlcXVpcmVkIGJ5IHJBRlxuICAgKi9cblxuXG4gIGlmICghd2luZG93LnBlcmZvcm1hbmNlIHx8ICF3aW5kb3cucGVyZm9ybWFuY2Uubm93KSB7XG4gICAgd2luZG93LnBlcmZvcm1hbmNlID0ge1xuICAgICAgc3RhcnQ6IERhdGUubm93KCksXG4gICAgICBub3c6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pKCk7XG5cbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAob1RoaXMpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxuICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgZk5PUCA9IGZ1bmN0aW9uIGZOT1AoKSB7fSxcbiAgICAgICAgZkJvdW5kID0gZnVuY3Rpb24gZkJvdW5kKCkge1xuICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgPyB0aGlzIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xuICAgICAgLy8gbmF0aXZlIGZ1bmN0aW9ucyBkb24ndCBoYXZlIGEgcHJvdG90eXBlXG4gICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgIH1cblxuICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuICAgIHJldHVybiBmQm91bmQ7XG4gIH07XG59IC8vIFBvbHlmaWxsIHRvIGdldCB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGluIElFOVxuXG5cbmZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmbikge1xuICBpZiAodHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBmdW5jTmFtZVJlZ2V4ID0gL2Z1bmN0aW9uXFxzKFteKF17MSx9KVxcKC87XG4gICAgdmFyIHJlc3VsdHMgPSBmdW5jTmFtZVJlZ2V4LmV4ZWMoZm4udG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGggPiAxID8gcmVzdWx0c1sxXS50cmltKCkgOiBcIlwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmbi5wcm90b3R5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZuLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoc3RyKSB7XG4gIGlmICgndHJ1ZScgPT09IHN0cikgcmV0dXJuIHRydWU7ZWxzZSBpZiAoJ2ZhbHNlJyA9PT0gc3RyKSByZXR1cm4gZmFsc2U7ZWxzZSBpZiAoIWlzTmFOKHN0ciAqIDEpKSByZXR1cm4gcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gc3RyO1xufSAvLyBDb252ZXJ0IFBhc2NhbENhc2UgdG8ga2ViYWItY2FzZVxuLy8gVGhhbmsgeW91OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84OTU1NTgwXG5cblxuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG59XG5cbnZhciBCb3ggPSB7XG4gIEltTm90VG91Y2hpbmdZb3U6IEltTm90VG91Y2hpbmdZb3UsXG4gIE92ZXJsYXBBcmVhOiBPdmVybGFwQXJlYSxcbiAgR2V0RGltZW5zaW9uczogR2V0RGltZW5zaW9ucyxcbiAgR2V0T2Zmc2V0czogR2V0T2Zmc2V0cyxcbiAgR2V0RXhwbGljaXRPZmZzZXRzOiBHZXRFeHBsaWNpdE9mZnNldHNcbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoZSBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQgdG8gYSBjb250YWluZXIgYW5kIGRldGVybWluZXMgY29sbGlzaW9uIGV2ZW50cyB3aXRoIGNvbnRhaW5lci5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byB0ZXN0IGZvciBjb2xsaXNpb25zLlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gcGFyZW50IC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgYm91bmRpbmcgY29udGFpbmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxyT25seSAtIHNldCB0byB0cnVlIHRvIGNoZWNrIGxlZnQgYW5kIHJpZ2h0IHZhbHVlcyBvbmx5LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRiT25seSAtIHNldCB0byB0cnVlIHRvIGNoZWNrIHRvcCBhbmQgYm90dG9tIHZhbHVlcyBvbmx5LlxuICAgKiBAZGVmYXVsdCBpZiBubyBwYXJlbnQgb2JqZWN0IHBhc3NlZCwgZGV0ZWN0cyBjb2xsaXNpb25zIHdpdGggYHdpbmRvd2AuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgY29sbGlzaW9uIGZyZWUsIGZhbHNlIGlmIGEgY29sbGlzaW9uIGluIGFueSBkaXJlY3Rpb24uXG4gICAqL1xuXG59O1xuXG5mdW5jdGlvbiBJbU5vdFRvdWNoaW5nWW91KGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHksIGlnbm9yZUJvdHRvbSkge1xuICByZXR1cm4gT3ZlcmxhcEFyZWEoZWxlbWVudCwgcGFyZW50LCBsck9ubHksIHRiT25seSwgaWdub3JlQm90dG9tKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gT3ZlcmxhcEFyZWEoZWxlbWVudCwgcGFyZW50LCBsck9ubHksIHRiT25seSwgaWdub3JlQm90dG9tKSB7XG4gIHZhciBlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcbiAgICAgIHRvcE92ZXIsXG4gICAgICBib3R0b21PdmVyLFxuICAgICAgbGVmdE92ZXIsXG4gICAgICByaWdodE92ZXI7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHZhciBwYXJEaW1zID0gR2V0RGltZW5zaW9ucyhwYXJlbnQpO1xuICAgIGJvdHRvbU92ZXIgPSBwYXJEaW1zLmhlaWdodCArIHBhckRpbXMub2Zmc2V0LnRvcCAtIChlbGVEaW1zLm9mZnNldC50b3AgKyBlbGVEaW1zLmhlaWdodCk7XG4gICAgdG9wT3ZlciA9IGVsZURpbXMub2Zmc2V0LnRvcCAtIHBhckRpbXMub2Zmc2V0LnRvcDtcbiAgICBsZWZ0T3ZlciA9IGVsZURpbXMub2Zmc2V0LmxlZnQgLSBwYXJEaW1zLm9mZnNldC5sZWZ0O1xuICAgIHJpZ2h0T3ZlciA9IHBhckRpbXMud2lkdGggKyBwYXJEaW1zLm9mZnNldC5sZWZ0IC0gKGVsZURpbXMub2Zmc2V0LmxlZnQgKyBlbGVEaW1zLndpZHRoKTtcbiAgfSBlbHNlIHtcbiAgICBib3R0b21PdmVyID0gZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCArIGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wIC0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0KTtcbiAgICB0b3BPdmVyID0gZWxlRGltcy5vZmZzZXQudG9wIC0gZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3A7XG4gICAgbGVmdE92ZXIgPSBlbGVEaW1zLm9mZnNldC5sZWZ0IC0gZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC5sZWZ0O1xuICAgIHJpZ2h0T3ZlciA9IGVsZURpbXMud2luZG93RGltcy53aWR0aCAtIChlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCk7XG4gIH1cblxuICBib3R0b21PdmVyID0gaWdub3JlQm90dG9tID8gMCA6IE1hdGgubWluKGJvdHRvbU92ZXIsIDApO1xuICB0b3BPdmVyID0gTWF0aC5taW4odG9wT3ZlciwgMCk7XG4gIGxlZnRPdmVyID0gTWF0aC5taW4obGVmdE92ZXIsIDApO1xuICByaWdodE92ZXIgPSBNYXRoLm1pbihyaWdodE92ZXIsIDApO1xuXG4gIGlmIChsck9ubHkpIHtcbiAgICByZXR1cm4gbGVmdE92ZXIgKyByaWdodE92ZXI7XG4gIH1cblxuICBpZiAodGJPbmx5KSB7XG4gICAgcmV0dXJuIHRvcE92ZXIgKyBib3R0b21PdmVyO1xuICB9IC8vIHVzZSBzdW0gb2Ygc3F1YXJlcyBiL2Mgd2UgY2FyZSBhYm91dCBvdmVybGFwIGFyZWEuXG5cblxuICByZXR1cm4gTWF0aC5zcXJ0KHRvcE92ZXIgKiB0b3BPdmVyICsgYm90dG9tT3ZlciAqIGJvdHRvbU92ZXIgKyBsZWZ0T3ZlciAqIGxlZnRPdmVyICsgcmlnaHRPdmVyICogcmlnaHRPdmVyKTtcbn1cbi8qKlxuICogVXNlcyBuYXRpdmUgbWV0aG9kcyB0byByZXR1cm4gYW4gb2JqZWN0IG9mIGRpbWVuc2lvbiB2YWx1ZXMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7alF1ZXJ5IHx8IEhUTUx9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IG9yIERPTSBlbGVtZW50IGZvciB3aGljaCB0byBnZXQgdGhlIGRpbWVuc2lvbnMuIENhbiBiZSBhbnkgZWxlbWVudCBvdGhlciB0aGF0IGRvY3VtZW50IG9yIHdpbmRvdy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gbmVzdGVkIG9iamVjdCBvZiBpbnRlZ2VyIHBpeGVsIHZhbHVlc1xuICogVE9ETyAtIGlmIGVsZW1lbnQgaXMgd2luZG93LCByZXR1cm4gb25seSB0aG9zZSB2YWx1ZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBHZXREaW1lbnNpb25zKGVsZW0pIHtcbiAgZWxlbSA9IGVsZW0ubGVuZ3RoID8gZWxlbVswXSA6IGVsZW07XG5cbiAgaWYgKGVsZW0gPT09IHdpbmRvdyB8fCBlbGVtID09PSBkb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkknbSBzb3JyeSwgRGF2ZS4gSSdtIGFmcmFpZCBJIGNhbid0IGRvIHRoYXQuXCIpO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgcGFyUmVjdCA9IGVsZW0ucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHdpblJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgd2luWSA9IHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgIHdpblggPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICBvZmZzZXQ6IHtcbiAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5ZLFxuICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luWFxuICAgIH0sXG4gICAgcGFyZW50RGltczoge1xuICAgICAgd2lkdGg6IHBhclJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhclJlY3QuaGVpZ2h0LFxuICAgICAgb2Zmc2V0OiB7XG4gICAgICAgIHRvcDogcGFyUmVjdC50b3AgKyB3aW5ZLFxuICAgICAgICBsZWZ0OiBwYXJSZWN0LmxlZnQgKyB3aW5YXG4gICAgICB9XG4gICAgfSxcbiAgICB3aW5kb3dEaW1zOiB7XG4gICAgICB3aWR0aDogd2luUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogd2luUmVjdC5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHtcbiAgICAgICAgdG9wOiB3aW5ZLFxuICAgICAgICBsZWZ0OiB3aW5YXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0b3AgYW5kIGxlZnQgaW50ZWdlciBwaXhlbCB2YWx1ZXMgZm9yIGR5bmFtaWNhbGx5IHJlbmRlcmVkIGVsZW1lbnRzLFxuICogc3VjaCBhczogVG9vbHRpcCwgUmV2ZWFsLCBhbmQgRHJvcGRvd24uIE1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBhbmQgd2hlcmVcbiAqIHlvdSBkb24ndCBrbm93IGFsaWdubWVudCwgYnV0IGdlbmVyYWxseSBmcm9tXG4gKiA2LjQgZm9yd2FyZCB5b3Ugc2hvdWxkIHVzZSBHZXRFeHBsaWNpdE9mZnNldHMsIGFzIEdldE9mZnNldHMgY29uZmxhdGVzIHBvc2l0aW9uIGFuZCBhbGlnbm1lbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAqIEBwYXJhbSB7alF1ZXJ5fSBhbmNob3IgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCdzIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbiAtIGEgc3RyaW5nIHJlbGF0aW5nIHRvIHRoZSBkZXNpcmVkIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LCByZWxhdGl2ZSB0byBpdCdzIGFuY2hvclxuICogQHBhcmFtIHtOdW1iZXJ9IHZPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgdmVydGljYWwgc2VwYXJhdGlvbiBiZXR3ZWVuIGFuY2hvciBhbmQgZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoT2Zmc2V0IC0gaW50ZWdlciBwaXhlbCB2YWx1ZSBvZiBkZXNpcmVkIGhvcml6b250YWwgc2VwYXJhdGlvbiBiZXR3ZWVuIGFuY2hvciBhbmQgZWxlbWVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyZmxvdyAtIGlmIGEgY29sbGlzaW9uIGV2ZW50IGlzIGRldGVjdGVkLCBzZXRzIHRvIHRydWUgdG8gZGVmYXVsdCB0aGUgZWxlbWVudCB0byBmdWxsIHdpZHRoIC0gYW55IGRlc2lyZWQgb2Zmc2V0LlxuICogVE9ETyBhbHRlci9yZXdyaXRlIHRvIHdvcmsgd2l0aCBgZW1gIHZhbHVlcyBhcyB3ZWxsL2luc3RlYWQgb2YgcGl4ZWxzXG4gKi9cblxuXG5mdW5jdGlvbiBHZXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgcG9zaXRpb24sIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpIHtcbiAgY29uc29sZS5sb2coXCJOT1RFOiBHZXRPZmZzZXRzIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgR2V0RXhwbGljaXRPZmZzZXRzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gNi41XCIpO1xuXG4gIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgcmV0dXJuIHJ0bCgpID8gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ3RvcCcsICdsZWZ0Jywgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdykgOiBHZXRFeHBsaWNpdE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCAndG9wJywgJ3JpZ2h0Jywgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdyk7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgcmV0dXJuIHJ0bCgpID8gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ2JvdHRvbScsICdsZWZ0Jywgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdykgOiBHZXRFeHBsaWNpdE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCAnYm90dG9tJywgJ3JpZ2h0Jywgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdyk7XG5cbiAgICBjYXNlICdjZW50ZXIgdG9wJzpcbiAgICAgIHJldHVybiBHZXRFeHBsaWNpdE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCAndG9wJywgJ2NlbnRlcicsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpO1xuXG4gICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICByZXR1cm4gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ2JvdHRvbScsICdjZW50ZXInLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KTtcblxuICAgIGNhc2UgJ2NlbnRlciBsZWZ0JzpcbiAgICAgIHJldHVybiBHZXRFeHBsaWNpdE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCAnbGVmdCcsICdjZW50ZXInLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KTtcblxuICAgIGNhc2UgJ2NlbnRlciByaWdodCc6XG4gICAgICByZXR1cm4gR2V0RXhwbGljaXRPZmZzZXRzKGVsZW1lbnQsIGFuY2hvciwgJ3JpZ2h0JywgJ2NlbnRlcicsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpO1xuXG4gICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgcmV0dXJuIEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsICdib3R0b20nLCAnbGVmdCcsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpO1xuXG4gICAgY2FzZSAncmlnaHQgYm90dG9tJzpcbiAgICAgIHJldHVybiBHZXRFeHBsaWNpdE9mZnNldHMoZWxlbWVudCwgYW5jaG9yLCAnYm90dG9tJywgJ3JpZ2h0Jywgdk9mZnNldCwgaE9mZnNldCwgaXNPdmVyZmxvdyk7XG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkuLi4gdGhpcyBhbG9uZyB3aXRoIHRoZSByZXZlYWwgYW5kIHJldmVhbCBmdWxsXG4gICAgLy8gY2xhc3NlcyBhcmUgdGhlIG9ubHkgb25lcyB0aGF0IGRpZG4ndCByZWZlcmVuY2UgYW5jaG9yXG5cbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCArICRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggLyAyIC0gJGVsZURpbXMud2lkdGggLyAyICsgaE9mZnNldCxcbiAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyAkZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCAvIDIgLSAoJGVsZURpbXMuaGVpZ2h0IC8gMiArIHZPZmZzZXQpXG4gICAgICB9O1xuXG4gICAgY2FzZSAncmV2ZWFsJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICgkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC0gJGVsZURpbXMud2lkdGgpIC8gMiArIGhPZmZzZXQsXG4gICAgICAgIHRvcDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wICsgdk9mZnNldFxuICAgICAgfTtcblxuICAgIGNhc2UgJ3JldmVhbCBmdWxsJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQsXG4gICAgICAgIHRvcDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcnRsKCkgPyAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICRlbGVEaW1zLndpZHRoICsgJGFuY2hvckRpbXMud2lkdGggLSBoT2Zmc2V0IDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyBoT2Zmc2V0LFxuICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0XG4gICAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsIHBvc2l0aW9uLCBhbGlnbm1lbnQsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpIHtcbiAgdmFyICRlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcbiAgICAgICRhbmNob3JEaW1zID0gYW5jaG9yID8gR2V0RGltZW5zaW9ucyhhbmNob3IpIDogbnVsbDtcbiAgdmFyIHRvcFZhbCwgbGVmdFZhbDsgLy8gc2V0IHBvc2l0aW9uIHJlbGF0ZWQgYXR0cmlidXRlXG5cbiAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB0b3BWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgbGVmdFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gKCRlbGVEaW1zLndpZHRoICsgaE9mZnNldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGxlZnRWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldDtcbiAgICAgIGJyZWFrO1xuICB9IC8vIHNldCBhbGlnbm1lbnQgcmVsYXRlZCBhdHRyaWJ1dGVcblxuXG4gIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBsZWZ0VmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyBoT2Zmc2V0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBsZWZ0VmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIC0gaE9mZnNldDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnRWYWwgPSBpc092ZXJmbG93ID8gaE9mZnNldCA6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggLyAyIC0gJGVsZURpbXMud2lkdGggLyAyICsgaE9mZnNldDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC50b3AgLSB2T2Zmc2V0ICsgJGFuY2hvckRpbXMuaGVpZ2h0IC0gJGVsZURpbXMuaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArIHZPZmZzZXQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICB0b3BWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgdk9mZnNldCArICRhbmNob3JEaW1zLmhlaWdodCAvIDIgLSAkZWxlRGltcy5oZWlnaHQgLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3BWYWwsXG4gICAgbGVmdDogbGVmdFZhbFxuICB9O1xufVxuXG4vKipcbiAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlcyAtIEltYWdlKHMpIHRvIGNoZWNrIGlmIGxvYWRlZC5cbiAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkLlxuICovXG5cbmZ1bmN0aW9uIG9uSW1hZ2VzTG9hZGVkKGltYWdlcywgY2FsbGJhY2spIHtcbiAgdmFyIHVubG9hZGVkID0gaW1hZ2VzLmxlbmd0aDtcblxuICBpZiAodW5sb2FkZWQgPT09IDApIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaW1hZ2VzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIC8vIENoZWNrIGlmIGltYWdlIGlzIGxvYWRlZFxuICAgIGlmICh0aGlzLmNvbXBsZXRlICYmIHR5cGVvZiB0aGlzLm5hdHVyYWxXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBhYm92ZSBjaGVjayBmYWlsZWQsIHNpbXVsYXRlIGxvYWRpbmcgb24gZGV0YWNoZWQgZWxlbWVudC5cbiAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBTdGlsbCBjb3VudCBpbWFnZSBhcyBsb2FkZWQgaWYgaXQgZmluYWxpemVzIHdpdGggYW4gZXJyb3IuXG5cbiAgICAgIHZhciBldmVudHMgPSBcImxvYWQuemYuaW1hZ2VzIGVycm9yLnpmLmltYWdlc1wiO1xuICAgICAgJChpbWFnZSkub25lKGV2ZW50cywgZnVuY3Rpb24gbWUoZXZlbnQpIHtcbiAgICAgICAgLy8gVW5iaW5kIHRoZSBldmVudCBsaXN0ZW5lcnMuIFdlJ3JlIHVzaW5nICdvbmUnIGJ1dCBvbmx5IG9uZSBvZiB0aGUgdHdvIGV2ZW50cyB3aWxsIGhhdmUgZmlyZWQuXG4gICAgICAgICQodGhpcykub2ZmKGV2ZW50cywgbWUpO1xuICAgICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xuICAgICAgfSk7XG4gICAgICBpbWFnZS5zcmMgPSAkKHRoaXMpLmF0dHIoJ3NyYycpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gc2luZ2xlSW1hZ2VMb2FkZWQoKSB7XG4gICAgdW5sb2FkZWQtLTtcblxuICAgIGlmICh1bmxvYWRlZCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBUaGlzIHV0aWwgd2FzIGNyZWF0ZWQgYnkgTWFyaXVzIE9sYmVydHogKlxuICogUGxlYXNlIHRoYW5rIE1hcml1cyBvbiBHaXRIdWIgL293bGJlcnR6ICpcbiAqIG9yIHRoZSB3ZWIgaHR0cDovL3d3dy5tYXJpdXNvbGJlcnR6LmRlLyAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBrZXlDb2RlcyA9IHtcbiAgOTogJ1RBQicsXG4gIDEzOiAnRU5URVInLFxuICAyNzogJ0VTQ0FQRScsXG4gIDMyOiAnU1BBQ0UnLFxuICAzNTogJ0VORCcsXG4gIDM2OiAnSE9NRScsXG4gIDM3OiAnQVJST1dfTEVGVCcsXG4gIDM4OiAnQVJST1dfVVAnLFxuICAzOTogJ0FSUk9XX1JJR0hUJyxcbiAgNDA6ICdBUlJPV19ET1dOJ1xufTtcbnZhciBjb21tYW5kcyA9IHt9OyAvLyBGdW5jdGlvbnMgcHVsbGVkIG91dCB0byBiZSByZWZlcmVuY2VhYmxlIGZyb20gaW50ZXJuYWxzXG5cbmZ1bmN0aW9uIGZpbmRGb2N1c2FibGUoJGVsZW1lbnQpIHtcbiAgaWYgKCEkZWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAkZWxlbWVudC5maW5kKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGVdJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoISQodGhpcykuaXMoJzp2aXNpYmxlJykgfHwgJCh0aGlzKS5hdHRyKCd0YWJpbmRleCcpIDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy9vbmx5IGhhdmUgdmlzaWJsZSBlbGVtZW50cyBhbmQgdGhvc2UgdGhhdCBoYXZlIGEgdGFiaW5kZXggZ3JlYXRlciBvciBlcXVhbCAwXG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VLZXkoZXZlbnQpIHtcbiAgdmFyIGtleSA9IGtleUNvZGVzW2V2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVdIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQud2hpY2gpLnRvVXBwZXJDYXNlKCk7IC8vIFJlbW92ZSB1bi1wcmludGFibGUgY2hhcmFjdGVycywgZS5nLiBmb3IgYGZyb21DaGFyQ29kZWAgY2FsbHMgZm9yIENUUkwgb25seSBldmVudHNcblxuICBrZXkgPSBrZXkucmVwbGFjZSgvXFxXKy8sICcnKTtcbiAgaWYgKGV2ZW50LnNoaWZ0S2V5KSBrZXkgPSBcIlNISUZUX1wiLmNvbmNhdChrZXkpO1xuICBpZiAoZXZlbnQuY3RybEtleSkga2V5ID0gXCJDVFJMX1wiLmNvbmNhdChrZXkpO1xuICBpZiAoZXZlbnQuYWx0S2V5KSBrZXkgPSBcIkFMVF9cIi5jb25jYXQoa2V5KTsgLy8gUmVtb3ZlIHRyYWlsaW5nIHVuZGVyc2NvcmUsIGluIGNhc2Ugb25seSBtb2RpZmllcnMgd2VyZSB1c2VkIChlLmcuIG9ubHkgYENUUkxfQUxUYClcblxuICBrZXkgPSBrZXkucmVwbGFjZSgvXyQvLCAnJyk7XG4gIHJldHVybiBrZXk7XG59XG5cbnZhciBLZXlib2FyZCA9IHtcbiAga2V5czogZ2V0S2V5Q29kZXMoa2V5Q29kZXMpLFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIChrZXlib2FyZCkgZXZlbnQgYW5kIHJldHVybnMgYSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIGl0cyBrZXlcbiAgICogQ2FuIGJlIHVzZWQgbGlrZSBGb3VuZGF0aW9uLnBhcnNlS2V5KGV2ZW50KSA9PT0gRm91bmRhdGlvbi5rZXlzLlNQQUNFXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUgZXZlbnQgaGFuZGxlclxuICAgKiBAcmV0dXJuIFN0cmluZyBrZXkgLSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBrZXkgcHJlc3NlZFxuICAgKi9cbiAgcGFyc2VLZXk6IHBhcnNlS2V5LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiAoa2V5Ym9hcmQpIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IC0gRm91bmRhdGlvbiBjb21wb25lbnQncyBuYW1lLCBlLmcuIFNsaWRlciBvciBSZXZlYWxcbiAgICogQHBhcmFtIHtPYmplY3RzfSBmdW5jdGlvbnMgLSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgaGFuZGxlS2V5OiBmdW5jdGlvbiBoYW5kbGVLZXkoZXZlbnQsIGNvbXBvbmVudCwgZnVuY3Rpb25zKSB7XG4gICAgdmFyIGNvbW1hbmRMaXN0ID0gY29tbWFuZHNbY29tcG9uZW50XSxcbiAgICAgICAga2V5Q29kZSA9IHRoaXMucGFyc2VLZXkoZXZlbnQpLFxuICAgICAgICBjbWRzLFxuICAgICAgICBjb21tYW5kLFxuICAgICAgICBmbjtcbiAgICBpZiAoIWNvbW1hbmRMaXN0KSByZXR1cm4gY29uc29sZS53YXJuKCdDb21wb25lbnQgbm90IGRlZmluZWQhJyk7XG5cbiAgICBpZiAodHlwZW9mIGNvbW1hbmRMaXN0Lmx0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHRoaXMgY29tcG9uZW50IGRvZXMgbm90IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBsdHIgYW5kIHJ0bFxuICAgICAgY21kcyA9IGNvbW1hbmRMaXN0OyAvLyB1c2UgcGxhaW4gbGlzdFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtZXJnZSBsdHIgYW5kIHJ0bDogaWYgZG9jdW1lbnQgaXMgcnRsLCBydGwgb3ZlcndyaXRlcyBsdHIgYW5kIHZpY2UgdmVyc2FcbiAgICAgIGlmIChydGwoKSkgY21kcyA9ICQuZXh0ZW5kKHt9LCBjb21tYW5kTGlzdC5sdHIsIGNvbW1hbmRMaXN0LnJ0bCk7ZWxzZSBjbWRzID0gJC5leHRlbmQoe30sIGNvbW1hbmRMaXN0LnJ0bCwgY29tbWFuZExpc3QubHRyKTtcbiAgICB9XG5cbiAgICBjb21tYW5kID0gY21kc1trZXlDb2RlXTtcbiAgICBmbiA9IGZ1bmN0aW9uc1tjb21tYW5kXTtcblxuICAgIGlmIChmbiAmJiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGV4ZWN1dGUgZnVuY3Rpb24gIGlmIGV4aXN0c1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gZm4uYXBwbHkoKTtcblxuICAgICAgaWYgKGZ1bmN0aW9ucy5oYW5kbGVkIHx8IHR5cGVvZiBmdW5jdGlvbnMuaGFuZGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBleGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWRcbiAgICAgICAgZnVuY3Rpb25zLmhhbmRsZWQocmV0dXJuVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZnVuY3Rpb25zLnVuaGFuZGxlZCB8fCB0eXBlb2YgZnVuY3Rpb25zLnVuaGFuZGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBleGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIG5vdCBoYW5kbGVkXG4gICAgICAgIGZ1bmN0aW9ucy51bmhhbmRsZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBnaXZlbiBgJGVsZW1lbnRgXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gc2VhcmNoIHdpdGhpblxuICAgKiBAcmV0dXJuIHtqUXVlcnl9ICRmb2N1c2FibGUgLSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiBgJGVsZW1lbnRgXG4gICAqL1xuICBmaW5kRm9jdXNhYmxlOiBmaW5kRm9jdXNhYmxlLFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgbmFtZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgLSBGb3VuZGF0aW9uIGNvbXBvbmVudCwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXG4gICAqIEByZXR1cm4gU3RyaW5nIGNvbXBvbmVudE5hbWVcbiAgICovXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb21wb25lbnROYW1lLCBjbWRzKSB7XG4gICAgY29tbWFuZHNbY29tcG9uZW50TmFtZV0gPSBjbWRzO1xuICB9LFxuICAvLyBUT0RPOTQzODogVGhlc2UgcmVmZXJlbmNlcyB0byBLZXlib2FyZCBuZWVkIHRvIG5vdCByZXF1aXJlIGdsb2JhbC4gV2lsbCAndGhpcycgd29yayBpbiB0aGlzIGNvbnRleHQ/XG4gIC8vXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRoZSBmb2N1cyBpbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICogQHBhcmFtICB7alF1ZXJ5fSAkZWxlbWVudCAgalF1ZXJ5IG9iamVjdCB0byB0cmFwIHRoZSBmb3VjcyBpbnRvLlxuICAgKi9cbiAgdHJhcEZvY3VzOiBmdW5jdGlvbiB0cmFwRm9jdXMoJGVsZW1lbnQpIHtcbiAgICB2YXIgJGZvY3VzYWJsZSA9IGZpbmRGb2N1c2FibGUoJGVsZW1lbnQpLFxuICAgICAgICAkZmlyc3RGb2N1c2FibGUgPSAkZm9jdXNhYmxlLmVxKDApLFxuICAgICAgICAkbGFzdEZvY3VzYWJsZSA9ICRmb2N1c2FibGUuZXEoLTEpO1xuICAgICRlbGVtZW50Lm9uKCdrZXlkb3duLnpmLnRyYXBmb2N1cycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gJGxhc3RGb2N1c2FibGVbMF0gJiYgcGFyc2VLZXkoZXZlbnQpID09PSAnVEFCJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkZmlyc3RGb2N1c2FibGUuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0ID09PSAkZmlyc3RGb2N1c2FibGVbMF0gJiYgcGFyc2VLZXkoZXZlbnQpID09PSAnU0hJRlRfVEFCJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkbGFzdEZvY3VzYWJsZS5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgdHJhcHBlZCBmb2N1cyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtqUXVlcnl9ICRlbGVtZW50ICBqUXVlcnkgb2JqZWN0IHRvIHJlbGVhc2UgdGhlIGZvY3VzIGZvci5cbiAgICovXG4gIHJlbGVhc2VGb2N1czogZnVuY3Rpb24gcmVsZWFzZUZvY3VzKCRlbGVtZW50KSB7XG4gICAgJGVsZW1lbnQub2ZmKCdrZXlkb3duLnpmLnRyYXBmb2N1cycpO1xuICB9XG59O1xuLypcbiAqIENvbnN0YW50cyBmb3IgZWFzaWVyIGNvbXBhcmluZy5cbiAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxuICovXG5cbmZ1bmN0aW9uIGdldEtleUNvZGVzKGtjcykge1xuICB2YXIgayA9IHt9O1xuXG4gIGZvciAodmFyIGtjIGluIGtjcykge1xuICAgIGtba2NzW2tjXV0gPSBrY3Nba2NdO1xuICB9XG5cbiAgcmV0dXJuIGs7XG59XG5cbi8qKlxuICogTW90aW9uIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5tb3Rpb25cbiAqL1xuXG52YXIgaW5pdENsYXNzZXMgPSBbJ211aS1lbnRlcicsICdtdWktbGVhdmUnXTtcbnZhciBhY3RpdmVDbGFzc2VzID0gWydtdWktZW50ZXItYWN0aXZlJywgJ211aS1sZWF2ZS1hY3RpdmUnXTtcbnZhciBNb3Rpb24gPSB7XG4gIGFuaW1hdGVJbjogZnVuY3Rpb24gYW5pbWF0ZUluKGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgICBhbmltYXRlKHRydWUsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xuICB9LFxuICBhbmltYXRlT3V0OiBmdW5jdGlvbiBhbmltYXRlT3V0KGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgICBhbmltYXRlKGZhbHNlLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gTW92ZShkdXJhdGlvbiwgZWxlbSwgZm4pIHtcbiAgdmFyIGFuaW0sXG4gICAgICBwcm9nLFxuICAgICAgc3RhcnQgPSBudWxsOyAvLyBjb25zb2xlLmxvZygnY2FsbGVkJyk7XG5cbiAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgZm4uYXBwbHkoZWxlbSk7XG4gICAgZWxlbS50cmlnZ2VyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKS50cmlnZ2VySGFuZGxlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gbW92ZSh0cykge1xuICAgIGlmICghc3RhcnQpIHN0YXJ0ID0gdHM7IC8vIGNvbnNvbGUubG9nKHN0YXJ0LCB0cyk7XG5cbiAgICBwcm9nID0gdHMgLSBzdGFydDtcbiAgICBmbi5hcHBseShlbGVtKTtcblxuICAgIGlmIChwcm9nIDwgZHVyYXRpb24pIHtcbiAgICAgIGFuaW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmUsIGVsZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbSk7XG4gICAgICBlbGVtLnRyaWdnZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pLnRyaWdnZXJIYW5kbGVyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKTtcbiAgICB9XG4gIH1cblxuICBhbmltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlKTtcbn1cbi8qKlxuICogQW5pbWF0ZXMgYW4gZWxlbWVudCBpbiBvciBvdXQgdXNpbmcgYSBDU1MgdHJhbnNpdGlvbiBjbGFzcy5cbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbiAtIERlZmluZXMgaWYgdGhlIGFuaW1hdGlvbiBpcyBpbiBvciBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvciBIVE1MIG9iamVjdCB0byBhbmltYXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IGFuaW1hdGlvbiAtIENTUyBjbGFzcyB0byB1c2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIENhbGxiYWNrIHRvIHJ1biB3aGVuIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFuaW1hdGUoaXNJbiwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICBlbGVtZW50ID0gJChlbGVtZW50KS5lcSgwKTtcbiAgaWYgKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaW5pdENsYXNzID0gaXNJbiA/IGluaXRDbGFzc2VzWzBdIDogaW5pdENsYXNzZXNbMV07XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzSW4gPyBhY3RpdmVDbGFzc2VzWzBdIDogYWN0aXZlQ2xhc3Nlc1sxXTsgLy8gU2V0IHVwIHRoZSBhbmltYXRpb25cblxuICByZXNldCgpO1xuICBlbGVtZW50LmFkZENsYXNzKGFuaW1hdGlvbikuY3NzKCd0cmFuc2l0aW9uJywgJ25vbmUnKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50LmFkZENsYXNzKGluaXRDbGFzcyk7XG4gICAgaWYgKGlzSW4pIGVsZW1lbnQuc2hvdygpO1xuICB9KTsgLy8gU3RhcnQgdGhlIGFuaW1hdGlvblxuXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aDtcbiAgICBlbGVtZW50LmNzcygndHJhbnNpdGlvbicsICcnKS5hZGRDbGFzcyhhY3RpdmVDbGFzcyk7XG4gIH0pOyAvLyBDbGVhbiB1cCB0aGUgYW5pbWF0aW9uIHdoZW4gaXQgZmluaXNoZXNcblxuICBlbGVtZW50Lm9uZSh0cmFuc2l0aW9uZW5kKGVsZW1lbnQpLCBmaW5pc2gpOyAvLyBIaWRlcyB0aGUgZWxlbWVudCAoZm9yIG91dCBhbmltYXRpb25zKSwgcmVzZXRzIHRoZSBlbGVtZW50LCBhbmQgcnVucyBhIGNhbGxiYWNrXG5cbiAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIGlmICghaXNJbikgZWxlbWVudC5oaWRlKCk7XG4gICAgcmVzZXQoKTtcbiAgICBpZiAoY2IpIGNiLmFwcGx5KGVsZW1lbnQpO1xuICB9IC8vIFJlc2V0cyB0cmFuc2l0aW9ucyBhbmQgcmVtb3ZlcyBtb3Rpb24tc3BlY2lmaWMgY2xhc3Nlc1xuXG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZWxlbWVudFswXS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAwO1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJcIi5jb25jYXQoaW5pdENsYXNzLCBcIiBcIikuY29uY2F0KGFjdGl2ZUNsYXNzLCBcIiBcIikuY29uY2F0KGFuaW1hdGlvbikpO1xuICB9XG59XG5cbnZhciBOZXN0ID0ge1xuICBGZWF0aGVyOiBmdW5jdGlvbiBGZWF0aGVyKG1lbnUpIHtcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3pmJztcbiAgICBtZW51LmF0dHIoJ3JvbGUnLCAnbWVudWJhcicpO1xuICAgIHZhciBpdGVtcyA9IG1lbnUuZmluZCgnbGknKS5hdHRyKHtcbiAgICAgICdyb2xlJzogJ21lbnVpdGVtJ1xuICAgIH0pLFxuICAgICAgICBzdWJNZW51Q2xhc3MgPSBcImlzLVwiLmNvbmNhdCh0eXBlLCBcIi1zdWJtZW51XCIpLFxuICAgICAgICBzdWJJdGVtQ2xhc3MgPSBcIlwiLmNvbmNhdChzdWJNZW51Q2xhc3MsIFwiLWl0ZW1cIiksXG4gICAgICAgIGhhc1N1YkNsYXNzID0gXCJpcy1cIi5jb25jYXQodHlwZSwgXCItc3VibWVudS1wYXJlbnRcIiksXG4gICAgICAgIGFwcGx5QXJpYSA9IHR5cGUgIT09ICdhY2NvcmRpb24nOyAvLyBBY2NvcmRpb25zIGhhbmRsZSB0aGVpciBvd24gQVJJQSBhdHRyaXV0ZXMuXG5cbiAgICBpdGVtcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkaXRlbSA9ICQodGhpcyksXG4gICAgICAgICAgJHN1YiA9ICRpdGVtLmNoaWxkcmVuKCd1bCcpO1xuXG4gICAgICBpZiAoJHN1Yi5sZW5ndGgpIHtcbiAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoaGFzU3ViQ2xhc3MpO1xuICAgICAgICAkc3ViLmFkZENsYXNzKFwic3VibWVudSBcIi5jb25jYXQoc3ViTWVudUNsYXNzKSkuYXR0cih7XG4gICAgICAgICAgJ2RhdGEtc3VibWVudSc6ICcnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhcHBseUFyaWEpIHtcbiAgICAgICAgICAkaXRlbS5hdHRyKHtcbiAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogJGl0ZW0uY2hpbGRyZW4oJ2E6Zmlyc3QnKS50ZXh0KClcbiAgICAgICAgICB9KTsgLy8gTm90ZTogIERyaWxsZG93bnMgYmVoYXZlIGRpZmZlcmVudGx5IGluIGhvdyB0aGV5IGhpZGUsIGFuZCBzbyBuZWVkXG4gICAgICAgICAgLy8gYWRkaXRpb25hbCBhdHRyaWJ1dGVzLiAgV2Ugc2hvdWxkIGxvb2sgaWYgdGhpcyBwb3NzaWJseSBvdmVyLWdlbmVyYWxpemVkXG4gICAgICAgICAgLy8gdXRpbGl0eSAoTmVzdCkgaXMgYXBwcm9wcmlhdGUgd2hlbiB3ZSByZXdvcmsgbWVudXMgaW4gNi40XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RyaWxsZG93bicpIHtcbiAgICAgICAgICAgICRpdGVtLmF0dHIoe1xuICAgICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkc3ViLmFkZENsYXNzKFwic3VibWVudSBcIi5jb25jYXQoc3ViTWVudUNsYXNzKSkuYXR0cih7XG4gICAgICAgICAgJ2RhdGEtc3VibWVudSc6ICcnLFxuICAgICAgICAgICdyb2xlJzogJ21lbnViYXInXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnZHJpbGxkb3duJykge1xuICAgICAgICAgICRzdWIuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCRpdGVtLnBhcmVudCgnW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcbiAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoXCJpcy1zdWJtZW51LWl0ZW0gXCIuY29uY2F0KHN1Ykl0ZW1DbGFzcykpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfSxcbiAgQnVybjogZnVuY3Rpb24gQnVybihtZW51LCB0eXBlKSB7XG4gICAgdmFyIC8vaXRlbXMgPSBtZW51LmZpbmQoJ2xpJyksXG4gICAgc3ViTWVudUNsYXNzID0gXCJpcy1cIi5jb25jYXQodHlwZSwgXCItc3VibWVudVwiKSxcbiAgICAgICAgc3ViSXRlbUNsYXNzID0gXCJcIi5jb25jYXQoc3ViTWVudUNsYXNzLCBcIi1pdGVtXCIpLFxuICAgICAgICBoYXNTdWJDbGFzcyA9IFwiaXMtXCIuY29uY2F0KHR5cGUsIFwiLXN1Ym1lbnUtcGFyZW50XCIpO1xuICAgIG1lbnUuZmluZCgnPmxpLCA+IGxpID4gdWwsIC5tZW51LCAubWVudSA+IGxpLCBbZGF0YS1zdWJtZW51XSA+IGxpJykucmVtb3ZlQ2xhc3MoXCJcIi5jb25jYXQoc3ViTWVudUNsYXNzLCBcIiBcIikuY29uY2F0KHN1Ykl0ZW1DbGFzcywgXCIgXCIpLmNvbmNhdChoYXNTdWJDbGFzcywgXCIgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlXCIpKS5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKS5jc3MoJ2Rpc3BsYXknLCAnJyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVyKGVsZW0sIG9wdGlvbnMsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAvL29wdGlvbnMgaXMgYW4gb2JqZWN0IGZvciBlYXNpbHkgYWRkaW5nIGZlYXR1cmVzIGxhdGVyLlxuICBuYW1lU3BhY2UgPSBPYmplY3Qua2V5cyhlbGVtLmRhdGEoKSlbMF0gfHwgJ3RpbWVyJyxcbiAgICAgIHJlbWFpbiA9IC0xLFxuICAgICAgc3RhcnQsXG4gICAgICB0aW1lcjtcblxuICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgdGhpcy5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJlbWFpbiA9IC0xO1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9O1xuXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlOyAvLyBpZighZWxlbS5kYXRhKCdwYXVzZWQnKSl7IHJldHVybiBmYWxzZTsgfS8vbWF5YmUgaW1wbGVtZW50IHRoaXMgc2FuaXR5IGNoZWNrIGlmIHVzZWQgZm9yIG90aGVyIHRoaW5ncy5cblxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgcmVtYWluID0gcmVtYWluIDw9IDAgPyBkdXJhdGlvbiA6IHJlbWFpbjtcbiAgICBlbGVtLmRhdGEoJ3BhdXNlZCcsIGZhbHNlKTtcbiAgICBzdGFydCA9IERhdGUubm93KCk7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvcHRpb25zLmluZmluaXRlKSB7XG4gICAgICAgIF90aGlzLnJlc3RhcnQoKTsgLy9yZXJ1biB0aGUgdGltZXIuXG5cbiAgICAgIH1cblxuICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH0sIHJlbWFpbik7XG4gICAgZWxlbS50cmlnZ2VyKFwidGltZXJzdGFydC56Zi5cIi5jb25jYXQobmFtZVNwYWNlKSk7XG4gIH07XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTsgLy9pZihlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxuXG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICBlbGVtLmRhdGEoJ3BhdXNlZCcsIHRydWUpO1xuICAgIHZhciBlbmQgPSBEYXRlLm5vdygpO1xuICAgIHJlbWFpbiA9IHJlbWFpbiAtIChlbmQgLSBzdGFydCk7XG4gICAgZWxlbS50cmlnZ2VyKFwidGltZXJwYXVzZWQuemYuXCIuY29uY2F0KG5hbWVTcGFjZSkpO1xuICB9O1xufVxuXG52YXIgVG91Y2ggPSB7fTtcbnZhciBzdGFydFBvc1gsXG4gICAgc3RhcnRQb3NZLFxuICAgIHN0YXJ0VGltZSxcbiAgICBlbGFwc2VkVGltZSxcbiAgICBzdGFydEV2ZW50LFxuICAgIGlzTW92aW5nID0gZmFsc2UsXG4gICAgZGlkTW92ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XG4gIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7IC8vIElmIHRoZSB0b3VjaCBkaWQgbm90IG1vdmUsIGNvbnNpZGVyIGl0IGFzIGEgXCJ0YXBcIlxuXG4gIGlmICghZGlkTW92ZWQpIHtcbiAgICB2YXIgdGFwRXZlbnQgPSAkLkV2ZW50KCd0YXAnLCBzdGFydEV2ZW50IHx8IGUpO1xuICAgICQodGhpcykudHJpZ2dlcih0YXBFdmVudCk7XG4gIH1cblxuICBzdGFydEV2ZW50ID0gbnVsbDtcbiAgaXNNb3ZpbmcgPSBmYWxzZTtcbiAgZGlkTW92ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xuICBpZiAoJC5zcG90U3dpcGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBpZiAoaXNNb3ZpbmcpIHtcbiAgICB2YXIgeCA9IGUudG91Y2hlc1swXS5wYWdlWDtcbiAgICB2YXIgeSA9IGUudG91Y2hlc1swXS5wYWdlWTtcbiAgICB2YXIgZHggPSBzdGFydFBvc1ggLSB4O1xuICAgIHZhciBkaXI7XG4gICAgZGlkTW92ZWQgPSB0cnVlO1xuICAgIGVsYXBzZWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWU7XG5cbiAgICBpZiAoTWF0aC5hYnMoZHgpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xuICAgICAgZGlyID0gZHggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IC8vIGVsc2UgaWYoTWF0aC5hYnMoZHkpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xuICAgIC8vICAgZGlyID0gZHkgPiAwID8gJ2Rvd24nIDogJ3VwJztcbiAgICAvLyB9XG5cblxuICAgIGlmIChkaXIpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9uVG91Y2hFbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICQodGhpcykudHJpZ2dlcigkLkV2ZW50KCdzd2lwZScsIGUpLCBkaXIpLnRyaWdnZXIoJC5FdmVudChcInN3aXBlXCIuY29uY2F0KGRpciksIGUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgIHN0YXJ0UG9zWCA9IGUudG91Y2hlc1swXS5wYWdlWDtcbiAgICBzdGFydFBvc1kgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgc3RhcnRFdmVudCA9IGU7XG4gICAgaXNNb3ZpbmcgPSB0cnVlO1xuICAgIGRpZE1vdmVkID0gZmFsc2U7XG4gICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xufVxuXG52YXIgU3BvdFN3aXBlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3BvdFN3aXBlKCQkJDEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BvdFN3aXBlKTtcblxuICAgIHRoaXMudmVyc2lvbiA9ICcxLjAuMCc7XG4gICAgdGhpcy5lbmFibGVkID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHRoaXMucHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICB0aGlzLm1vdmVUaHJlc2hvbGQgPSA3NTtcbiAgICB0aGlzLnRpbWVUaHJlc2hvbGQgPSAyMDA7XG4gICAgdGhpcy4kID0gJCQkMTtcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTcG90U3dpcGUsIFt7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyICQkJDEgPSB0aGlzLiQ7XG4gICAgICAkJCQxLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7XG4gICAgICAgIHNldHVwOiBpbml0XG4gICAgICB9O1xuICAgICAgJCQkMS5ldmVudC5zcGVjaWFsLnRhcCA9IHtcbiAgICAgICAgc2V0dXA6IGluaXRcbiAgICAgIH07XG4gICAgICAkJCQxLmVhY2goWydsZWZ0JywgJ3VwJywgJ2Rvd24nLCAncmlnaHQnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAkJCQxLmV2ZW50LnNwZWNpYWxbXCJzd2lwZVwiLmNvbmNhdCh0aGlzKV0gPSB7XG4gICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgICAgICAgJCQkMSh0aGlzKS5vbignc3dpcGUnLCAkJCQxLm5vb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTcG90U3dpcGU7XG59KCk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQXMgZmFyIGFzIEkgY2FuIHRlbGwsIGJvdGggc2V0dXBTcG90U3dpcGUgYW5kICAgICpcbiAqIHNldHVwVG91Y2hIYW5kbGVyIHNob3VsZCBiZSBpZGVtcG90ZW50LCAgICAgICAgICAqXG4gKiBiZWNhdXNlIHRoZXkgZGlyZWN0bHkgcmVwbGFjZSBmdW5jdGlvbnMgJiAgICAgICAgKlxuICogdmFsdWVzLCBhbmQgZG8gbm90IGFkZCBldmVudCBoYW5kbGVycyBkaXJlY3RseS4gICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRvdWNoLnNldHVwU3BvdFN3aXBlID0gZnVuY3Rpb24gKCQkJDEpIHtcbiAgJCQkMS5zcG90U3dpcGUgPSBuZXcgU3BvdFN3aXBlKCQkJDEpO1xufTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNZXRob2QgZm9yIGFkZGluZyBwc2V1ZG8gZHJhZyBldmVudHMgdG8gZWxlbWVudHMgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5Ub3VjaC5zZXR1cFRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uICgkJCQxKSB7XG4gICQkJDEuZm4uYWRkVG91Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgJCQkMShlbCkuYmluZCgndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy93ZSBwYXNzIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgYmVjYXVzZSB0aGUgalF1ZXJ5IGV2ZW50XG4gICAgICAgIC8vb2JqZWN0IGlzIG5vcm1hbGl6ZWQgdG8gdzNjIHNwZWNzIGFuZCBkb2VzIG5vdCBwcm92aWRlIHRoZSBUb3VjaExpc3RcbiAgICAgICAgaGFuZGxlVG91Y2goZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGFuZGxlVG91Y2ggPSBmdW5jdGlvbiBoYW5kbGVUb3VjaChldmVudCkge1xuICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgICBmaXJzdCA9IHRvdWNoZXNbMF0sXG4gICAgICAgICAgZXZlbnRUeXBlcyA9IHtcbiAgICAgICAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gICAgICAgIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gICAgICAgIHRvdWNoZW5kOiAnbW91c2V1cCdcbiAgICAgIH0sXG4gICAgICAgICAgdHlwZSA9IGV2ZW50VHlwZXNbZXZlbnQudHlwZV0sXG4gICAgICAgICAgc2ltdWxhdGVkRXZlbnQ7XG5cbiAgICAgIGlmICgnTW91c2VFdmVudCcgaW4gd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IG5ldyB3aW5kb3cuTW91c2VFdmVudCh0eXBlLCB7XG4gICAgICAgICAgJ2J1YmJsZXMnOiB0cnVlLFxuICAgICAgICAgICdjYW5jZWxhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnc2NyZWVuWCc6IGZpcnN0LnNjcmVlblgsXG4gICAgICAgICAgJ3NjcmVlblknOiBmaXJzdC5zY3JlZW5ZLFxuICAgICAgICAgICdjbGllbnRYJzogZmlyc3QuY2xpZW50WCxcbiAgICAgICAgICAnY2xpZW50WSc6IGZpcnN0LmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgICAgIHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSwgZmlyc3Quc2NyZWVuWCwgZmlyc3Quc2NyZWVuWSwgZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDBcbiAgICAgICAgLypsZWZ0Ki9cbiAgICAgICAgLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgZmlyc3QudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuICAgIH07XG4gIH07XG59O1xuXG5Ub3VjaC5pbml0ID0gZnVuY3Rpb24gKCQkJDEpIHtcbiAgaWYgKHR5cGVvZiAkJCQxLnNwb3RTd2lwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBUb3VjaC5zZXR1cFNwb3RTd2lwZSgkJCQxKTtcbiAgICBUb3VjaC5zZXR1cFRvdWNoSGFuZGxlcigkJCQxKTtcbiAgfVxufTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcmVmaXhlcyA9IFsnV2ViS2l0JywgJ01veicsICdPJywgJ01zJywgJyddO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoXCJcIi5jb25jYXQocHJlZml4ZXNbaV0sIFwiTXV0YXRpb25PYnNlcnZlclwiKSBpbiB3aW5kb3cpIHtcbiAgICAgIHJldHVybiB3aW5kb3dbXCJcIi5jb25jYXQocHJlZml4ZXNbaV0sIFwiTXV0YXRpb25PYnNlcnZlclwiKV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSgpO1xuXG52YXIgdHJpZ2dlcnMgPSBmdW5jdGlvbiB0cmlnZ2VycyhlbCwgdHlwZSkge1xuICBlbC5kYXRhKHR5cGUpLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAkKFwiI1wiLmNvbmNhdChpZCkpW3R5cGUgPT09ICdjbG9zZScgPyAndHJpZ2dlcicgOiAndHJpZ2dlckhhbmRsZXInXShcIlwiLmNvbmNhdCh0eXBlLCBcIi56Zi50cmlnZ2VyXCIpLCBbZWxdKTtcbiAgfSk7XG59O1xuXG52YXIgVHJpZ2dlcnMgPSB7XG4gIExpc3RlbmVyczoge1xuICAgIEJhc2ljOiB7fSxcbiAgICBHbG9iYWw6IHt9XG4gIH0sXG4gIEluaXRpYWxpemVyczoge31cbn07XG5UcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMgPSB7XG4gIG9wZW5MaXN0ZW5lcjogZnVuY3Rpb24gb3Blbkxpc3RlbmVyKCkge1xuICAgIHRyaWdnZXJzKCQodGhpcyksICdvcGVuJyk7XG4gIH0sXG4gIGNsb3NlTGlzdGVuZXI6IGZ1bmN0aW9uIGNsb3NlTGlzdGVuZXIoKSB7XG4gICAgdmFyIGlkID0gJCh0aGlzKS5kYXRhKCdjbG9zZScpO1xuXG4gICAgaWYgKGlkKSB7XG4gICAgICB0cmlnZ2VycygkKHRoaXMpLCAnY2xvc2UnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbG9zZS56Zi50cmlnZ2VyJyk7XG4gICAgfVxuICB9LFxuICB0b2dnbGVMaXN0ZW5lcjogZnVuY3Rpb24gdG9nZ2xlTGlzdGVuZXIoKSB7XG4gICAgdmFyIGlkID0gJCh0aGlzKS5kYXRhKCd0b2dnbGUnKTtcblxuICAgIGlmIChpZCkge1xuICAgICAgdHJpZ2dlcnMoJCh0aGlzKSwgJ3RvZ2dsZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKHRoaXMpLnRyaWdnZXIoJ3RvZ2dsZS56Zi50cmlnZ2VyJyk7XG4gICAgfVxuICB9LFxuICBjbG9zZWFibGVMaXN0ZW5lcjogZnVuY3Rpb24gY2xvc2VhYmxlTGlzdGVuZXIoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdmFyIGFuaW1hdGlvbiA9ICQodGhpcykuZGF0YSgnY2xvc2FibGUnKTtcblxuICAgIGlmIChhbmltYXRpb24gIT09ICcnKSB7XG4gICAgICBNb3Rpb24uYW5pbWF0ZU91dCgkKHRoaXMpLCBhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKHRoaXMpLmZhZGVPdXQoKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcbiAgICB9XG4gIH0sXG4gIHRvZ2dsZUZvY3VzTGlzdGVuZXI6IGZ1bmN0aW9uIHRvZ2dsZUZvY3VzTGlzdGVuZXIoKSB7XG4gICAgdmFyIGlkID0gJCh0aGlzKS5kYXRhKCd0b2dnbGUtZm9jdXMnKTtcbiAgICAkKFwiI1wiLmNvbmNhdChpZCkpLnRyaWdnZXJIYW5kbGVyKCd0b2dnbGUuemYudHJpZ2dlcicsIFskKHRoaXMpXSk7XG4gIH1cbn07IC8vIEVsZW1lbnRzIHdpdGggW2RhdGEtb3Blbl0gd2lsbCByZXZlYWwgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXG5cblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRPcGVuTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcbiAgJGVsZW0ub2ZmKCdjbGljay56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLm9wZW5MaXN0ZW5lcik7XG4gICRlbGVtLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLW9wZW5dJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLm9wZW5MaXN0ZW5lcik7XG59OyAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NlXSB3aWxsIGNsb3NlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuLy8gSWYgdXNlZCB3aXRob3V0IGEgdmFsdWUgb24gW2RhdGEtY2xvc2VdLCB0aGUgZXZlbnQgd2lsbCBidWJibGUsIGFsbG93aW5nIGl0IHRvIGNsb3NlIGEgcGFyZW50IGNvbXBvbmVudC5cblxuXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VMaXN0ZW5lciA9IGZ1bmN0aW9uICgkZWxlbSkge1xuICAkZWxlbS5vZmYoJ2NsaWNrLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMuY2xvc2VMaXN0ZW5lcik7XG4gICRlbGVtLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZUxpc3RlbmVyKTtcbn07IC8vIEVsZW1lbnRzIHdpdGggW2RhdGEtdG9nZ2xlXSB3aWxsIHRvZ2dsZSBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cblxuXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkVG9nZ2xlTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcbiAgJGVsZW0ub2ZmKCdjbGljay56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLnRvZ2dsZUxpc3RlbmVyKTtcbiAgJGVsZW0ub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtdG9nZ2xlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy50b2dnbGVMaXN0ZW5lcik7XG59OyAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NhYmxlXSB3aWxsIHJlc3BvbmQgdG8gY2xvc2UuemYudHJpZ2dlciBldmVudHMuXG5cblxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZENsb3NlYWJsZUxpc3RlbmVyID0gZnVuY3Rpb24gKCRlbGVtKSB7XG4gICRlbGVtLm9mZignY2xvc2UuemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZWFibGVMaXN0ZW5lcik7XG4gICRlbGVtLm9uKCdjbG9zZS56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlYWJsZV0sIFtkYXRhLWNsb3NhYmxlXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZWFibGVMaXN0ZW5lcik7XG59OyAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLXRvZ2dsZS1mb2N1c10gd2lsbCByZXNwb25kIHRvIGNvbWluZyBpbiBhbmQgb3V0IG9mIGZvY3VzXG5cblxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFRvZ2dsZUZvY3VzTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcbiAgJGVsZW0ub2ZmKCdmb2N1cy56Zi50cmlnZ2VyIGJsdXIuemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy50b2dnbGVGb2N1c0xpc3RlbmVyKTtcbiAgJGVsZW0ub24oJ2ZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZS1mb2N1c10nLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMudG9nZ2xlRm9jdXNMaXN0ZW5lcik7XG59OyAvLyBNb3JlIEdsb2JhbC9jb21wbGV4IGxpc3RlbmVycyBhbmQgdHJpZ2dlcnNcblxuXG5UcmlnZ2Vycy5MaXN0ZW5lcnMuR2xvYmFsID0ge1xuICByZXNpemVMaXN0ZW5lcjogZnVuY3Rpb24gcmVzaXplTGlzdGVuZXIoJG5vZGVzKSB7XG4gICAgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAvL2ZhbGxiYWNrIGZvciBJRSA5XG4gICAgICAkbm9kZXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgIH0pO1xuICAgIH0gLy90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIHJlc2l6ZSBldmVudFxuXG5cbiAgICAkbm9kZXMuYXR0cignZGF0YS1ldmVudHMnLCBcInJlc2l6ZVwiKTtcbiAgfSxcbiAgc2Nyb2xsTGlzdGVuZXI6IGZ1bmN0aW9uIHNjcm9sbExpc3RlbmVyKCRub2Rlcykge1xuICAgIGlmICghTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgLy9mYWxsYmFjayBmb3IgSUUgOVxuICAgICAgJG5vZGVzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKCdzY3JvbGxtZS56Zi50cmlnZ2VyJyk7XG4gICAgICB9KTtcbiAgICB9IC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBzY3JvbGwgZXZlbnRcblxuXG4gICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXCJzY3JvbGxcIik7XG4gIH0sXG4gIGNsb3NlTWVMaXN0ZW5lcjogZnVuY3Rpb24gY2xvc2VNZUxpc3RlbmVyKGUsIHBsdWdpbklkKSB7XG4gICAgdmFyIHBsdWdpbiA9IGUubmFtZXNwYWNlLnNwbGl0KCcuJylbMF07XG4gICAgdmFyIHBsdWdpbnMgPSAkKFwiW2RhdGEtXCIuY29uY2F0KHBsdWdpbiwgXCJdXCIpKS5ub3QoXCJbZGF0YS15ZXRpLWJveD1cXFwiXCIuY29uY2F0KHBsdWdpbklkLCBcIlxcXCJdXCIpKTtcbiAgICBwbHVnaW5zLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gJCh0aGlzKTtcblxuICAgICAgX3RoaXMudHJpZ2dlckhhbmRsZXIoJ2Nsb3NlLnpmLnRyaWdnZXInLCBbX3RoaXNdKTtcbiAgICB9KTtcbiAgfSAvLyBHbG9iYWwsIHBhcnNlcyB3aG9sZSBkb2N1bWVudC5cblxufTtcblxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZENsb3NlbWVMaXN0ZW5lciA9IGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gIHZhciB5ZXRpQm94ZXMgPSAkKCdbZGF0YS15ZXRpLWJveF0nKSxcbiAgICAgIHBsdWdOYW1lcyA9IFsnZHJvcGRvd24nLCAndG9vbHRpcCcsICdyZXZlYWwnXTtcblxuICBpZiAocGx1Z2luTmFtZSkge1xuICAgIGlmICh0eXBlb2YgcGx1Z2luTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBsdWdOYW1lcy5wdXNoKHBsdWdpbk5hbWUpO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihwbHVnaW5OYW1lKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBsdWdpbk5hbWVbMF0gPT09ICdzdHJpbmcnKSA7IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignUGx1Z2luIG5hbWVzIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh5ZXRpQm94ZXMubGVuZ3RoKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHBsdWdOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBcImNsb3NlbWUuemYuXCIuY29uY2F0KG5hbWUpO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgICAkKHdpbmRvdykub2ZmKGxpc3RlbmVycykub24obGlzdGVuZXJzLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuR2xvYmFsLmNsb3NlTWVMaXN0ZW5lcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRlYm91bmNlR2xvYmFsTGlzdGVuZXIoZGVib3VuY2UsIHRyaWdnZXIsIGxpc3RlbmVyKSB7XG4gIHZhciB0aW1lcixcbiAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAkKHdpbmRvdykub2ZmKHRyaWdnZXIpLm9uKHRyaWdnZXIsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIH1cblxuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCBkZWJvdW5jZSB8fCAxMCk7IC8vZGVmYXVsdCB0aW1lIHRvIGVtaXQgc2Nyb2xsIGV2ZW50XG4gIH0pO1xufVxuXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkUmVzaXplTGlzdGVuZXIgPSBmdW5jdGlvbiAoZGVib3VuY2UpIHtcbiAgdmFyICRub2RlcyA9ICQoJ1tkYXRhLXJlc2l6ZV0nKTtcblxuICBpZiAoJG5vZGVzLmxlbmd0aCkge1xuICAgIGRlYm91bmNlR2xvYmFsTGlzdGVuZXIoZGVib3VuY2UsICdyZXNpemUuemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5HbG9iYWwucmVzaXplTGlzdGVuZXIsICRub2Rlcyk7XG4gIH1cbn07XG5cblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRTY3JvbGxMaXN0ZW5lciA9IGZ1bmN0aW9uIChkZWJvdW5jZSkge1xuICB2YXIgJG5vZGVzID0gJCgnW2RhdGEtc2Nyb2xsXScpO1xuXG4gIGlmICgkbm9kZXMubGVuZ3RoKSB7XG4gICAgZGVib3VuY2VHbG9iYWxMaXN0ZW5lcihkZWJvdW5jZSwgJ3Njcm9sbC56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkdsb2JhbC5zY3JvbGxMaXN0ZW5lciwgJG5vZGVzKTtcbiAgfVxufTtcblxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZE11dGF0aW9uRXZlbnRzTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcbiAgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyICRub2RlcyA9ICRlbGVtLmZpbmQoJ1tkYXRhLXJlc2l6ZV0sIFtkYXRhLXNjcm9sbF0sIFtkYXRhLW11dGF0ZV0nKTsgLy9lbGVtZW50IGNhbGxiYWNrXG5cbiAgdmFyIGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24gPSBmdW5jdGlvbiBsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uKG11dGF0aW9uUmVjb3Jkc0xpc3QpIHtcbiAgICB2YXIgJHRhcmdldCA9ICQobXV0YXRpb25SZWNvcmRzTGlzdFswXS50YXJnZXQpOyAvL3RyaWdnZXIgdGhlIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBlbGVtZW50IGRlcGVuZGluZyBvbiB0eXBlXG5cbiAgICBzd2l0Y2ggKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0udHlwZSkge1xuICAgICAgY2FzZSBcImF0dHJpYnV0ZXNcIjpcbiAgICAgICAgaWYgKCR0YXJnZXQuYXR0cihcImRhdGEtZXZlbnRzXCIpID09PSBcInNjcm9sbFwiICYmIG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0uYXR0cmlidXRlTmFtZSA9PT0gXCJkYXRhLWV2ZW50c1wiKSB7XG4gICAgICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcignc2Nyb2xsbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0LCB3aW5kb3cucGFnZVlPZmZzZXRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkdGFyZ2V0LmF0dHIoXCJkYXRhLWV2ZW50c1wiKSA9PT0gXCJyZXNpemVcIiAmJiBtdXRhdGlvblJlY29yZHNMaXN0WzBdLmF0dHJpYnV0ZU5hbWUgPT09IFwiZGF0YS1ldmVudHNcIikge1xuICAgICAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0uYXR0cmlidXRlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgICAgJHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKS5hdHRyKFwiZGF0YS1ldmVudHNcIiwgXCJtdXRhdGVcIik7XG4gICAgICAgICAgJHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKS50cmlnZ2VySGFuZGxlcignbXV0YXRlbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0LmNsb3Nlc3QoXCJbZGF0YS1tdXRhdGVdXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImNoaWxkTGlzdFwiOlxuICAgICAgICAkdGFyZ2V0LmNsb3Nlc3QoXCJbZGF0YS1tdXRhdGVdXCIpLmF0dHIoXCJkYXRhLWV2ZW50c1wiLCBcIm11dGF0ZVwiKTtcbiAgICAgICAgJHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKS50cmlnZ2VySGFuZGxlcignbXV0YXRlbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0LmNsb3Nlc3QoXCJbZGF0YS1tdXRhdGVdXCIpXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvL25vdGhpbmdcbiAgICB9XG4gIH07XG5cbiAgaWYgKCRub2Rlcy5sZW5ndGgpIHtcbiAgICAvL2ZvciBlYWNoIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBsaXN0ZW4gZm9yIHJlc2l6aW5nLCBzY3JvbGxpbmcsIG9yIG11dGF0aW9uIGFkZCBhIHNpbmdsZSBvYnNlcnZlclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9ICRub2Rlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciBlbGVtZW50T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uKTtcbiAgICAgIGVsZW1lbnRPYnNlcnZlci5vYnNlcnZlKCRub2Rlc1tpXSwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IGZhbHNlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcImRhdGEtZXZlbnRzXCIsIFwic3R5bGVcIl1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFNpbXBsZUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyICRkb2N1bWVudCA9ICQoZG9jdW1lbnQpO1xuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkT3Blbkxpc3RlbmVyKCRkb2N1bWVudCk7XG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZUxpc3RlbmVyKCRkb2N1bWVudCk7XG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRUb2dnbGVMaXN0ZW5lcigkZG9jdW1lbnQpO1xuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VhYmxlTGlzdGVuZXIoJGRvY3VtZW50KTtcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFRvZ2dsZUZvY3VzTGlzdGVuZXIoJGRvY3VtZW50KTtcbn07XG5cblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRHbG9iYWxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciAkZG9jdW1lbnQgPSAkKGRvY3VtZW50KTtcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZE11dGF0aW9uRXZlbnRzTGlzdGVuZXIoJGRvY3VtZW50KTtcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFJlc2l6ZUxpc3RlbmVyKCk7XG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRTY3JvbGxMaXN0ZW5lcigpO1xuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VtZUxpc3RlbmVyKCk7XG59O1xuXG5UcmlnZ2Vycy5pbml0ID0gZnVuY3Rpb24gKCQkJDEsIEZvdW5kYXRpb24pIHtcbiAgb25Mb2FkKCQkJDEod2luZG93KSwgZnVuY3Rpb24gKCkge1xuICAgIGlmICgkJCQxLnRyaWdnZXJzSW5pdGlhbGl6ZWQgIT09IHRydWUpIHtcbiAgICAgIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRTaW1wbGVMaXN0ZW5lcnMoKTtcbiAgICAgIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgICQkJDEudHJpZ2dlcnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBpZiAoRm91bmRhdGlvbikge1xuICAgIEZvdW5kYXRpb24uVHJpZ2dlcnMgPSBUcmlnZ2VyczsgLy8gTGVnYWN5IGluY2x1ZGVkIHRvIGJlIGJhY2t3YXJkcyBjb21wYXRpYmxlIGZvciBub3cuXG5cbiAgICBGb3VuZGF0aW9uLklIZWFyWW91ID0gVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZEdsb2JhbExpc3RlbmVycztcbiAgfVxufTtcblxuLy8ge2Z1bmN0aW9ufSBfc2V0dXAgKHJlcGxhY2VzIHByZXZpb3VzIGNvbnN0cnVjdG9yKSxcbi8vIHtmdW5jdGlvbn0gX2Rlc3Ryb3kgKHJlcGxhY2VzIHByZXZpb3VzIGRlc3Ryb3kpXG5cbnZhciBQbHVnaW4gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbHVnaW4oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVnaW4pO1xuXG4gICAgdGhpcy5fc2V0dXAoZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICB2YXIgcGx1Z2luTmFtZSA9IGdldFBsdWdpbk5hbWUodGhpcyk7XG4gICAgdGhpcy51dWlkID0gR2V0WW9EaWdpdHMoNiwgcGx1Z2luTmFtZSk7XG5cbiAgICBpZiAoIXRoaXMuJGVsZW1lbnQuYXR0cihcImRhdGEtXCIuY29uY2F0KHBsdWdpbk5hbWUpKSkge1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKFwiZGF0YS1cIi5jb25jYXQocGx1Z2luTmFtZSksIHRoaXMudXVpZCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBpbml0aWFsaXplZC5cbiAgICAgKiBAZXZlbnQgUGx1Z2luI2luaXRcbiAgICAgKi9cblxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwiaW5pdC56Zi5cIi5jb25jYXQocGx1Z2luTmFtZSkpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBsdWdpbiwgW3tcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5fZGVzdHJveSgpO1xuXG4gICAgICB2YXIgcGx1Z2luTmFtZSA9IGdldFBsdWdpbk5hbWUodGhpcyk7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHIoXCJkYXRhLVwiLmNvbmNhdChwbHVnaW5OYW1lKSkucmVtb3ZlRGF0YSgnemZQbHVnaW4nKVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGJlZW4gZGVzdHJveWVkLlxuICAgICAgICogQGV2ZW50IFBsdWdpbiNkZXN0cm95ZWRcbiAgICAgICAqL1xuICAgICAgLnRyaWdnZXIoXCJkZXN0cm95ZWQuemYuXCIuY29uY2F0KHBsdWdpbk5hbWUpKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBudWxsOyAvL2NsZWFuIHVwIHNjcmlwdCB0byBwcmVwIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBsdWdpbjtcbn0oKTsgLy8gQ29udmVydCBQYXNjYWxDYXNlIHRvIGtlYmFiLWNhc2Vcbi8vIFRoYW5rIHlvdTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODk1NTU4MFxuXG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZSQxKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIGdldFBsdWdpbk5hbWUob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZSQxKG9iai5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaHlwaGVuYXRlJDEob2JqLmNsYXNzTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBYmlkZSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWJpZGVcbiAqL1xuXG52YXIgQWJpZGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKEFiaWRlLCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBBYmlkZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJpZGUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBYmlkZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQWJpZGUsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBBYmlkZS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBBYmlkZVxuICAgICAqIEBmaXJlcyBBYmlkZSNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBBYmlkZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQWJpZGUnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgQWJpZGUgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IEFiaWRlIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGlucHV0cyA9ICQubWVyZ2UoIC8vIENvbnNpZGVyIGFzIGlucHV0IHRvIHZhbGlkYXRlOlxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdpbnB1dCcpLm5vdCgnW3R5cGU9c3VibWl0XScpLCAvLyAqIGFsbCBpbnB1dCBmaWVsZHMgZXhwZWN0IHN1Ym1pdFxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCd0ZXh0YXJlYSwgc2VsZWN0JykgLy8gKiBhbGwgdGV4dGFyZWFzIGFuZCBzZWxlY3QgZmllbGRzXG4gICAgICApO1xuICAgICAgdmFyICRnbG9iYWxFcnJvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpOyAvLyBBZGQgYTExeSBhdHRyaWJ1dGVzIHRvIGFsbCBmaWVsZHNcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hMTF5QXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLiRpbnB1dHMuZWFjaChmdW5jdGlvbiAoaSwgaW5wdXQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmFkZEExMXlBdHRyaWJ1dGVzKCQoaW5wdXQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRnbG9iYWxFcnJvcnMuZWFjaChmdW5jdGlvbiAoaSwgZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmFkZEdsb2JhbEVycm9yQTExeUF0dHJpYnV0ZXMoJChlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgQWJpZGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLmFiaWRlJykub24oJ3Jlc2V0LnpmLmFiaWRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMucmVzZXRGb3JtKCk7XG4gICAgICB9KS5vbignc3VibWl0LnpmLmFiaWRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnZhbGlkYXRlRm9ybSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGVPbiA9PT0gJ2ZpZWxkQ2hhbmdlJykge1xuICAgICAgICB0aGlzLiRpbnB1dHMub2ZmKCdjaGFuZ2UuemYuYWJpZGUnKS5vbignY2hhbmdlLnpmLmFiaWRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBfdGhpczMudmFsaWRhdGVJbnB1dCgkKGUudGFyZ2V0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxpdmVWYWxpZGF0ZSkge1xuICAgICAgICB0aGlzLiRpbnB1dHMub2ZmKCdpbnB1dC56Zi5hYmlkZScpLm9uKCdpbnB1dC56Zi5hYmlkZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgX3RoaXMzLnZhbGlkYXRlSW5wdXQoJChlLnRhcmdldCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWxpZGF0ZU9uQmx1cikge1xuICAgICAgICB0aGlzLiRpbnB1dHMub2ZmKCdibHVyLnpmLmFiaWRlJykub24oJ2JsdXIuemYuYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIF90aGlzMy52YWxpZGF0ZUlucHV0KCQoZS50YXJnZXQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIEFiaWRlIHVwb24gRE9NIGNoYW5nZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVmbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIGZvcm0gZWxlbWVudCBoYXMgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBhbmQgaWYgaXQncyBjaGVja2VkIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVxdWlyZWRDaGVja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1aXJlZENoZWNrKCRlbCkge1xuICAgICAgaWYgKCEkZWwuYXR0cigncmVxdWlyZWQnKSkgcmV0dXJuIHRydWU7XG4gICAgICB2YXIgaXNHb29kID0gdHJ1ZTtcblxuICAgICAgc3dpdGNoICgkZWxbMF0udHlwZSkge1xuICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgaXNHb29kID0gJGVsWzBdLmNoZWNrZWQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XG4gICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XG4gICAgICAgICAgdmFyIG9wdCA9ICRlbC5maW5kKCdvcHRpb246c2VsZWN0ZWQnKTtcbiAgICAgICAgICBpZiAoIW9wdC5sZW5ndGggfHwgIW9wdC52YWwoKSkgaXNHb29kID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoISRlbC52YWwoKSB8fCAhJGVsLnZhbCgpLmxlbmd0aCkgaXNHb29kID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0dvb2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldDpcbiAgICAgKiAtIEJhc2VkIG9uICRlbCwgdGhlIGZpcnN0IGVsZW1lbnQocykgY29ycmVzcG9uZGluZyB0byBgZm9ybUVycm9yU2VsZWN0b3JgIGluIHRoaXMgb3JkZXI6XG4gICAgICogICAxLiBUaGUgZWxlbWVudCdzIGRpcmVjdCBzaWJsaW5nKCdzKS5cbiAgICAgKiAgIDIuIFRoZSBlbGVtZW50J3MgcGFyZW50J3MgY2hpbGRyZW4uXG4gICAgICogLSBFbGVtZW50KHMpIHdpdGggdGhlIGF0dHJpYnV0ZSBgW2RhdGEtZm9ybS1lcnJvci1mb3JdYCBzZXQgd2l0aCB0aGUgZWxlbWVudCdzIGlkLlxuICAgICAqXG4gICAgICogVGhpcyBhbGxvd3MgZm9yIG11bHRpcGxlIGZvcm0gZXJyb3JzIHBlciBpbnB1dCwgdGhvdWdoIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBmb3JtIGVycm9ycyB3aWxsIGJlIHNob3duLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGFzIHJlZmVyZW5jZSB0byBmaW5kIHRoZSBmb3JtIGVycm9yIHNlbGVjdG9yLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGpRdWVyeSBvYmplY3Qgd2l0aCB0aGUgc2VsZWN0b3IuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kRm9ybUVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRGb3JtRXJyb3IoJGVsKSB7XG4gICAgICB2YXIgaWQgPSAkZWxbMF0uaWQ7XG4gICAgICB2YXIgJGVycm9yID0gJGVsLnNpYmxpbmdzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7XG5cbiAgICAgIGlmICghJGVycm9yLmxlbmd0aCkge1xuICAgICAgICAkZXJyb3IgPSAkZWwucGFyZW50KCkuZmluZCh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgJGVycm9yID0gJGVycm9yLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoXCJbZGF0YS1mb3JtLWVycm9yLWZvcj1cXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJdXCIpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGlzIG9yZGVyOlxuICAgICAqIDIuIFRoZSA8bGFiZWw+IHdpdGggdGhlIGF0dHJpYnV0ZSBgW2Zvcj1cInNvbWVJbnB1dElkXCJdYFxuICAgICAqIDMuIFRoZSBgLmNsb3Nlc3QoKWAgPGxhYmVsPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbmRMYWJlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTGFiZWwoJGVsKSB7XG4gICAgICB2YXIgaWQgPSAkZWxbMF0uaWQ7XG4gICAgICB2YXIgJGxhYmVsID0gdGhpcy4kZWxlbWVudC5maW5kKFwibGFiZWxbZm9yPVxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIl1cIikpO1xuXG4gICAgICBpZiAoISRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICRlbC5jbG9zZXN0KCdsYWJlbCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJGxhYmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNldCBvZiBsYWJlbHMgYXNzb2NpYXRlZCB3aXRoIGEgc2V0IG9mIHJhZGlvIGVscyBpbiB0aGlzIG9yZGVyXG4gICAgICogMi4gVGhlIDxsYWJlbD4gd2l0aCB0aGUgYXR0cmlidXRlIGBbZm9yPVwic29tZUlucHV0SWRcIl1gXG4gICAgICogMy4gVGhlIGAuY2xvc2VzdCgpYCA8bGFiZWw+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFJhZGlvTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRSYWRpb0xhYmVscygkZWxzKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGxhYmVscyA9ICRlbHMubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICB2YXIgaWQgPSBlbC5pZDtcblxuICAgICAgICB2YXIgJGxhYmVsID0gX3RoaXM0LiRlbGVtZW50LmZpbmQoXCJsYWJlbFtmb3I9XFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXVwiKSk7XG5cbiAgICAgICAgaWYgKCEkbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgJGxhYmVsID0gJChlbCkuY2xvc2VzdCgnbGFiZWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbGFiZWxbMF07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAkKGxhYmVscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIENTUyBlcnJvciBjbGFzcyBhcyBzcGVjaWZpZWQgYnkgdGhlIEFiaWRlIHNldHRpbmdzIHRvIHRoZSBsYWJlbCwgaW5wdXQsIGFuZCB0aGUgZm9ybVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgY2xhc3MgdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEVycm9yQ2xhc3Nlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFcnJvckNsYXNzZXMoJGVsKSB7XG4gICAgICB2YXIgJGxhYmVsID0gdGhpcy5maW5kTGFiZWwoJGVsKTtcbiAgICAgIHZhciAkZm9ybUVycm9yID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbCk7XG5cbiAgICAgIGlmICgkbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICRsYWJlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRmb3JtRXJyb3IubGVuZ3RoKSB7XG4gICAgICAgICRmb3JtRXJyb3IuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoe1xuICAgICAgICAnZGF0YS1pbnZhbGlkJzogJycsXG4gICAgICAgICdhcmlhLWludmFsaWQnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBbZm9yXSBhbmQgW3JvbGU9YWxlcnRdIGF0dHJpYnV0ZXMgdG8gYWxsIGZvcm0gZXJyb3IgdGFyZ2V0dGluZyAkZWwsXG4gICAgICogYW5kIFthcmlhLWRlc2NyaWJlZGJ5XSBhdHRyaWJ1dGUgdG8gJGVsIHRvd2FyZCB0aGUgZmlyc3QgZm9ybSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQTExeUF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQTExeUF0dHJpYnV0ZXMoJGVsKSB7XG4gICAgICB2YXIgJGVycm9ycyA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWwpO1xuICAgICAgdmFyICRsYWJlbHMgPSAkZXJyb3JzLmZpbHRlcignbGFiZWwnKTtcbiAgICAgIHZhciAkZXJyb3IgPSAkZXJyb3JzLmZpcnN0KCk7XG4gICAgICBpZiAoISRlcnJvcnMubGVuZ3RoKSByZXR1cm47IC8vIFNldCBbYXJpYS1kZXNjcmliZWRieV0gb24gdGhlIGlucHV0IHRvd2FyZCB0aGUgZmlyc3QgZm9ybSBlcnJvciBpZiBpdCBpcyBub3Qgc2V0XG5cbiAgICAgIGlmICh0eXBlb2YgJGVsLmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBmaXJzdCBlcnJvciBJRCBvciBjcmVhdGUgb25lXG4gICAgICAgIHZhciBlcnJvcklkID0gJGVycm9yLmF0dHIoJ2lkJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVycm9ySWQgPSBHZXRZb0RpZ2l0cyg2LCAnYWJpZGUtZXJyb3InKTtcbiAgICAgICAgICAkZXJyb3IuYXR0cignaWQnLCBlcnJvcklkKTtcbiAgICAgICAgfVxuICAgICAgICAkZWwuYXR0cignYXJpYS1kZXNjcmliZWRieScsIGVycm9ySWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGxhYmVscy5maWx0ZXIoJ1tmb3JdJykubGVuZ3RoIDwgJGxhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBpbnB1dCBJRCBvciBjcmVhdGUgb25lXG4gICAgICAgIHZhciBlbGVtSWQgPSAkZWwuYXR0cignaWQnKTtcblxuICAgICAgICBpZiAodHlwZW9mIGVsZW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBlbGVtSWQgPSBHZXRZb0RpZ2l0cyg2LCAnYWJpZGUtaW5wdXQnKTtcbiAgICAgICAgICAkZWwuYXR0cignaWQnLCBlbGVtSWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgJGxhYmVscy5lYWNoKGZ1bmN0aW9uIChpLCBsYWJlbCkge1xuICAgICAgICAgIHZhciAkbGFiZWwgPSAkKGxhYmVsKTtcbiAgICAgICAgICBpZiAodHlwZW9mICRsYWJlbC5hdHRyKCdmb3InKSA9PT0gJ3VuZGVmaW5lZCcpICRsYWJlbC5hdHRyKCdmb3InLCBlbGVtSWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRm9yIGVhY2ggZXJyb3IgdGFyZ2V0aW5nICRlbCwgc2V0IFtyb2xlPWFsZXJ0XSBpZiBpdCBpcyBub3Qgc2V0LlxuXG5cbiAgICAgICRlcnJvcnMuZWFjaChmdW5jdGlvbiAoaSwgbGFiZWwpIHtcbiAgICAgICAgdmFyICRsYWJlbCA9ICQobGFiZWwpO1xuICAgICAgICBpZiAodHlwZW9mICRsYWJlbC5hdHRyKCdyb2xlJykgPT09ICd1bmRlZmluZWQnKSAkbGFiZWwuYXR0cigncm9sZScsICdhbGVydCcpO1xuICAgICAgfSkuZW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgW2FyaWEtbGl2ZV0gYXR0cmlidXRlIHRvIHRoZSBnaXZlbiBnbG9iYWwgZm9ybSBlcnJvciAkZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSBhdHRyaWJ1dGUgdG9cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEdsb2JhbEVycm9yQTExeUF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkR2xvYmFsRXJyb3JBMTF5QXR0cmlidXRlcygkZWwpIHtcbiAgICAgIGlmICh0eXBlb2YgJGVsLmF0dHIoJ2FyaWEtbGl2ZScpID09PSAndW5kZWZpbmVkJykgJGVsLmF0dHIoJ2FyaWEtbGl2ZScsIHRoaXMub3B0aW9ucy5hMTF5RXJyb3JMZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBDU1MgZXJyb3IgY2xhc3NlcyBldGMgZnJvbSBhbiBlbnRpcmUgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSAtIEEgc3RyaW5nIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lIG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAgICpcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKGdyb3VwTmFtZSkge1xuICAgICAgdmFyICRlbHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCI6cmFkaW9bbmFtZT1cXFwiXCIuY29uY2F0KGdyb3VwTmFtZSwgXCJcXFwiXVwiKSk7XG4gICAgICB2YXIgJGxhYmVscyA9IHRoaXMuZmluZFJhZGlvTGFiZWxzKCRlbHMpO1xuICAgICAgdmFyICRmb3JtRXJyb3JzID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbHMpO1xuXG4gICAgICBpZiAoJGxhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgJGxhYmVscy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRmb3JtRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAkZm9ybUVycm9ycy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xuICAgICAgfVxuXG4gICAgICAkZWxzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoe1xuICAgICAgICAnZGF0YS1pbnZhbGlkJzogbnVsbCxcbiAgICAgICAgJ2FyaWEtaW52YWxpZCc6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIENTUyBlcnJvciBjbGFzcyBhcyBzcGVjaWZpZWQgYnkgdGhlIEFiaWRlIHNldHRpbmdzIGZyb20gdGhlIGxhYmVsLCBpbnB1dCwgYW5kIHRoZSBmb3JtXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFcnJvckNsYXNzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXJyb3JDbGFzc2VzKCRlbCkge1xuICAgICAgLy8gcmFkaW9zIG5lZWQgdG8gY2xlYXIgYWxsIG9mIHRoZSBlbHNcbiAgICAgIGlmICgkZWxbMF0udHlwZSA9PSAncmFkaW8nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKCRlbC5hdHRyKCduYW1lJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgJGxhYmVsID0gdGhpcy5maW5kTGFiZWwoJGVsKTtcbiAgICAgIHZhciAkZm9ybUVycm9yID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbCk7XG5cbiAgICAgIGlmICgkbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICRsYWJlbC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRmb3JtRXJyb3IubGVuZ3RoKSB7XG4gICAgICAgICRmb3JtRXJyb3IucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoe1xuICAgICAgICAnZGF0YS1pbnZhbGlkJzogbnVsbCxcbiAgICAgICAgJ2FyaWEtaW52YWxpZCc6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHb2VzIHRocm91Z2ggYSBmb3JtIHRvIGZpbmQgaW5wdXRzIGFuZCBwcm9jZWVkcyB0byB2YWxpZGF0ZSB0aGVtIGluIHdheXMgc3BlY2lmaWMgdG8gdGhlaXIgdHlwZS5cbiAgICAgKiBJZ25vcmVzIGlucHV0cyB3aXRoIGRhdGEtYWJpZGUtaWdub3JlLCB0eXBlPVwiaGlkZGVuXCIgb3IgZGlzYWJsZWQgYXR0cmlidXRlcyBzZXRcbiAgICAgKiBAZmlyZXMgQWJpZGUjaW52YWxpZFxuICAgICAqIEBmaXJlcyBBYmlkZSN2YWxpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byB2YWxpZGF0ZSwgc2hvdWxkIGJlIGFuIEhUTUwgaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZ29vZFRvR28gLSBJZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGVJbnB1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZUlucHV0KCRlbCkge1xuICAgICAgdmFyIGNsZWFyUmVxdWlyZSA9IHRoaXMucmVxdWlyZWRDaGVjaygkZWwpLFxuICAgICAgICAgIHZhbGlkYXRlZCA9IGZhbHNlLFxuICAgICAgICAgIGN1c3RvbVZhbGlkYXRvciA9IHRydWUsXG4gICAgICAgICAgdmFsaWRhdG9yID0gJGVsLmF0dHIoJ2RhdGEtdmFsaWRhdG9yJyksXG4gICAgICAgICAgZXF1YWxUbyA9IHRydWU7IC8vIGRvbid0IHZhbGlkYXRlIGlnbm9yZWQgaW5wdXRzIG9yIGhpZGRlbiBpbnB1dHMgb3IgZGlzYWJsZWQgaW5wdXRzXG5cbiAgICAgIGlmICgkZWwuaXMoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKSB8fCAkZWwuaXMoJ1t0eXBlPVwiaGlkZGVuXCJdJykgfHwgJGVsLmlzKCdbZGlzYWJsZWRdJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoJGVsWzBdLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgIHZhbGlkYXRlZCA9IHRoaXMudmFsaWRhdGVSYWRpbygkZWwuYXR0cignbmFtZScpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgdmFsaWRhdGVkID0gY2xlYXJSZXF1aXJlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGNhc2UgJ3NlbGVjdC1vbmUnOlxuICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxuICAgICAgICAgIHZhbGlkYXRlZCA9IGNsZWFyUmVxdWlyZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhbGlkYXRlZCA9IHRoaXMudmFsaWRhdGVUZXh0KCRlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgY3VzdG9tVmFsaWRhdG9yID0gdGhpcy5tYXRjaFZhbGlkYXRpb24oJGVsLCB2YWxpZGF0b3IsICRlbC5hdHRyKCdyZXF1aXJlZCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKSkge1xuICAgICAgICBlcXVhbFRvID0gdGhpcy5vcHRpb25zLnZhbGlkYXRvcnMuZXF1YWxUbygkZWwpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ29vZFRvR28gPSBbY2xlYXJSZXF1aXJlLCB2YWxpZGF0ZWQsIGN1c3RvbVZhbGlkYXRvciwgZXF1YWxUb10uaW5kZXhPZihmYWxzZSkgPT09IC0xO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAoZ29vZFRvR28gPyAndmFsaWQnIDogJ2ludmFsaWQnKSArICcuemYuYWJpZGUnO1xuXG4gICAgICBpZiAoZ29vZFRvR28pIHtcbiAgICAgICAgLy8gUmUtdmFsaWRhdGUgaW5wdXRzIHRoYXQgZGVwZW5kIG9uIHRoaXMgb25lIHdpdGggZXF1YWx0b1xuICAgICAgICB2YXIgZGVwZW5kZW50RWxlbWVudHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCJbZGF0YS1lcXVhbHRvPVxcXCJcIi5jb25jYXQoJGVsLmF0dHIoJ2lkJyksIFwiXFxcIl1cIikpO1xuXG4gICAgICAgIGlmIChkZXBlbmRlbnRFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgZGVwZW5kZW50RWxlbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzKS52YWwoKSkge1xuICAgICAgICAgICAgICBfdGhpcy52YWxpZGF0ZUlucHV0KCQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXNbZ29vZFRvR28gPyAncmVtb3ZlRXJyb3JDbGFzc2VzJyA6ICdhZGRFcnJvckNsYXNzZXMnXSgkZWwpO1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBpbnB1dCBpcyBkb25lIGNoZWNraW5nIGZvciB2YWxpZGF0aW9uLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgdmFsaWQuemYuYWJpZGVgIG9yIGBpbnZhbGlkLnpmLmFiaWRlYFxuICAgICAgICogVHJpZ2dlciBpbmNsdWRlcyB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIGlucHV0LlxuICAgICAgICogQGV2ZW50IEFiaWRlI3ZhbGlkXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjaW52YWxpZFxuICAgICAgICovXG5cbiAgICAgICRlbC50cmlnZ2VyKG1lc3NhZ2UsIFskZWxdKTtcbiAgICAgIHJldHVybiBnb29kVG9HbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR29lcyB0aHJvdWdoIGEgZm9ybSBhbmQgaWYgdGhlcmUgYXJlIGFueSBpbnZhbGlkIGlucHV0cywgaXQgd2lsbCBkaXNwbGF5IHRoZSBmb3JtIGVycm9yIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gbm9FcnJvciAtIHRydWUgaWYgbm8gZXJyb3JzIHdlcmUgZGV0ZWN0ZWQuLi5cbiAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybXZhbGlkXG4gICAgICogQGZpcmVzIEFiaWRlI2Zvcm1pbnZhbGlkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZUZvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVGb3JtKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBhY2MgPSBbXTtcblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kaW5wdXRzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBhY2MucHVzaChfdGhpcy52YWxpZGF0ZUlucHV0KCQodGhpcykpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG5vRXJyb3IgPSBhY2MuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKS5lYWNoKGZ1bmN0aW9uIChpLCBlbGVtKSB7XG4gICAgICAgIHZhciAkZWxlbSA9ICQoZWxlbSk7IC8vIEVuc3VyZSBhMTF5IGF0dHJpYnV0ZXMgYXJlIHNldFxuXG4gICAgICAgIGlmIChfdGhpczUub3B0aW9ucy5hMTF5QXR0cmlidXRlcykgX3RoaXM1LmFkZEdsb2JhbEVycm9yQTExeUF0dHJpYnV0ZXMoJGVsZW0pOyAvLyBTaG93IG9yIGhpZGUgdGhlIGVycm9yXG5cbiAgICAgICAgJGVsZW0uY3NzKCdkaXNwbGF5Jywgbm9FcnJvciA/ICdub25lJyA6ICdibG9jaycpO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGZvcm0gaXMgZmluaXNoZWQgdmFsaWRhdGluZy4gRXZlbnQgdHJpZ2dlciBpcyBlaXRoZXIgYGZvcm12YWxpZC56Zi5hYmlkZWAgb3IgYGZvcm1pbnZhbGlkLnpmLmFiaWRlYC5cbiAgICAgICAqIFRyaWdnZXIgaW5jbHVkZXMgdGhlIGVsZW1lbnQgb2YgdGhlIGZvcm0uXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjZm9ybXZhbGlkXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjZm9ybWludmFsaWRcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoKG5vRXJyb3IgPyAnZm9ybXZhbGlkJyA6ICdmb3JtaW52YWxpZCcpICsgJy56Zi5hYmlkZScsIFt0aGlzLiRlbGVtZW50XSk7XG4gICAgICByZXR1cm4gbm9FcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIGEgbm90IGEgdGV4dCBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB0aGUgcGF0dGVybiBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZS4gSWYgbm8gbWF0Y2hpbmcgcGF0dGVybiBpcyBmb3VuZCwgcmV0dXJucyB0cnVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHZhbGlkYXRlLCBzaG91bGQgYmUgYSB0ZXh0IGlucHV0IEhUTUwgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIC0gc3RyaW5nIHZhbHVlIG9mIG9uZSBvZiB0aGUgUmVnRXggcGF0dGVybnMgaW4gQWJpZGUub3B0aW9ucy5wYXR0ZXJuc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgdGhlIGlucHV0IHZhbHVlIG1hdGNoZXMgdGhlIHBhdHRlcm4gc3BlY2lmaWVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZVRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVUZXh0KCRlbCwgcGF0dGVybikge1xuICAgICAgLy8gQSBwYXR0ZXJuIGNhbiBiZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBiZSBpbmZlcmVkIGZyb20gdGhlIGlucHV0J3MgXCJwYXR0ZXJuXCIgYXR0cmlidXRlLCBvciBpdCdzIFwidHlwZVwiIGF0dHJpYnV0ZVxuICAgICAgcGF0dGVybiA9IHBhdHRlcm4gfHwgJGVsLmF0dHIoJ3BhdHRlcm4nKSB8fCAkZWwuYXR0cigndHlwZScpO1xuICAgICAgdmFyIGlucHV0VGV4dCA9ICRlbC52YWwoKTtcbiAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoaW5wdXRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0aGUgcGF0dGVybiBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQgaXMgaW4gQWJpZGUncyBsaXN0IG9mIHBhdHRlcm5zLCB0aGVuIHRlc3QgdGhhdCByZWdleHBcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXR0ZXJucy5oYXNPd25Qcm9wZXJ0eShwYXR0ZXJuKSkge1xuICAgICAgICAgIHZhbGlkID0gdGhpcy5vcHRpb25zLnBhdHRlcm5zW3BhdHRlcm5dLnRlc3QoaW5wdXRUZXh0KTtcbiAgICAgICAgfSAvLyBJZiB0aGUgcGF0dGVybiBuYW1lIGlzbid0IGFsc28gdGhlIHR5cGUgYXR0cmlidXRlIG9mIHRoZSBmaWVsZCwgdGhlbiB0ZXN0IGl0IGFzIGEgcmVnZXhwXG4gICAgICAgIGVsc2UgaWYgKHBhdHRlcm4gIT09ICRlbC5hdHRyKCd0eXBlJykpIHtcbiAgICAgICAgICAgIHZhbGlkID0gbmV3IFJlZ0V4cChwYXR0ZXJuKS50ZXN0KGlucHV0VGV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9IC8vIEFuIGVtcHR5IGZpZWxkIGlzIHZhbGlkIGlmIGl0J3Mgbm90IHJlcXVpcmVkXG4gICAgICBlbHNlIGlmICghJGVsLnByb3AoJ3JlcXVpcmVkJykpIHtcbiAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3IgYSBub3QgYSByYWRpbyBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZXF1aXJlZCBhbmQgc2VsZWN0ZWQuIEFsdGhvdWdoIHRoZSBmdW5jdGlvbiB0YXJnZXRzIGEgc2luZ2xlIGA8aW5wdXQ+YCwgaXQgdmFsaWRhdGVzIGJ5IGNoZWNraW5nIHRoZSBgcmVxdWlyZWRgIGFuZCBgY2hlY2tlZGAgcHJvcGVydGllcyBvZiBhbGwgcmFkaW8gYnV0dG9ucyBpbiBpdHMgZ3JvdXAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSAtIEEgc3RyaW5nIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lIG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdCBsZWFzdCBvbmUgcmFkaW8gaW5wdXQgaGFzIGJlZW4gc2VsZWN0ZWQgKGlmIGl0J3MgcmVxdWlyZWQpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZVJhZGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlUmFkaW8oZ3JvdXBOYW1lKSB7XG4gICAgICAvLyBJZiBhdCBsZWFzdCBvbmUgcmFkaW8gaW4gdGhlIGdyb3VwIGhhcyB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUsIHRoZSBncm91cCBpcyBjb25zaWRlcmVkIHJlcXVpcmVkXG4gICAgICAvLyBQZXIgVzNDIHNwZWMsIGFsbCByYWRpbyBidXR0b25zIGluIGEgZ3JvdXAgc2hvdWxkIGhhdmUgYHJlcXVpcmVkYCwgYnV0IHdlJ3JlIGJlaW5nIG5pY2VcbiAgICAgIHZhciAkZ3JvdXAgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCI6cmFkaW9bbmFtZT1cXFwiXCIuY29uY2F0KGdyb3VwTmFtZSwgXCJcXFwiXVwiKSk7XG4gICAgICB2YXIgdmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICByZXF1aXJlZCA9IGZhbHNlOyAvLyBGb3IgdGhlIGdyb3VwIHRvIGJlIHJlcXVpcmVkLCBhdCBsZWFzdCBvbmUgcmFkaW8gbmVlZHMgdG8gYmUgcmVxdWlyZWRcblxuICAgICAgJGdyb3VwLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgaWYgKCQoZSkuYXR0cigncmVxdWlyZWQnKSkge1xuICAgICAgICAgIHJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlcXVpcmVkKSB2YWxpZCA9IHRydWU7XG5cbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgLy8gRm9yIHRoZSBncm91cCB0byBiZSB2YWxpZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIGNoZWNrZWRcbiAgICAgICAgJGdyb3VwLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICBpZiAoJChlKS5wcm9wKCdjaGVja2VkJykpIHtcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgc2VsZWN0ZWQgaW5wdXQgcGFzc2VzIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uIE11bHRpcGxlIHZhbGlkYXRpb25zIGNhbiBiZSB1c2VkLCBpZiBwYXNzZWQgdG8gdGhlIGVsZW1lbnQgd2l0aCBgZGF0YS12YWxpZGF0b3I9XCJmb28gYmFyIGJhelwiYCBpbiBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBpbnB1dCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWxpZGF0b3JzIC0gYSBzdHJpbmcgb2YgZnVuY3Rpb24gbmFtZXMgbWF0Y2hpbmcgZnVuY3Rpb25zIGluIHRoZSBBYmlkZS5vcHRpb25zLnZhbGlkYXRvcnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVxdWlyZWQgLSBzZWxmIGV4cGxhbmF0b3J5P1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgdmFsaWRhdGlvbnMgcGFzc2VkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hWYWxpZGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoVmFsaWRhdGlvbigkZWwsIHZhbGlkYXRvcnMsIHJlcXVpcmVkKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgcmVxdWlyZWQgPSByZXF1aXJlZCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIHZhciBjbGVhciA9IHZhbGlkYXRvcnMuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5vcHRpb25zLnZhbGlkYXRvcnNbdl0oJGVsLCByZXF1aXJlZCwgJGVsLnBhcmVudCgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsZWFyLmluZGV4T2YoZmFsc2UpID09PSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGZvcm0gaW5wdXRzIGFuZCBzdHlsZXNcbiAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybXJlc2V0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNldEZvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRGb3JtKCkge1xuICAgICAgdmFyICRmb3JtID0gdGhpcy4kZWxlbWVudCxcbiAgICAgICAgICBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgJChcIi5cIi5jb25jYXQob3B0cy5sYWJlbEVycm9yQ2xhc3MpLCAkZm9ybSkubm90KCdzbWFsbCcpLnJlbW92ZUNsYXNzKG9wdHMubGFiZWxFcnJvckNsYXNzKTtcbiAgICAgICQoXCIuXCIuY29uY2F0KG9wdHMuaW5wdXRFcnJvckNsYXNzKSwgJGZvcm0pLm5vdCgnc21hbGwnKS5yZW1vdmVDbGFzcyhvcHRzLmlucHV0RXJyb3JDbGFzcyk7XG4gICAgICAkKFwiXCIuY29uY2F0KG9wdHMuZm9ybUVycm9yU2VsZWN0b3IsIFwiLlwiKS5jb25jYXQob3B0cy5mb3JtRXJyb3JDbGFzcykpLnJlbW92ZUNsYXNzKG9wdHMuZm9ybUVycm9yQ2xhc3MpO1xuICAgICAgJGZvcm0uZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICQoJzppbnB1dCcsICRmb3JtKS5ub3QoJzpidXR0b24sIDpzdWJtaXQsIDpyZXNldCwgOmhpZGRlbiwgOnJhZGlvLCA6Y2hlY2tib3gsIFtkYXRhLWFiaWRlLWlnbm9yZV0nKS52YWwoJycpLmF0dHIoe1xuICAgICAgICAnZGF0YS1pbnZhbGlkJzogbnVsbCxcbiAgICAgICAgJ2FyaWEtaW52YWxpZCc6IG51bGxcbiAgICAgIH0pO1xuICAgICAgJCgnOmlucHV0OnJhZGlvJywgJGZvcm0pLm5vdCgnW2RhdGEtYWJpZGUtaWdub3JlXScpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSkuYXR0cih7XG4gICAgICAgICdkYXRhLWludmFsaWQnOiBudWxsLFxuICAgICAgICAnYXJpYS1pbnZhbGlkJzogbnVsbFxuICAgICAgfSk7XG4gICAgICAkKCc6aW5wdXQ6Y2hlY2tib3gnLCAkZm9ybSkubm90KCdbZGF0YS1hYmlkZS1pZ25vcmVdJykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKS5hdHRyKHtcbiAgICAgICAgJ2RhdGEtaW52YWxpZCc6IG51bGwsXG4gICAgICAgICdhcmlhLWludmFsaWQnOiBudWxsXG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgZm9ybSBoYXMgYmVlbiByZXNldC5cbiAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtcmVzZXRcbiAgICAgICAqL1xuXG4gICAgICAkZm9ybS50cmlnZ2VyKCdmb3JtcmVzZXQuemYuYWJpZGUnLCBbJGZvcm1dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgQWJpZGUuXG4gICAgICogUmVtb3ZlcyBlcnJvciBzdHlsZXMgYW5kIGNsYXNzZXMgZnJvbSBlbGVtZW50cywgd2l0aG91dCByZXNldHRpbmcgdGhlaXIgdmFsdWVzLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLmFiaWRlJykuZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgIHRoaXMuJGlucHV0cy5vZmYoJy5hYmlkZScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmVFcnJvckNsYXNzZXMoJCh0aGlzKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWJpZGU7XG59KFBsdWdpbik7XG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICovXG5cblxuQWJpZGUuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBldmVudCB0byB2YWxpZGF0ZSBpbnB1dHMuIENoZWNrYm94ZXMgYW5kIHJhZGlvcyB2YWxpZGF0ZSBpbW1lZGlhdGVseS5cbiAgICogUmVtb3ZlIG9yIGNoYW5nZSB0aGlzIHZhbHVlIGZvciBtYW51YWwgdmFsaWRhdGlvbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2ZpZWxkQ2hhbmdlJ1xuICAgKi9cbiAgdmFsaWRhdGVPbjogJ2ZpZWxkQ2hhbmdlJyxcblxuICAvKipcbiAgICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byBpbnB1dCBsYWJlbHMgb24gZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2lzLWludmFsaWQtbGFiZWwnXG4gICAqL1xuICBsYWJlbEVycm9yQ2xhc3M6ICdpcy1pbnZhbGlkLWxhYmVsJyxcblxuICAvKipcbiAgICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byBpbnB1dHMgb24gZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2lzLWludmFsaWQtaW5wdXQnXG4gICAqL1xuICBpbnB1dEVycm9yQ2xhc3M6ICdpcy1pbnZhbGlkLWlucHV0JyxcblxuICAvKipcbiAgICogQ2xhc3Mgc2VsZWN0b3IgdG8gdXNlIHRvIHRhcmdldCBGb3JtIEVycm9ycyBmb3Igc2hvdy9oaWRlLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcuZm9ybS1lcnJvcidcbiAgICovXG4gIGZvcm1FcnJvclNlbGVjdG9yOiAnLmZvcm0tZXJyb3InLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhZGRlZCB0byBGb3JtIEVycm9ycyBvbiBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnaXMtdmlzaWJsZSdcbiAgICovXG4gIGZvcm1FcnJvckNsYXNzOiAnaXMtdmlzaWJsZScsXG5cbiAgLyoqXG4gICAqIElmIHRydWUsIGF1dG9tYXRpY2FsbHkgaW5zZXJ0IHdoZW4gcG9zc2libGU6XG4gICAqIC0gYFthcmlhLWRlc2NyaWJlZGJ5XWAgb24gZmllbGRzXG4gICAqIC0gYFtyb2xlPWFsZXJ0XWAgb24gZm9ybSBlcnJvcnMgYW5kIGBbZm9yXWAgb24gZm9ybSBlcnJvciBsYWJlbHNcbiAgICogLSBgW2FyaWEtbGl2ZV1gIG9uIGdsb2JhbCBlcnJvcnMgYFtkYXRhLWFiaWRlLWVycm9yXWAgKHNlZSBvcHRpb24gYGExMXlFcnJvckxldmVsYCkuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGExMXlBdHRyaWJ1dGVzOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBbYXJpYS1saXZlXSBhdHRyaWJ1dGUgdmFsdWUgdG8gYmUgYXBwbGllZCBvbiBnbG9iYWwgZXJyb3JzIGBbZGF0YS1hYmlkZS1lcnJvcl1gLlxuICAgKiBPcHRpb25zIGFyZTogJ2Fzc2VydGl2ZScsICdwb2xpdGUnIGFuZCAnb2ZmJy9udWxsXG4gICAqIEBvcHRpb25cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BY2Nlc3NpYmlsaXR5L0FSSUEvQVJJQV9MaXZlX1JlZ2lvbnNcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2Fzc2VydGl2ZSdcbiAgICovXG4gIGExMXlFcnJvckxldmVsOiAnYXNzZXJ0aXZlJyxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgdG8gdmFsaWRhdGUgdGV4dCBpbnB1dHMgb24gYW55IHZhbHVlIGNoYW5nZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGxpdmVWYWxpZGF0ZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIHRvIHZhbGlkYXRlIGlucHV0cyBvbiBibHVyLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdmFsaWRhdGVPbkJsdXI6IGZhbHNlLFxuICBwYXR0ZXJuczoge1xuICAgIGFscGhhOiAvXlthLXpBLVpdKyQvLFxuICAgIGFscGhhX251bWVyaWM6IC9eW2EtekEtWjAtOV0rJC8sXG4gICAgaW50ZWdlcjogL15bLStdP1xcZCskLyxcbiAgICBudW1iZXI6IC9eWy0rXT9cXGQqKD86W1xcLlxcLF1cXGQrKT8kLyxcbiAgICAvLyBhbWV4LCB2aXNhLCBkaW5lcnNcbiAgICBjYXJkOiAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXwoPzoyMjJbMS05XXwyWzMtNl1bMC05XXsyfXwyN1swLTFdWzAtOV18MjcyMClbMC05XXsxMn18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9KSQvLFxuICAgIGN2djogL14oWzAtOV0pezMsNH0kLyxcbiAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9zdGF0ZXMtb2YtdGhlLXR5cGUtYXR0cmlidXRlLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3NcbiAgICBlbWFpbDogL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrJC8sXG4gICAgLy8gRnJvbSBDb21tb25SZWdleEpTIChAdGFseXNzb25vYylcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGFseXNzb25vYy9Db21tb25SZWdleEpTL2Jsb2IvZTI5MDFiOWY1NzIyMmJjMTQwNjlkYzhmMDU5OGQ1ZjQxMjU1NTQxMS9saWIvY29tbW9ucmVnZXguanMjTDc2XG4gICAgLy8gRm9yIG1vcmUgcmVzdHJpY3RpdmUgVVJMIFJlZ2V4cywgc2VlIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL3VybC1yZWdleC5cbiAgICB1cmw6IC9eKCg/OihodHRwcz98ZnRwcz98ZmlsZXxzc2h8c2Z0cCk6XFwvXFwvfHd3d1xcZHswLDN9Wy5dfFthLXowLTkuXFwtXStbLl1bYS16XXsyLDR9XFwvKSg/OlteXFxzKCk8Pl0rfFxcKCg/OlteXFxzKCk8Pl0rfCg/OlxcKFteXFxzKCk8Pl0rXFwpKSkqXFwpKSsoPzpcXCgoPzpbXlxccygpPD5dK3woPzpcXChbXlxccygpPD5dK1xcKSkpKlxcKXxbXlxcc2AhKClcXFtcXF17fTs6XFwnXCIuLDw+P1xceGFiXFx4YmJcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5XSkpJC8sXG4gICAgLy8gYWJjLmRlXG4gICAgZG9tYWluOiAvXihbYS16QS1aMC05XShbYS16QS1aMC05XFwtXXswLDYxfVthLXpBLVowLTldKT9cXC4pK1thLXpBLVpdezIsOH0kLyxcbiAgICBkYXRldGltZTogL14oWzAtMl1bMC05XXszfSlcXC0oWzAtMV1bMC05XSlcXC0oWzAtM11bMC05XSlUKFswLTVdWzAtOV0pXFw6KFswLTVdWzAtOV0pXFw6KFswLTVdWzAtOV0pKFp8KFtcXC1cXCtdKFswLTFdWzAtOV0pXFw6MDApKSQvLFxuICAgIC8vIFlZWVktTU0tRERcbiAgICBkYXRlOiAvKD86MTl8MjApWzAtOV17Mn0tKD86KD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfDFbMC05XXwyWzAtOV0pfCg/Oig/ITAyKSg/OjBbMS05XXwxWzAtMl0pLSg/OjMwKSl8KD86KD86MFsxMzU3OF18MVswMl0pLTMxKSkkLyxcbiAgICAvLyBISDpNTTpTU1xuICAgIHRpbWU6IC9eKDBbMC05XXwxWzAtOV18MlswLTNdKSg6WzAtNV1bMC05XSl7Mn0kLyxcbiAgICBkYXRlSVNPOiAvXlxcZHs0fVtcXC9cXC1dXFxkezEsMn1bXFwvXFwtXVxcZHsxLDJ9JC8sXG4gICAgLy8gTU0vREQvWVlZWVxuICAgIG1vbnRoX2RheV95ZWFyOiAvXigwWzEtOV18MVswMTJdKVstIFxcLy5dKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFwvLl1cXGR7NH0kLyxcbiAgICAvLyBERC9NTS9ZWVlZXG4gICAgZGF5X21vbnRoX3llYXI6IC9eKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFwvLl0oMFsxLTldfDFbMDEyXSlbLSBcXC8uXVxcZHs0fSQvLFxuICAgIC8vICNGRkYgb3IgI0ZGRkZGRlxuICAgIGNvbG9yOiAvXiM/KFthLWZBLUYwLTldezZ9fFthLWZBLUYwLTldezN9KSQvLFxuICAgIC8vIERvbWFpbiB8fCBVUkxcbiAgICB3ZWJzaXRlOiB7XG4gICAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIEFiaWRlLmRlZmF1bHRzLnBhdHRlcm5zWydkb21haW4nXS50ZXN0KHRleHQpIHx8IEFiaWRlLmRlZmF1bHRzLnBhdHRlcm5zWyd1cmwnXS50ZXN0KHRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT3B0aW9uYWwgdmFsaWRhdGlvbiBmdW5jdGlvbnMgdG8gYmUgdXNlZC4gYGVxdWFsVG9gIGJlaW5nIHRoZSBvbmx5IGRlZmF1bHQgaW5jbHVkZWQgZnVuY3Rpb24uXG4gICAqIEZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIG9ubHkgYSBib29sZWFuIGlmIHRoZSBpbnB1dCBpcyB2YWxpZCBvciBub3QuIEZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAqIGVsIDogVGhlIGpRdWVyeSBlbGVtZW50IHRvIHZhbGlkYXRlLlxuICAgKiByZXF1aXJlZCA6IEJvb2xlYW4gdmFsdWUgb2YgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBiZSBwcmVzZW50IG9yIG5vdC5cbiAgICogcGFyZW50IDogVGhlIGRpcmVjdCBwYXJlbnQgb2YgdGhlIGlucHV0LlxuICAgKiBAb3B0aW9uXG4gICAqL1xuICB2YWxpZGF0b3JzOiB7XG4gICAgZXF1YWxUbzogZnVuY3Rpb24gZXF1YWxUbyhlbCwgcmVxdWlyZWQsIHBhcmVudCkge1xuICAgICAgcmV0dXJuICQoXCIjXCIuY29uY2F0KGVsLmF0dHIoJ2RhdGEtZXF1YWx0bycpKSkudmFsKCkgPT09IGVsLnZhbCgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBY2NvcmRpb24gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmFjY29yZGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICovXG5cbnZhciBBY2NvcmRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKEFjY29yZGlvbiwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gQWNjb3JkaW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2NvcmRpb24pO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBY2NvcmRpb24pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFjY29yZGlvbiwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbi5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBBY2NvcmRpb25cbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGEgcGxhaW4gb2JqZWN0IHdpdGggc2V0dGluZ3MgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEFjY29yZGlvbi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQWNjb3JkaW9uJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgS2V5Ym9hcmQucmVnaXN0ZXIoJ0FjY29yZGlvbicsIHtcbiAgICAgICAgJ0VOVEVSJzogJ3RvZ2dsZScsXG4gICAgICAgICdTUEFDRSc6ICd0b2dnbGUnLFxuICAgICAgICAnQVJST1dfRE9XTic6ICduZXh0JyxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3ByZXZpb3VzJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBhY2NvcmRpb24gYnkgYW5pbWF0aW5nIHRoZSBwcmVzZXQgYWN0aXZlIHBhbmUocykuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2lzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigncm9sZScsICd0YWJsaXN0Jyk7XG4gICAgICB0aGlzLiR0YWJzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignW2RhdGEtYWNjb3JkaW9uLWl0ZW1dJyk7XG4gICAgICB0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24gKGlkeCwgZWwpIHtcbiAgICAgICAgdmFyICRlbCA9ICQoZWwpLFxuICAgICAgICAgICAgJGNvbnRlbnQgPSAkZWwuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpLFxuICAgICAgICAgICAgaWQgPSAkY29udGVudFswXS5pZCB8fCBHZXRZb0RpZ2l0cyg2LCAnYWNjb3JkaW9uJyksXG4gICAgICAgICAgICBsaW5rSWQgPSBlbC5pZCA/IFwiXCIuY29uY2F0KGVsLmlkLCBcIi1sYWJlbFwiKSA6IFwiXCIuY29uY2F0KGlkLCBcIi1sYWJlbFwiKTtcbiAgICAgICAgJGVsLmZpbmQoJ2E6Zmlyc3QnKS5hdHRyKHtcbiAgICAgICAgICAnYXJpYS1jb250cm9scyc6IGlkLFxuICAgICAgICAgICdyb2xlJzogJ3RhYicsXG4gICAgICAgICAgJ2lkJzogbGlua0lkLFxuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgJGNvbnRlbnQuYXR0cih7XG4gICAgICAgICAgJ3JvbGUnOiAndGFicGFuZWwnLFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWQsXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAnaWQnOiBpZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyICRpbml0QWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuXG4gICAgICBpZiAoJGluaXRBY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgIC8vIFNhdmUgdXAgdGhlIGluaXRpYWwgaGFzaCB0byByZXR1cm4gdG8gaXQgbGF0ZXIgd2hlbiBnb2luZyBiYWNrIGluIGhpc3RvcnlcbiAgICAgICAgdGhpcy5faW5pdGlhbEFuY2hvciA9ICRpbml0QWN0aXZlLnByZXYoJ2EnKS5hdHRyKCdocmVmJyk7XG5cbiAgICAgICAgdGhpcy5fb3BlblNpbmdsZVRhYigkaW5pdEFjdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmNob3IgPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcblxuICAgICAgICBpZiAoIWFuY2hvci5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgc3RpbGwgaW5pdGlhbGl6aW5nIGFuZCB0aGVyZSBpcyBubyBhbmNob3IsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkb1xuICAgICAgICAgIGlmIChfdGhpczIuX2lzSW5pdGlhbGl6aW5nKSByZXR1cm47IC8vIE90aGVyd2lzZSwgbW92ZSB0byB0aGUgaW5pdGlhbCBhbmNob3JcblxuICAgICAgICAgIGlmIChfdGhpczIuX2luaXRpYWxBbmNob3IpIGFuY2hvciA9IF90aGlzMi5faW5pdGlhbEFuY2hvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkYW5jaG9yID0gYW5jaG9yICYmICQoYW5jaG9yKTtcblxuICAgICAgICB2YXIgJGxpbmsgPSBhbmNob3IgJiYgX3RoaXMyLiRlbGVtZW50LmZpbmQoXCJbaHJlZiQ9XFxcIlwiLmNvbmNhdChhbmNob3IsIFwiXFxcIl1cIikpOyAvLyBXaGV0aGVyIHRoZSBhbmNob3IgZWxlbWVudCB0aGF0IGhhcyBiZWVuIGZvdW5kIGlzIHBhcnQgb2YgdGhpcyBlbGVtZW50XG5cblxuICAgICAgICB2YXIgaXNPd25BbmNob3IgPSAhISgkYW5jaG9yLmxlbmd0aCAmJiAkbGluay5sZW5ndGgpOyAvLyBJZiB0aGVyZSBpcyBhbiBhbmNob3IgZm9yIHRoZSBoYXNoLCBvcGVuIGl0IChpZiBub3QgYWxyZWFkeSBhY3RpdmUpXG5cbiAgICAgICAgaWYgKCRhbmNob3IgJiYgJGxpbmsgJiYgJGxpbmsubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCEkbGluay5wYXJlbnQoJ1tkYXRhLWFjY29yZGlvbi1pdGVtXScpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xuICAgICAgICAgICAgX3RoaXMyLl9vcGVuU2luZ2xlVGFiKCRhbmNob3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIGNsb3NlIGV2ZXJ5dGhpbmdcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpczIuX2Nsb3NlQWxsVGFicygpO1xuICAgICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPd25BbmNob3IpIHtcbiAgICAgICAgICAvLyBSb2xsIHVwIGEgbGl0dGxlIHRvIHNob3cgdGhlIHRpdGxlc1xuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5kZWVwTGlua1NtdWRnZSkge1xuICAgICAgICAgICAgb25Mb2FkKCQod2luZG93KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMyLiRlbGVtZW50Lm9mZnNldCgpO1xuXG4gICAgICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IG9mZnNldC50b3BcbiAgICAgICAgICAgICAgfSwgX3RoaXMyLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2VEZWxheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBkZWVwbGlua2VkIGF0IHBhZ2Vsb2FkXG4gICAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbiNkZWVwbGlua1xuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBfdGhpczIuJGVsZW1lbnQudHJpZ2dlcignZGVlcGxpbmsuemYuYWNjb3JkaW9uJywgWyRsaW5rLCAkYW5jaG9yXSk7XG4gICAgICAgIH1cbiAgICAgIH07IC8vdXNlIGJyb3dzZXIgdG8gb3BlbiBhIHRhYiwgaWYgaXQgZXhpc3RzIGluIHRoaXMgdGFic2V0XG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICB0aGlzLl9jaGVja0RlZXBMaW5rKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgICB0aGlzLl9pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIGFjY29yZGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kdGFicy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRlbGVtID0gJCh0aGlzKTtcbiAgICAgICAgdmFyICR0YWJDb250ZW50ID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuXG4gICAgICAgIGlmICgkdGFiQ29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAkZWxlbS5jaGlsZHJlbignYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uIGtleWRvd24uemYuYWNjb3JkaW9uJykub24oJ2NsaWNrLnpmLmFjY29yZGlvbicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkdGFiQ29udGVudCk7XG4gICAgICAgICAgfSkub24oJ2tleWRvd24uemYuYWNjb3JkaW9uJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnQWNjb3JkaW9uJywge1xuICAgICAgICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJHRhYkNvbnRlbnQpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIHZhciAkYSA9ICRlbGVtLm5leHQoKS5maW5kKCdhJykuZm9jdXMoKTtcblxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCkge1xuICAgICAgICAgICAgICAgICAgJGEudHJpZ2dlcignY2xpY2suemYuYWNjb3JkaW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMoKSB7XG4gICAgICAgICAgICAgICAgdmFyICRhID0gJGVsZW0ucHJldigpLmZpbmQoJ2EnKS5mb2N1cygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kKSB7XG4gICAgICAgICAgICAgICAgICAkYS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQoKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICAkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgY29udGVudCBwYW5lJ3Mgb3Blbi9jbG9zZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIGpRdWVyeSBvYmplY3Qgb2YgdGhlIHBhbmUgdG8gdG9nZ2xlIChgLmFjY29yZGlvbi1jb250ZW50YCkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCR0YXJnZXQpIHtcbiAgICAgIGlmICgkdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWFjY29yZGlvbl0nKS5pcygnW2Rpc2FibGVkXScpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnQ2Fubm90IHRvZ2dsZSBhbiBhY2NvcmRpb24gdGhhdCBpcyBkaXNhYmxlZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoJHRhcmdldC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHtcbiAgICAgICAgdGhpcy51cCgkdGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG93bigkdGFyZ2V0KTtcbiAgICAgIH0gLy9laXRoZXIgcmVwbGFjZSBvciB1cGRhdGUgYnJvd3NlciBoaXN0b3J5XG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICB2YXIgYW5jaG9yID0gJHRhcmdldC5wcmV2KCdhJykuYXR0cignaHJlZicpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlSGlzdG9yeSkge1xuICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgYW5jaG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGFjY29yZGlvbiB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBBY2NvcmRpb24gcGFuZSB0byBvcGVuIChgLmFjY29yZGlvbi1jb250ZW50YCkuXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiNkb3duXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvd24oJHRhcmdldCkge1xuICAgICAgaWYgKCR0YXJnZXQuY2xvc2VzdCgnW2RhdGEtYWNjb3JkaW9uXScpLmlzKCdbZGlzYWJsZWRdJykpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdDYW5ub3QgY2FsbCBkb3duIG9uIGFuIGFjY29yZGlvbiB0aGF0IGlzIGRpc2FibGVkLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpIHRoaXMuX29wZW5UYWIoJHRhcmdldCk7ZWxzZSB0aGlzLl9vcGVuU2luZ2xlVGFiKCR0YXJnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgKiBJdCBtYXkgYmUgaWdub3JlZCBpZiB0aGUgQWNjb3JkaW9uIG9wdGlvbnMgZG9uJ3QgYWxsb3cgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gY2xvc2UgKGAuYWNjb3JkaW9uLWNvbnRlbnRgKS5cbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI3VwXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cCgkdGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5pcygnW2Rpc2FibGVkXScpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnQ2Fubm90IGNhbGwgdXAgb24gYW4gYWNjb3JkaW9uIHRoYXQgaXMgZGlzYWJsZWQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRG9uJ3QgY2xvc2UgdGhlIGl0ZW0gaWYgaXQgaXMgYWxyZWFkeSBjbG9zZWRcblxuXG4gICAgICB2YXIgJHRhcmdldEl0ZW0gPSAkdGFyZ2V0LnBhcmVudCgpO1xuICAgICAgaWYgKCEkdGFyZ2V0SXRlbS5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHJldHVybjsgLy8gRG9uJ3QgY2xvc2UgdGhlIGl0ZW0gaWYgdGhlcmUgaXMgbm8gb3RoZXIgYWN0aXZlIGl0ZW0gKHVubGVzcyB3aXRoIGBhbGxvd0FsbENsb3NlZGApXG5cbiAgICAgIHZhciAkb3RoZXJzSXRlbXMgPSAkdGFyZ2V0SXRlbS5zaWJsaW5ncygpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWQgJiYgISRvdGhlcnNJdGVtcy5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VUYWIoJHRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YCB0aGUgb25seSBvcGVuZWQgdGFiLCBjbG9zaW5nIGFsbCBvdGhlcnMgdGFicy5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gb3BlbiAoYC5hY2NvcmRpb24tY29udGVudGApLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblNpbmdsZVRhYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblNpbmdsZVRhYigkdGFyZ2V0KSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG90aGVycyBhY3RpdmUgdGFicy5cbiAgICAgIHZhciAkYWN0aXZlQ29udGVudHMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuXG4gICAgICBpZiAoJGFjdGl2ZUNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9jbG9zZVRhYigkYWN0aXZlQ29udGVudHMubm90KCR0YXJnZXQpKTtcbiAgICAgIH0gLy8gVGhlbiBvcGVuIHRoZSB0YXJnZXQuXG5cblxuICAgICAgdGhpcy5fb3BlblRhYigkdGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gb3BlbiAoYC5hY2NvcmRpb24tY29udGVudGApLlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jZG93blxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblRhYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblRhYigkdGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyICR0YXJnZXRJdGVtID0gJHRhcmdldC5wYXJlbnQoKTtcbiAgICAgIHZhciB0YXJnZXRDb250ZW50SWQgPSAkdGFyZ2V0LmF0dHIoJ2FyaWEtbGFiZWxsZWRieScpO1xuICAgICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcbiAgICAgICR0YXJnZXRJdGVtLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAgICQoXCIjXCIuY29uY2F0KHRhcmdldENvbnRlbnRJZCkpLmF0dHIoe1xuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRydWUsXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICAkdGFyZ2V0LnNsaWRlRG93bih0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgb3BlbmluZy5cbiAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbiNkb3duXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpczMuJGVsZW1lbnQudHJpZ2dlcignZG93bi56Zi5hY2NvcmRpb24nLCBbJHRhcmdldF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHRhYiB0byBjbG9zZSAoYC5hY2NvcmRpb24tY29udGVudGApLlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jdXBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Nsb3NlVGFiXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZVRhYigkdGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyICR0YXJnZXRJdGVtID0gJHRhcmdldC5wYXJlbnQoKTtcbiAgICAgIHZhciB0YXJnZXRDb250ZW50SWQgPSAkdGFyZ2V0LmF0dHIoJ2FyaWEtbGFiZWxsZWRieScpO1xuICAgICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgJHRhcmdldEl0ZW0ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgJChcIiNcIi5jb25jYXQodGFyZ2V0Q29udGVudElkKSkuYXR0cih7XG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgJHRhcmdldC5zbGlkZVVwKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB0YWIgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI3VwXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpczQuJGVsZW1lbnQudHJpZ2dlcigndXAuemYuYWNjb3JkaW9uJywgWyR0YXJnZXRdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIGFjdGl2ZSB0YWJzXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiN1cFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xvc2VBbGxUYWJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZUFsbFRhYnMoKSB7XG4gICAgICB2YXIgJGFjdGl2ZVRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuXG4gICAgICBpZiAoJGFjdGl2ZVRhYnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlVGFiKCRhY3RpdmVUYWJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uLlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jZGVzdHJveWVkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtdGFiLWNvbnRlbnRdJykuc3RvcCh0cnVlKS5zbGlkZVVwKDApLmNzcygnZGlzcGxheScsICcnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignLnpmLmFjY29yZGlvbicpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICAgICQod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWNjb3JkaW9uO1xufShQbHVnaW4pO1xuXG5BY2NvcmRpb24uZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBhbmltYXRlIHRoZSBvcGVuaW5nIG9mIGFuIGFjY29yZGlvbiBwYW5lLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDI1MFxuICAgKi9cbiAgc2xpZGVTcGVlZDogMjUwLFxuXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgYWNjb3JkaW9uIHRvIGhhdmUgbXVsdGlwbGUgb3BlbiBwYW5lcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIG11bHRpRXhwYW5kOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBjbG9zZSBhbGwgcGFuZXMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhbGxvd0FsbENsb3NlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIExpbmsgdGhlIGxvY2F0aW9uIGhhc2ggdG8gdGhlIG9wZW4gcGFuZS5cbiAgICogU2V0IHRoZSBsb2NhdGlvbiBoYXNoIHdoZW4gdGhlIG9wZW5lZCBwYW5lIGNoYW5nZXMsIGFuZCBvcGVuIGFuZCBzY3JvbGwgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcGFuZSB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGVlcExpbms6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVlcExpbmtgIGlzIGVuYWJsZWQsIGFkanVzdCB0aGUgZGVlcCBsaW5rIHNjcm9sbCB0byBtYWtlIHN1cmUgdGhlIHRvcCBvZiB0aGUgYWNjb3JkaW9uIHBhbmVsIGlzIHZpc2libGVcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlZXBMaW5rU211ZGdlOiBmYWxzZSxcblxuICAvKipcbiAgICogSWYgYGRlZXBMaW5rU211ZGdlYCBpcyBlbmFibGVkLCBhbmltYXRpb24gdGltZSAobXMpIGZvciB0aGUgZGVlcCBsaW5rIGFkanVzdG1lbnRcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAzMDBcbiAgICovXG4gIGRlZXBMaW5rU211ZGdlRGVsYXk6IDMwMCxcblxuICAvKipcbiAgICogSWYgYGRlZXBMaW5rYCBpcyBlbmFibGVkLCB1cGRhdGUgdGhlIGJyb3dzZXIgaGlzdG9yeSB3aXRoIHRoZSBvcGVuIGFjY29yZGlvblxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdXBkYXRlSGlzdG9yeTogZmFsc2Vcbn07XG5cbi8qKlxuICogQWNjb3JkaW9uTWVudSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uTWVudVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5uZXN0XG4gKi9cblxudmFyIEFjY29yZGlvbk1lbnUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKEFjY29yZGlvbk1lbnUsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIEFjY29yZGlvbk1lbnUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjY29yZGlvbk1lbnUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBY2NvcmRpb25NZW51KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBY2NvcmRpb25NZW51LCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgQWNjb3JkaW9uTWVudVxuICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbiBtZW51LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEFjY29yZGlvbk1lbnUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0FjY29yZGlvbk1lbnUnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICBLZXlib2FyZC5yZWdpc3RlcignQWNjb3JkaW9uTWVudScsIHtcbiAgICAgICAgJ0VOVEVSJzogJ3RvZ2dsZScsXG4gICAgICAgICdTUEFDRSc6ICd0b2dnbGUnLFxuICAgICAgICAnQVJST1dfUklHSFQnOiAnb3BlbicsXG4gICAgICAgICdBUlJPV19VUCc6ICd1cCcsXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxuICAgICAgICAnQVJST1dfTEVGVCc6ICdjbG9zZScsXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2VBbGwnXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGFjY29yZGlvbiBtZW51IGJ5IGhpZGluZyBhbGwgbmVzdGVkIG1lbnVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIE5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnYWNjb3JkaW9uJyk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKS5ub3QoJy5pcy1hY3RpdmUnKS5zbGlkZVVwKDApOyAvLy5maW5kKCdhJykuY3NzKCdwYWRkaW5nLWxlZnQnLCAnMXJlbScpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAncm9sZSc6ICd0cmVlJyxcbiAgICAgICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogdGhpcy5vcHRpb25zLm11bHRpT3BlblxuICAgICAgfSk7XG4gICAgICB0aGlzLiRtZW51TGlua3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKTtcbiAgICAgIHRoaXMuJG1lbnVMaW5rcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmtJZCA9IHRoaXMuaWQgfHwgR2V0WW9EaWdpdHMoNiwgJ2FjYy1tZW51LWxpbmsnKSxcbiAgICAgICAgICAgICRlbGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAgICRzdWIgPSAkZWxlbS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSxcbiAgICAgICAgICAgIHN1YklkID0gJHN1YlswXS5pZCB8fCBHZXRZb0RpZ2l0cyg2LCAnYWNjLW1lbnUnKSxcbiAgICAgICAgICAgIGlzQWN0aXZlID0gJHN1Yi5oYXNDbGFzcygnaXMtYWN0aXZlJyk7XG5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucGFyZW50TGluaykge1xuICAgICAgICAgIHZhciAkYW5jaG9yID0gJGVsZW0uY2hpbGRyZW4oJ2EnKTtcbiAgICAgICAgICAkYW5jaG9yLmNsb25lKCkucHJlcGVuZFRvKCRzdWIpLndyYXAoJzxsaSBkYXRhLWlzLXBhcmVudC1saW5rIGNsYXNzPVwiaXMtc3VibWVudS1wYXJlbnQtaXRlbSBpcy1zdWJtZW51LWl0ZW0gaXMtYWNjb3JkaW9uLXN1Ym1lbnUtaXRlbVwiPjwvbGk+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XG4gICAgICAgICAgJGVsZW0uYWRkQ2xhc3MoJ2hhcy1zdWJtZW51LXRvZ2dsZScpO1xuICAgICAgICAgICRlbGVtLmNoaWxkcmVuKCdhJykuYWZ0ZXIoJzxidXR0b24gaWQ9XCInICsgbGlua0lkICsgJ1wiIGNsYXNzPVwic3VibWVudS10b2dnbGVcIiBhcmlhLWNvbnRyb2xzPVwiJyArIHN1YklkICsgJ1wiIGFyaWEtZXhwYW5kZWQ9XCInICsgaXNBY3RpdmUgKyAnXCIgdGl0bGU9XCInICsgX3RoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlVGV4dCArICdcIj48c3BhbiBjbGFzcz1cInN1Ym1lbnUtdG9nZ2xlLXRleHRcIj4nICsgX3RoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlVGV4dCArICc8L3NwYW4+PC9idXR0b24+Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGVsZW0uYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHN1YklkLFxuICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBpc0FjdGl2ZSxcbiAgICAgICAgICAgICdpZCc6IGxpbmtJZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgJHN1Yi5hdHRyKHtcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkLFxuICAgICAgICAgICdhcmlhLWhpZGRlbic6ICFpc0FjdGl2ZSxcbiAgICAgICAgICAncm9sZSc6ICdncm91cCcsXG4gICAgICAgICAgJ2lkJzogc3ViSWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5hdHRyKHtcbiAgICAgICAgJ3JvbGUnOiAndHJlZWl0ZW0nXG4gICAgICB9KTtcbiAgICAgIHZhciBpbml0UGFuZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKTtcblxuICAgICAgaWYgKGluaXRQYW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpbml0UGFuZXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuZG93bigkKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIG1lbnUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRzdWJtZW51ID0gJCh0aGlzKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcblxuICAgICAgICBpZiAoJHN1Ym1lbnUubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xuICAgICAgICAgICAgJCh0aGlzKS5jaGlsZHJlbignLnN1Ym1lbnUtdG9nZ2xlJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jykub24oJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJHN1Ym1lbnUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQodGhpcykuY2hpbGRyZW4oJ2EnKS5vZmYoJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnKS5vbignY2xpY2suemYuYWNjb3JkaW9uTWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJHN1Ym1lbnUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KS5vbigna2V5ZG93bi56Zi5hY2NvcmRpb25tZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyICRlbGVtZW50ID0gJCh0aGlzKSxcbiAgICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgndWwnKS5jaGlsZHJlbignbGknKSxcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudCxcbiAgICAgICAgICAgICR0YXJnZXQgPSAkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcbiAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBpZiAoJCh0aGlzKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpIC0gMSkpLmZpbmQoJ2EnKS5maXJzdCgpO1xuICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkgKyAxLCAkZWxlbWVudHMubGVuZ3RoIC0gMSkpLmZpbmQoJ2EnKS5maXJzdCgpO1xuXG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV06dmlzaWJsZScpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBoYXMgb3BlbiBzdWIgbWVudVxuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5maW5kKCdsaTpmaXJzdC1jaGlsZCcpLmZpbmQoJ2EnKS5maXJzdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnOmZpcnN0LWNoaWxkJykpIHtcbiAgICAgICAgICAgICAgLy8gaXMgZmlyc3QgZWxlbWVudCBvZiBzdWIgbWVudVxuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRwcmV2RWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gaWYgcHJldmlvdXMgZWxlbWVudCBoYXMgb3BlbiBzdWIgbWVudVxuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkcHJldkVsZW1lbnQucGFyZW50cygnbGknKS5maW5kKCdsaTpsYXN0LWNoaWxkJykuZmluZCgnYScpLmZpcnN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCc6bGFzdC1jaGlsZCcpKSB7XG4gICAgICAgICAgICAgIC8vIGlzIGxhc3QgZWxlbWVudCBvZiBzdWIgbWVudVxuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkubmV4dCgnbGknKS5maW5kKCdhJykuZmlyc3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnQWNjb3JkaW9uTWVudScsIHtcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICAgICAgaWYgKCR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgICAgICBfdGhpcy5kb3duKCR0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICR0YXJnZXQuZmluZCgnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoJHRhcmdldC5sZW5ndGggJiYgISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgICAgICAvLyBjbG9zZSBhY3RpdmUgc3ViIG9mIHRoaXMgaXRlbVxuICAgICAgICAgICAgICBfdGhpcy51cCgkdGFyZ2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBjbG9zZSBjdXJyZW50bHkgb3BlbiBzdWJcbiAgICAgICAgICAgICAgX3RoaXMudXAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpKTtcblxuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwOiBmdW5jdGlvbiB1cCgpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkb3duOiBmdW5jdGlvbiBkb3duKCkge1xuICAgICAgICAgICAgJG5leHRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKTtcblxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlQWxsOiBmdW5jdGlvbiBjbG9zZUFsbCgpIHtcbiAgICAgICAgICAgIF90aGlzLmhpZGVBbGwoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLy5hdHRyKCd0YWJpbmRleCcsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIHBhbmVzIG9mIHRoZSBtZW51LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZUFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlQWxsKCkge1xuICAgICAgdGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhbGwgcGFuZXMgb2YgdGhlIG1lbnUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG93QWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dBbGwoKSB7XG4gICAgICB0aGlzLmRvd24odGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgb3Blbi9jbG9zZSBzdGF0ZSBvZiBhIHN1Ym1lbnUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSB0aGUgc3VibWVudSB0byB0b2dnbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoJHRhcmdldCkge1xuICAgICAgaWYgKCEkdGFyZ2V0LmlzKCc6YW5pbWF0ZWQnKSkge1xuICAgICAgICBpZiAoISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgIHRoaXMudXAoJHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb3duKCR0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBzdWItbWVudSBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIG9wZW4uXG4gICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjZG93blxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3duKCR0YXJnZXQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aU9wZW4pIHtcbiAgICAgICAgdGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKS5ub3QoJHRhcmdldC5wYXJlbnRzVW50aWwodGhpcy4kZWxlbWVudCkuYWRkKCR0YXJnZXQpKSk7XG4gICAgICB9XG5cbiAgICAgICR0YXJnZXQuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoe1xuICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xuICAgICAgICAkdGFyZ2V0LnByZXYoJy5zdWJtZW51LXRvZ2dsZScpLmF0dHIoe1xuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR0YXJnZXQucGFyZW50KCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50JykuYXR0cih7XG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAkdGFyZ2V0LnNsaWRlRG93bih0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBkb25lIG9wZW5pbmcuXG4gICAgICAgICAqIEBldmVudCBBY2NvcmRpb25NZW51I2Rvd25cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdkb3duLnpmLmFjY29yZGlvbk1lbnUnLCBbJHRhcmdldF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuIEFsbCBzdWItbWVudXMgaW5zaWRlIHRoZSB0YXJnZXQgd2lsbCBiZSBjbG9zZWQgYXMgd2VsbC5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIGNsb3NlLlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I3VwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cCgkdGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyICRzdWJtZW51cyA9ICR0YXJnZXQuZmluZCgnW2RhdGEtc3VibWVudV0nKTtcbiAgICAgIHZhciAkYWxsbWVudXMgPSAkdGFyZ2V0LmFkZCgkc3VibWVudXMpO1xuICAgICAgJHN1Ym1lbnVzLnNsaWRlVXAoMCk7XG4gICAgICAkYWxsbWVudXMucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xuICAgICAgICAkYWxsbWVudXMucHJldignLnN1Ym1lbnUtdG9nZ2xlJykuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRhbGxtZW51cy5wYXJlbnQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAkdGFyZ2V0LnNsaWRlVXAodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSN1cFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMzLiRlbGVtZW50LnRyaWdnZXIoJ3VwLnpmLmFjY29yZGlvbk1lbnUnLCBbJHRhcmdldF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFjY29yZGlvbiBtZW51LlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2Rlc3Ryb3llZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuc2xpZGVEb3duKDApLmNzcygnZGlzcGxheScsICcnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpO1xuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1pcy1wYXJlbnQtbGlua10nKS5kZXRhY2goKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnLmhhcy1zdWJtZW51LXRvZ2dsZScpLnJlbW92ZUNsYXNzKCdoYXMtc3VibWVudS10b2dnbGUnKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCcuc3VibWVudS10b2dnbGUnKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsICdhY2NvcmRpb24nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWNjb3JkaW9uTWVudTtcbn0oUGx1Z2luKTtcblxuQWNjb3JkaW9uTWVudS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEFkZHMgdGhlIHBhcmVudCBsaW5rIHRvIHRoZSBzdWJtZW51LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcGFyZW50TGluazogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYSBzdWJtZW51IGluIG1zLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDI1MFxuICAgKi9cbiAgc2xpZGVTcGVlZDogMjUwLFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc2VwYXJhdGUgc3VibWVudSB0b2dnbGUgYnV0dG9uLiBUaGlzIGFsbG93cyB0aGUgcGFyZW50IGl0ZW0gdG8gaGF2ZSBhIGxpbmsuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgc3VibWVudVRvZ2dsZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHVzZWQgZm9yIHRoZSBzdWJtZW51IHRvZ2dsZSBpZiBlbmFibGVkLiBUaGlzIGlzIHVzZWQgZm9yIHNjcmVlbiByZWFkZXJzIG9ubHkuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgc3VibWVudVRvZ2dsZVRleHQ6ICdUb2dnbGUgbWVudScsXG5cbiAgLyoqXG4gICAqIEFsbG93IHRoZSBtZW51IHRvIGhhdmUgbXVsdGlwbGUgb3BlbiBwYW5lcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgbXVsdGlPcGVuOiB0cnVlXG59O1xuXG4vKipcbiAqIERyaWxsZG93biBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJpbGxkb3duXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKi9cblxudmFyIERyaWxsZG93biA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoRHJpbGxkb3duLCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBEcmlsbGRvd24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyaWxsZG93bik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKERyaWxsZG93bikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRHJpbGxkb3duLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcmlsbGRvd24gbWVudS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBEcmlsbGRvd25cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbiBtZW51LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIERyaWxsZG93bi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnRHJpbGxkb3duJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgS2V5Ym9hcmQucmVnaXN0ZXIoJ0RyaWxsZG93bicsIHtcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxuICAgICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXG4gICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJyxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZScsXG4gICAgICAgICdUQUInOiAnZG93bicsXG4gICAgICAgICdTSElGVF9UQUInOiAndXAnXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGRyaWxsZG93biBieSBjcmVhdGluZyBqUXVlcnkgY29sbGVjdGlvbnMgb2YgZWxlbWVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBOZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCwgJ2RyaWxsZG93bicpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9BcHBseUNsYXNzKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2RyaWxsZG93bicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAncm9sZSc6ICd0cmVlJyxcbiAgICAgICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kc3VibWVudUFuY2hvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpLmNoaWxkcmVuKCdhJyk7XG4gICAgICB0aGlzLiRzdWJtZW51cyA9IHRoaXMuJHN1Ym1lbnVBbmNob3JzLnBhcmVudCgnbGknKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5hdHRyKCdyb2xlJywgJ2dyb3VwJyk7XG4gICAgICB0aGlzLiRtZW51SXRlbXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpJykubm90KCcuanMtZHJpbGxkb3duLWJhY2snKS5hdHRyKCdyb2xlJywgJ3RyZWVpdGVtJykuZmluZCgnYScpOyAvLyBTZXQgdGhlIG1haW4gbWVudSBhcyBjdXJyZW50IGJ5IGRlZmF1bHQgKHVubGVzcyBhIHN1Ym1lbnUgaXMgc2VsZWN0ZWQpXG4gICAgICAvLyBVc2VkIHRvIHNldCB0aGUgd3JhcHBlciBoZWlnaHQgd2hlbiB0aGUgZHJpbGxkb3duIGlzIGNsb3NlZC9yZW9wZW5lZCBmcm9tIGFueSAoc3ViKW1lbnVcblxuICAgICAgdGhpcy4kY3VycmVudE1lbnUgPSB0aGlzLiRlbGVtZW50O1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLW11dGF0ZScsIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1kcmlsbGRvd24nKSB8fCBHZXRZb0RpZ2l0cyg2LCAnZHJpbGxkb3duJykpO1xuXG4gICAgICB0aGlzLl9wcmVwYXJlTWVudSgpO1xuXG4gICAgICB0aGlzLl9yZWdpc3RlckV2ZW50cygpO1xuXG4gICAgICB0aGlzLl9rZXlib2FyZEV2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwcmVwYXJlcyBkcmlsbGRvd24gbWVudSBieSBzZXR0aW5nIGF0dHJpYnV0ZXMgdG8gbGlua3MgYW5kIGVsZW1lbnRzXG4gICAgICogc2V0cyBhIG1pbiBoZWlnaHQgdG8gcHJldmVudCBjb250ZW50IGp1bXBpbmdcbiAgICAgKiB3cmFwcyB0aGUgZWxlbWVudCBpZiBub3QgYWxyZWFkeSB3cmFwcGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcmVwYXJlTWVudVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZU1lbnUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBpZighdGhpcy5vcHRpb25zLmhvbGRPcGVuKXtcbiAgICAgIC8vICAgdGhpcy5fbWVudUxpbmtFdmVudHMoKTtcbiAgICAgIC8vIH1cblxuXG4gICAgICB0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRsaW5rID0gJCh0aGlzKTtcbiAgICAgICAgdmFyICRzdWIgPSAkbGluay5wYXJlbnQoKTtcblxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5wYXJlbnRMaW5rKSB7XG4gICAgICAgICAgJGxpbmsuY2xvbmUoKS5wcmVwZW5kVG8oJHN1Yi5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSkud3JhcCgnPGxpIGRhdGEtaXMtcGFyZW50LWxpbmsgY2xhc3M9XCJpcy1zdWJtZW51LXBhcmVudC1pdGVtIGlzLXN1Ym1lbnUtaXRlbSBpcy1kcmlsbGRvd24tc3VibWVudS1pdGVtXCIgcm9sZT1cIm1lbnVpdGVtXCI+PC9saT4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRsaW5rLmRhdGEoJ3NhdmVkSHJlZicsICRsaW5rLmF0dHIoJ2hyZWYnKSkucmVtb3ZlQXR0cignaHJlZicpLmF0dHIoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgICRsaW5rLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLmF0dHIoe1xuICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAgICAgJ3RhYmluZGV4JzogMCxcbiAgICAgICAgICAncm9sZSc6ICdncm91cCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuX2V2ZW50cygkbGluayk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJHN1Ym1lbnVzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJG1lbnUgPSAkKHRoaXMpLFxuICAgICAgICAgICAgJGJhY2sgPSAkbWVudS5maW5kKCcuanMtZHJpbGxkb3duLWJhY2snKTtcblxuICAgICAgICBpZiAoISRiYWNrLmxlbmd0aCkge1xuICAgICAgICAgIHN3aXRjaCAoX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgJG1lbnUuYXBwZW5kKF90aGlzLm9wdGlvbnMuYmFja0J1dHRvbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICRtZW51LnByZXBlbmQoX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbnN1cHBvcnRlZCBiYWNrQnV0dG9uUG9zaXRpb24gdmFsdWUgJ1wiICsgX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uUG9zaXRpb24gKyBcIidcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX2JhY2soJG1lbnUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiRzdWJtZW51cy5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgdGhpcy4kc3VibWVudXMuYWRkQ2xhc3MoJ2RyaWxsZG93bi1zdWJtZW51LWNvdmVyLXByZXZpb3VzJyk7XG4gICAgICB9IC8vIGNyZWF0ZSBhIHdyYXBwZXIgb24gZWxlbWVudCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuXG5cbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtZHJpbGxkb3duJykpIHtcbiAgICAgICAgdGhpcy4kd3JhcHBlciA9ICQodGhpcy5vcHRpb25zLndyYXBwZXIpLmFkZENsYXNzKCdpcy1kcmlsbGRvd24nKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmFkZENsYXNzKCdhbmltYXRlLWhlaWdodCcpO1xuICAgICAgICB0aGlzLiRlbGVtZW50LndyYXAodGhpcy4kd3JhcHBlcik7XG4gICAgICB9IC8vIHNldCB3cmFwcGVyXG5cblxuICAgICAgdGhpcy4kd3JhcHBlciA9IHRoaXMuJGVsZW1lbnQucGFyZW50KCk7XG4gICAgICB0aGlzLiR3cmFwcGVyLmNzcyh0aGlzLl9nZXRNYXhEaW1zKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemUoKSB7XG4gICAgICB0aGlzLiR3cmFwcGVyLmNzcyh7XG4gICAgICAgICdtYXgtd2lkdGgnOiAnbm9uZScsXG4gICAgICAgICdtaW4taGVpZ2h0JzogJ25vbmUnXG4gICAgICB9KTsgLy8gX2dldE1heERpbXMgaGFzIHNpZGUgZWZmZWN0cyAoYm9vKSBidXQgY2FsbGluZyBpdCBzaG91bGQgdXBkYXRlIGFsbCBvdGhlciBuZWNlc3NhcnkgaGVpZ2h0cyAmIHdpZHRoc1xuXG4gICAgICB0aGlzLiR3cmFwcGVyLmNzcyh0aGlzLl9nZXRNYXhEaW1zKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIHRvIGVsZW1lbnRzIGluIHRoZSBtZW51LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgbWVudSBpdGVtIHRvIGFkZCBoYW5kbGVycyB0by5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygkZWxlbSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgJGVsZW0ub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCQoZS50YXJnZXQpLnBhcmVudHNVbnRpbCgndWwnLCAnbGknKS5oYXNDbGFzcygnaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50JykpIHtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSAvLyBpZihlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LmZpcnN0RWxlbWVudENoaWxkKXtcbiAgICAgICAgLy8gICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIH1cblxuXG4gICAgICAgIF90aGlzLl9zaG93KCRlbGVtLnBhcmVudCgnbGknKSk7XG5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICAgICAgdmFyICRib2R5ID0gJCgnYm9keScpO1xuICAgICAgICAgICRib2R5Lm9mZignLnpmLmRyaWxsZG93bicpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCAkLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLCBlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XG5cbiAgICAgICAgICAgICRib2R5Lm9mZignLnpmLmRyaWxsZG93bicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byB0aGUgbWVudSBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVnaXN0ZXJFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyRXZlbnRzKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxUb3ApIHtcbiAgICAgICAgdGhpcy5fYmluZEhhbmRsZXIgPSB0aGlzLl9zY3JvbGxUb3AuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignb3Blbi56Zi5kcmlsbGRvd24gaGlkZS56Zi5kcmlsbGRvd24gY2xvc2VkLnpmLmRyaWxsZG93bicsIHRoaXMuX2JpbmRIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5vbignbXV0YXRlbWUuemYudHJpZ2dlcicsIHRoaXMuX3Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIFRvcCBvZiBFbGVtZW50IG9yIGRhdGEtc2Nyb2xsLXRvcC1lbGVtZW50XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIERyaWxsZG93biNzY3JvbGxtZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Njcm9sbFRvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2Nyb2xsVG9wKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyICRzY3JvbGxUb3BFbGVtZW50ID0gX3RoaXMub3B0aW9ucy5zY3JvbGxUb3BFbGVtZW50ICE9ICcnID8gJChfdGhpcy5vcHRpb25zLnNjcm9sbFRvcEVsZW1lbnQpIDogX3RoaXMuJGVsZW1lbnQsXG4gICAgICAgICAgc2Nyb2xsUG9zID0gcGFyc2VJbnQoJHNjcm9sbFRvcEVsZW1lbnQub2Zmc2V0KCkudG9wICsgX3RoaXMub3B0aW9ucy5zY3JvbGxUb3BPZmZzZXQsIDEwKTtcbiAgICAgICQoJ2h0bWwsIGJvZHknKS5zdG9wKHRydWUpLmFuaW1hdGUoe1xuICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbFBvc1xuICAgICAgfSwgX3RoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgX3RoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgKiBGaXJlcyBhZnRlciB0aGUgbWVudSBoYXMgc2Nyb2xsZWRcbiAgICAgICAgICAqIEBldmVudCBEcmlsbGRvd24jc2Nyb2xsbWVcbiAgICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcyA9PT0gJCgnaHRtbCcpWzBdKSBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzY3JvbGxtZS56Zi5kcmlsbGRvd24nKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGtleWRvd24gZXZlbnQgbGlzdGVuZXIgdG8gYGxpYCdzIGluIHRoZSBtZW51LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfa2V5Ym9hcmRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2tleWJvYXJkRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kbWVudUl0ZW1zLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjayA+IGEsIC5pcy1zdWJtZW51LXBhcmVudC1pdGVtID4gYScpKS5vbigna2V5ZG93bi56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpLFxuICAgICAgICAgICAgJGVsZW1lbnRzID0gJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5jaGlsZHJlbignbGknKS5jaGlsZHJlbignYScpLFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LFxuICAgICAgICAgICAgJG5leHRFbGVtZW50O1xuICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWF4KDAsIGkgLSAxKSk7XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSArIDEsICRlbGVtZW50cy5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdEcmlsbGRvd24nLCB7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIGlmICgkZWxlbWVudC5pcyhfdGhpcy4kc3VibWVudUFuY2hvcnMpKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7XG5cbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLm9uZSh0cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5maW5kKCd1bCBsaSBhJykubm90KCcuanMtZHJpbGxkb3duLWJhY2sgYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKSk7XG5cbiAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykub25lKHRyYW5zaXRpb25lbmQoJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpLmNoaWxkcmVuKCdhJykuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cDogZnVuY3Rpb24gdXAoKSB7XG4gICAgICAgICAgICAkcHJldkVsZW1lbnQuZm9jdXMoKTsgLy8gRG9uJ3QgdGFwIGZvY3VzIG9uIGZpcnN0IGVsZW1lbnQgaW4gcm9vdCB1bFxuXG4gICAgICAgICAgICByZXR1cm4gISRlbGVtZW50LmlzKF90aGlzLiRlbGVtZW50LmZpbmQoJz4gbGk6Zmlyc3QtY2hpbGQgPiBhJykpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZG93bjogZnVuY3Rpb24gZG93bigpIHtcbiAgICAgICAgICAgICRuZXh0RWxlbWVudC5mb2N1cygpOyAvLyBEb24ndCB0YXAgZm9jdXMgb24gbGFzdCBlbGVtZW50IGluIHJvb3QgdWxcblxuICAgICAgICAgICAgcmV0dXJuICEkZWxlbWVudC5pcyhfdGhpcy4kZWxlbWVudC5maW5kKCc+IGxpOmxhc3QtY2hpbGQgPiBhJykpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY2xvc2Ugb24gZWxlbWVudCBpbiByb290IHVsXG4gICAgICAgICAgICBpZiAoISRlbGVtZW50LmlzKF90aGlzLiRlbGVtZW50LmZpbmQoJz4gbGkgPiBhJykpKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpKTtcblxuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoKS5wYXJlbnQoKS5zaWJsaW5ncygnYScpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucGFyZW50TGluayAmJiAkZWxlbWVudC5hdHRyKCdocmVmJykpIHtcbiAgICAgICAgICAgICAgLy8gTGluayB3aXRoIGhyZWZcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghJGVsZW1lbnQuaXMoX3RoaXMuJG1lbnVJdGVtcykpIHtcbiAgICAgICAgICAgICAgLy8gbm90IG1lbnUgaXRlbSBtZWFucyBiYWNrIGJ1dHRvblxuICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpKTtcblxuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLm9uZSh0cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQuaXMoX3RoaXMuJHN1Ym1lbnVBbmNob3JzKSkge1xuICAgICAgICAgICAgICAvLyBTdWIgbWVudSBpdGVtXG4gICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7XG5cbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLm9uZSh0cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5maW5kKCd1bCBsaSBhJykubm90KCcuanMtZHJpbGxkb3duLWJhY2sgYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIGVuZCBrZXlib2FyZEFjY2Vzc1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIG9wZW4gZWxlbWVudHMsIGFuZCByZXR1cm5zIHRvIHJvb3QgbWVudS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZmlyZXMgRHJpbGxkb3duI2Nsb3NlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hpZGVBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGVBbGwoKSB7XG4gICAgICB2YXIgJGVsZW0gPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1kcmlsbGRvd24tc3VibWVudS5pcy1hY3RpdmUnKS5hZGRDbGFzcygnaXMtY2xvc2luZycpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmNzcyh7XG4gICAgICAgIGhlaWdodDogJGVsZW0ucGFyZW50KCkuY2xvc2VzdCgndWwnKS5kYXRhKCdjYWxjSGVpZ2h0JylcbiAgICAgIH0pO1xuICAgICAgJGVsZW0ub25lKHRyYW5zaXRpb25lbmQoJGVsZW0pLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAkZWxlbS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcnKTtcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGZ1bGx5IGNsb3NlZC5cbiAgICAgICAqIEBldmVudCBEcmlsbGRvd24jY2xvc2VkXG4gICAgICAgKi9cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYuZHJpbGxkb3duJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgZm9yIGVhY2ggYGJhY2tgIGJ1dHRvbiwgYW5kIGNsb3NlcyBvcGVuIG1lbnVzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jYmFja1xuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGFkZCBgYmFja2AgZXZlbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmFjaygkZWxlbSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgJGVsZW0ub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKTtcbiAgICAgICRlbGVtLmNoaWxkcmVuKCcuanMtZHJpbGxkb3duLWJhY2snKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgLy8gY29uc29sZS5sb2coJ21vdXNldXAgb24gYmFjaycpO1xuXG4gICAgICAgIF90aGlzLl9oaWRlKCRlbGVtKTsgLy8gSWYgdGhlcmUgaXMgYSBwYXJlbnQgc3VibWVudSwgY2FsbCBzaG93XG5cblxuICAgICAgICB2YXIgcGFyZW50U3ViTWVudSA9ICRlbGVtLnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpO1xuXG4gICAgICAgIGlmIChwYXJlbnRTdWJNZW51Lmxlbmd0aCkge1xuICAgICAgICAgIF90aGlzLl9zaG93KHBhcmVudFN1Yk1lbnUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lciB0byBtZW51IGl0ZW1zIHcvbyBzdWJtZW51cyB0byBjbG9zZSBvcGVuIG1lbnVzIG9uIGNsaWNrLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWVudUxpbmtFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21lbnVMaW5rRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kbWVudUl0ZW1zLm5vdCgnLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpLm9mZignY2xpY2suemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIENTUyBjbGFzc2VzIGZvciBzdWJtZW51IHRvIHNob3cgaXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgdGFyZ2V0IHN1Ym1lbnUgKGB1bGAgdGFnKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpZ2dlciAtIHRyaWdnZXIgZHJpbGxkb3duIGV2ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U2hvd1N1Yk1lbnVDbGFzc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTaG93U3ViTWVudUNsYXNzZXMoJGVsZW0sIHRyaWdnZXIpIHtcbiAgICAgICRlbGVtLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5yZW1vdmVDbGFzcygnaW52aXNpYmxlJykuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG4gICAgICAkZWxlbS5wYXJlbnQoJ2xpJykuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICBpZiAodHJpZ2dlciA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIENTUyBjbGFzc2VzIGZvciBzdWJtZW51IHRvIGhpZGUgaXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgdGFyZ2V0IHN1Ym1lbnUgKGB1bGAgdGFnKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpZ2dlciAtIHRyaWdnZXIgZHJpbGxkb3duIGV2ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0SGlkZVN1Yk1lbnVDbGFzc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRIaWRlU3ViTWVudUNsYXNzZXMoJGVsZW0sIHRyaWdnZXIpIHtcbiAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5hZGRDbGFzcygnaW52aXNpYmxlJykuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgICRlbGVtLnBhcmVudCgnbGknKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuXG4gICAgICBpZiAodHJpZ2dlciA9PT0gdHJ1ZSkge1xuICAgICAgICAkZWxlbS50cmlnZ2VyKCdoaWRlLnpmLmRyaWxsZG93bicsIFskZWxlbV0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIHNwZWNpZmljIGRyaWxsZG93biAoc3ViKW1lbnUgbm8gbWF0dGVyIHdoaWNoIChzdWIpbWVudSBpbiBpdCBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICAgKiBDb21wYXJlZCB0byBfc2hvdygpIHRoaXMgbGV0cyB5b3UganVtcCBpbnRvIGFueSBzdWJtZW51IHdpdGhvdXQgY2xpY2tpbmcgdGhyb3VnaCBldmVyeSBzdWJtZW51IG9uIHRoZSB3YXkgdG8gaXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIERyaWxsZG93biNvcGVuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIHRhcmdldCAoc3ViKW1lbnUgKGB1bGAgdGFnKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b0ZvY3VzIC0gaWYgdHJ1ZSB0aGUgZmlyc3QgbGluayBpbiB0aGUgdGFyZ2V0IChzdWIpbWVudSBnZXRzIGF1dG8gZm9jdXNlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3dNZW51XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93TWVudSgkZWxlbSwgYXV0b0ZvY3VzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBSZXNldCBkcmlsbGRvd25cblxuXG4gICAgICB2YXIgJGV4cGFuZGVkU3VibWVudXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpW2FyaWEtZXhwYW5kZWQ9XCJ0cnVlXCJdID4gdWxbZGF0YS1zdWJtZW51XScpO1xuICAgICAgJGV4cGFuZGVkU3VibWVudXMuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgX3RoaXMuX3NldEhpZGVTdWJNZW51Q2xhc3NlcygkKHRoaXMpKTtcbiAgICAgIH0pOyAvLyBTYXZlIHRoZSBtZW51IGFzIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIG9uZS5cblxuICAgICAgdGhpcy4kY3VycmVudE1lbnUgPSAkZWxlbTsgLy8gSWYgdGFyZ2V0IG1lbnUgaXMgcm9vdCwgZm9jdXMgZmlyc3QgbGluayAmIGV4aXRcblxuICAgICAgaWYgKCRlbGVtLmlzKCdbZGF0YS1kcmlsbGRvd25dJykpIHtcbiAgICAgICAgaWYgKGF1dG9Gb2N1cyA9PT0gdHJ1ZSkgJGVsZW0uZmluZCgnbGlbcm9sZT1cInRyZWVpdGVtXCJdID4gYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmNzcygnaGVpZ2h0JywgJGVsZW0uZGF0YSgnY2FsY0hlaWdodCcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGaW5kIGFsbCBzdWJtZW51cyBvbiB3YXkgdG8gcm9vdCBpbmNsLiB0aGUgZWxlbWVudCBpdHNlbGZcblxuXG4gICAgICB2YXIgJHN1Ym1lbnVzID0gJGVsZW0uY2hpbGRyZW4oKS5maXJzdCgpLnBhcmVudHNVbnRpbCgnW2RhdGEtZHJpbGxkb3duXScsICdbZGF0YS1zdWJtZW51XScpOyAvLyBPcGVuIHRhcmdldCBtZW51IGFuZCBhbGwgc3VibWVudXMgb24gaXRzIHdheSB0byByb290XG5cbiAgICAgICRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAvLyBVcGRhdGUgaGVpZ2h0IG9mIGZpcnN0IGNoaWxkICh0YXJnZXQgbWVudSkgaWYgYXV0b0hlaWdodCBvcHRpb24gdHJ1ZVxuICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgX3RoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgICAgX3RoaXMuJHdyYXBwZXIuY3NzKCdoZWlnaHQnLCAkKHRoaXMpLmRhdGEoJ2NhbGNIZWlnaHQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNMYXN0Q2hpbGQgPSBpbmRleCA9PSAkc3VibWVudXMubGVuZ3RoIC0gMTsgLy8gQWRkIHRyYW5zaXRpb25zZW5kIGxpc3RlbmVyIHRvIGxhc3QgY2hpbGQgKHJvb3QgZHVlIHRvIHJldmVyc2Ugb3JkZXIpIHRvIG9wZW4gdGFyZ2V0IG1lbnUncyBmaXJzdCBsaW5rXG4gICAgICAgIC8vIExhc3QgY2hpbGQgbWFrZXMgc3VyZSB0aGUgZXZlbnQgZ2V0cyBhbHdheXMgdHJpZ2dlcmVkIGV2ZW4gaWYgZ29pbmcgdGhyb3VnaCBzZXZlcmFsIG1lbnVzXG5cbiAgICAgICAgaWYgKGlzTGFzdENoaWxkID09PSB0cnVlKSB7XG4gICAgICAgICAgJCh0aGlzKS5vbmUodHJhbnNpdGlvbmVuZCgkKHRoaXMpKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGF1dG9Gb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAkZWxlbS5maW5kKCdsaVtyb2xlPVwidHJlZWl0ZW1cIl0gPiBhJykuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX3NldFNob3dTdWJNZW51Q2xhc3NlcygkKHRoaXMpLCBpc0xhc3RDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBzdWJtZW51LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jb3BlblxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gb3BlbiwgaS5lLiB0aGUgYGxpYCB0YWcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdygkZWxlbSkge1xuICAgICAgdmFyICRzdWJtZW51ID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XG4gICAgICAkZWxlbS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG4gICAgICB0aGlzLiRjdXJyZW50TWVudSA9ICRzdWJtZW51O1xuICAgICAgJHN1Ym1lbnUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKS5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHtcbiAgICAgICAgICBoZWlnaHQ6ICRzdWJtZW51LmRhdGEoJ2NhbGNIZWlnaHQnKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgb3BlbmVkLlxuICAgICAgICogQGV2ZW50IERyaWxsZG93biNvcGVuXG4gICAgICAgKi9cblxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGVzIGEgc3VibWVudVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jaGlkZVxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGhpZGUsIGkuZS4gdGhlIGB1bGAgdGFnLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoJGVsZW0pIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkgdGhpcy4kd3JhcHBlci5jc3Moe1xuICAgICAgICBoZWlnaHQ6ICRlbGVtLnBhcmVudCgpLmNsb3Nlc3QoJ3VsJykuZGF0YSgnY2FsY0hlaWdodCcpXG4gICAgICB9KTtcblxuICAgICAgJGVsZW0ucGFyZW50KCdsaScpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICAkZWxlbS5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgJGVsZW0uYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKS5vbmUodHJhbnNpdGlvbmVuZCgkZWxlbSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJGVsZW0ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nJyk7XG4gICAgICAgICRlbGVtLmJsdXIoKS5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgY2xvc2VkLlxuICAgICAgICogQGV2ZW50IERyaWxsZG93biNoaWRlXG4gICAgICAgKi9cblxuICAgICAgJGVsZW0udHJpZ2dlcignaGlkZS56Zi5kcmlsbGRvd24nLCBbJGVsZW1dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgbmVzdGVkIG1lbnVzIHRvIGNhbGN1bGF0ZSB0aGUgbWluLWhlaWdodCwgYW5kIG1heC13aWR0aCBmb3IgdGhlIG1lbnUuXG4gICAgICogUHJldmVudHMgY29udGVudCBqdW1waW5nLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TWF4RGltc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWF4RGltcygpIHtcbiAgICAgIHZhciBtYXhIZWlnaHQgPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgIF90aGlzID0gdGhpczsgLy8gUmVjYWxjdWxhdGUgbWVudSBoZWlnaHRzIGFuZCB0b3RhbCBtYXggaGVpZ2h0XG5cblxuICAgICAgdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnVtT2ZFbGVtcyA9ICQodGhpcykuY2hpbGRyZW4oJ2xpJykubGVuZ3RoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gQm94LkdldERpbWVuc2lvbnModGhpcykuaGVpZ2h0O1xuICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHQgPiBtYXhIZWlnaHQgPyBoZWlnaHQgOiBtYXhIZWlnaHQ7XG5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkge1xuICAgICAgICAgICQodGhpcykuZGF0YSgnY2FsY0hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSByZXN1bHRbJ2hlaWdodCddID0gdGhpcy4kY3VycmVudE1lbnUuZGF0YSgnY2FsY0hlaWdodCcpO2Vsc2UgcmVzdWx0WydtaW4taGVpZ2h0J10gPSBcIlwiLmNvbmNhdChtYXhIZWlnaHQsIFwicHhcIik7XG4gICAgICByZXN1bHRbJ21heC13aWR0aCddID0gXCJcIi5jb25jYXQodGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCwgXCJweFwiKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBEcmlsbGRvd24gTWVudVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNjcm9sbFRvcCkgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5kcmlsbGRvd24nLCB0aGlzLl9iaW5kSGFuZGxlcik7XG5cbiAgICAgIHRoaXMuX2hpZGVBbGwoKTtcblxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgIE5lc3QuQnVybih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XG4gICAgICB0aGlzLiRlbGVtZW50LnVud3JhcCgpLmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjaywgLmlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0nKS5yZW1vdmUoKS5lbmQoKS5maW5kKCcuaXMtYWN0aXZlLCAuaXMtY2xvc2luZywgLmlzLWRyaWxsZG93bi1zdWJtZW51JykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nIGlzLWRyaWxsZG93bi1zdWJtZW51JykuZW5kKCkuZmluZCgnW2RhdGEtc3VibWVudV0nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCByb2xlJyk7XG4gICAgICB0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS5vZmYoJy56Zi5kcmlsbGRvd24nKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1pcy1wYXJlbnQtbGlua10nKS5kZXRhY2goKTtcbiAgICAgIHRoaXMuJHN1Ym1lbnVzLnJlbW92ZUNsYXNzKCdkcmlsbGRvd24tc3VibWVudS1jb3Zlci1wcmV2aW91cyBpbnZpc2libGUnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGxpbmsgPSAkKHRoaXMpO1xuICAgICAgICAkbGluay5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuXG4gICAgICAgIGlmICgkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkge1xuICAgICAgICAgICRsaW5rLmF0dHIoJ2hyZWYnLCAkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkucmVtb3ZlRGF0YSgnc2F2ZWRIcmVmJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRHJpbGxkb3duO1xufShQbHVnaW4pO1xuXG5EcmlsbGRvd24uZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBEcmlsbGRvd25zIGRlcGVuZCBvbiBzdHlsZXMgaW4gb3JkZXIgdG8gZnVuY3Rpb24gcHJvcGVybHk7IGluIHRoZSBkZWZhdWx0IGJ1aWxkIG9mIEZvdW5kYXRpb24gdGhlc2UgYXJlXG4gICAqIG9uIHRoZSBgZHJpbGxkb3duYCBjbGFzcy4gVGhpcyBvcHRpb24gYXV0by1hcHBsaWVzIHRoaXMgY2xhc3MgdG8gdGhlIGRyaWxsZG93biB1cG9uIGluaXRpYWxpemF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29saWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhdXRvQXBwbHlDbGFzczogdHJ1ZSxcblxuICAvKipcbiAgICogTWFya3VwIHVzZWQgZm9yIEpTIGdlbmVyYXRlZCBiYWNrIGJ1dHRvbi4gUHJlcGVuZGVkICBvciBhcHBlbmRlZCAoc2VlIGJhY2tCdXR0b25Qb3NpdGlvbikgdG8gc3VibWVudSBsaXN0cyBhbmQgZGVsZXRlZCBvbiBgZGVzdHJveWAgbWV0aG9kLCAnanMtZHJpbGxkb3duLWJhY2snIGNsYXNzIHJlcXVpcmVkLiBSZW1vdmUgdGhlIGJhY2tzbGFzaCAoYFxcYCkgaWYgY29weSBhbmQgcGFzdGluZy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnPGxpIGNsYXNzPVwianMtZHJpbGxkb3duLWJhY2tcIj48YSB0YWJpbmRleD1cIjBcIj5CYWNrPC9hPjwvbGk+J1xuICAgKi9cbiAgYmFja0J1dHRvbjogJzxsaSBjbGFzcz1cImpzLWRyaWxsZG93bi1iYWNrXCI+PGEgdGFiaW5kZXg9XCIwXCI+QmFjazwvYT48L2xpPicsXG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIHRoZSBiYWNrIGJ1dHRvbiBlaXRoZXIgYXQgdGhlIHRvcCBvciBib3R0b20gb2YgZHJpbGxkb3duIHN1Ym1lbnVzLiBDYW4gYmUgYCdsZWZ0J2Agb3IgYCdib3R0b20nYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCB0b3BcbiAgICovXG4gIGJhY2tCdXR0b25Qb3NpdGlvbjogJ3RvcCcsXG5cbiAgLyoqXG4gICAqIE1hcmt1cCB1c2VkIHRvIHdyYXAgZHJpbGxkb3duIG1lbnUuIFVzZSBhIGNsYXNzIG5hbWUgZm9yIGluZGVwZW5kZW50IHN0eWxpbmc7IHRoZSBKUyBhcHBsaWVkIGNsYXNzOiBgaXMtZHJpbGxkb3duYCBpcyByZXF1aXJlZC4gUmVtb3ZlIHRoZSBiYWNrc2xhc2ggKGBcXGApIGlmIGNvcHkgYW5kIHBhc3RpbmcuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJzxkaXY+PC9kaXY+J1xuICAgKi9cbiAgd3JhcHBlcjogJzxkaXY+PC9kaXY+JyxcblxuICAvKipcbiAgICogQWRkcyB0aGUgcGFyZW50IGxpbmsgdG8gdGhlIHN1Ym1lbnUuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBwYXJlbnRMaW5rOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3cgdGhlIG1lbnUgdG8gcmV0dXJuIHRvIHJvb3QgbGlzdCBvbiBib2R5IGNsaWNrLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY2xvc2VPbkNsaWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3cgdGhlIG1lbnUgdG8gYXV0byBhZGp1c3QgaGVpZ2h0LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYXV0b0hlaWdodDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgdGhlIGF1dG8gYWRqdXN0IGhlaWdodC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFuaW1hdGVIZWlnaHQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgbWVudSBhZnRlciBvcGVuaW5nIGEgc3VibWVudSBvciBuYXZpZ2F0aW5nIGJhY2sgdXNpbmcgdGhlIG1lbnUgYmFjayBidXR0b25cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNjcm9sbFRvcDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFN0cmluZyBqcXVlcnkgc2VsZWN0b3IgKGZvciBleGFtcGxlICdib2R5Jykgb2YgZWxlbWVudCB0byB0YWtlIG9mZnNldCgpLnRvcCBmcm9tLCBpZiBlbXB0eSBzdHJpbmcgdGhlIGRyaWxsZG93biBtZW51IG9mZnNldCgpLnRvcCBpcyB0YWtlblxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICBzY3JvbGxUb3BFbGVtZW50OiAnJyxcblxuICAvKipcbiAgICogU2Nyb2xsVG9wIG9mZnNldFxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHNjcm9sbFRvcE9mZnNldDogMCxcblxuICAvKipcbiAgICogU2Nyb2xsIGFuaW1hdGlvbiBkdXJhdGlvblxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDUwMFxuICAgKi9cbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcblxuICAvKipcbiAgICogU2Nyb2xsIGFuaW1hdGlvbiBlYXNpbmcuIENhbiBiZSBgJ3N3aW5nJ2Agb3IgYCdsaW5lYXInYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2FuaW1hdGV8SlF1ZXJ5IGFuaW1hdGV9XG4gICAqIEBkZWZhdWx0ICdzd2luZydcbiAgICovXG4gIGFuaW1hdGlvbkVhc2luZzogJ3N3aW5nJyAvLyBob2xkT3BlbjogZmFsc2VcblxufTtcblxudmFyIFBPU0lUSU9OUyA9IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ107XG52YXIgVkVSVElDQUxfQUxJR05NRU5UUyA9IFsndG9wJywgJ2JvdHRvbScsICdjZW50ZXInXTtcbnZhciBIT1JJWk9OVEFMX0FMSUdOTUVOVFMgPSBbJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJ107XG52YXIgQUxJR05NRU5UUyA9IHtcbiAgJ2xlZnQnOiBWRVJUSUNBTF9BTElHTk1FTlRTLFxuICAncmlnaHQnOiBWRVJUSUNBTF9BTElHTk1FTlRTLFxuICAndG9wJzogSE9SSVpPTlRBTF9BTElHTk1FTlRTLFxuICAnYm90dG9tJzogSE9SSVpPTlRBTF9BTElHTk1FTlRTXG59O1xuXG5mdW5jdGlvbiBuZXh0SXRlbShpdGVtLCBhcnJheSkge1xuICB2YXIgY3VycmVudElkeCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG5cbiAgaWYgKGN1cnJlbnRJZHggPT09IGFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4gYXJyYXlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFycmF5W2N1cnJlbnRJZHggKyAxXTtcbiAgfVxufVxuXG52YXIgUG9zaXRpb25hYmxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhQb3NpdGlvbmFibGUsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIFBvc2l0aW9uYWJsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zaXRpb25hYmxlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUG9zaXRpb25hYmxlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb3NpdGlvbmFibGUsIFt7XG4gICAga2V5OiBcIl9pbml0XCIsXG5cbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBjbGFzcyBlbmNhcHN1bGF0aW5nIHRoZSB0ZXRoZXItbGlrZSBleHBsaWNpdCBwb3NpdGlvbmluZyBsb2dpY1xuICAgICAqIGluY2x1ZGluZyByZXBvc2l0aW9uaW5nIGJhc2VkIG9uIG92ZXJsYXAuXG4gICAgICogRXhwZWN0cyBjbGFzc2VzIHRvIGRlZmluZSBkZWZhdWx0cyBmb3Igdk9mZnNldCwgaE9mZnNldCwgcG9zaXRpb24sXG4gICAgICogYWxpZ25tZW50LCBhbGxvd092ZXJsYXAsIGFuZCBhbGxvd0JvdHRvbU92ZXJsYXAuIFRoZXkgY2FuIGRvIHRoaXMgYnlcbiAgICAgKiBleHRlbmRpbmcgdGhlIGRlZmF1bHRzLCBvciAoZm9yIG5vdyByZWNvbW1lbmRlZCBkdWUgdG8gdGhlIHdheSBkb2NzIGFyZVxuICAgICAqIGdlbmVyYXRlZCkgYnkgZXhwbGljaXRseSBkZWNsYXJpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICB0aGlzLnRyaWVkUG9zaXRpb25zID0ge307XG4gICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYXV0bycgPyB0aGlzLl9nZXREZWZhdWx0UG9zaXRpb24oKSA6IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYWxpZ25tZW50ID0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2F1dG8nID8gdGhpcy5fZ2V0RGVmYXVsdEFsaWdubWVudCgpIDogdGhpcy5vcHRpb25zLmFsaWdubWVudDtcbiAgICAgIHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICB0aGlzLm9yaWdpbmFsQWxpZ25tZW50ID0gdGhpcy5hbGlnbm1lbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREZWZhdWx0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiAnYm90dG9tJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERlZmF1bHRBbGlnbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRBbGlnbm1lbnQoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICByZXR1cm4gcnRsKCkgPyAncmlnaHQnIDogJ2xlZnQnO1xuXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcmV0dXJuICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBwb3NpdGlvbmFibGUgcG9zc2libGUgcG9zaXRpb25zIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGFsaWdubWVudHNcbiAgICAgKiBhbmQgcG9zaXRpb25zLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVwb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVwb3NpdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9hbGlnbm1lbnRzRXhoYXVzdGVkKHRoaXMucG9zaXRpb24pKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXh0SXRlbSh0aGlzLnBvc2l0aW9uLCBQT1NJVElPTlMpO1xuICAgICAgICB0aGlzLmFsaWdubWVudCA9IEFMSUdOTUVOVFNbdGhpcy5wb3NpdGlvbl1bMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZWFsaWduKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGRyb3Bkb3duIHBhbmUgcG9zc2libGUgcG9zaXRpb25zIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGFsaWdubWVudHNcbiAgICAgKiBvbiB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlYWxpZ25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWxpZ24oKSB7XG4gICAgICB0aGlzLl9hZGRUcmllZFBvc2l0aW9uKHRoaXMucG9zaXRpb24sIHRoaXMuYWxpZ25tZW50KTtcblxuICAgICAgdGhpcy5hbGlnbm1lbnQgPSBuZXh0SXRlbSh0aGlzLmFsaWdubWVudCwgQUxJR05NRU5UU1t0aGlzLnBvc2l0aW9uXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRUcmllZFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRUcmllZFBvc2l0aW9uKHBvc2l0aW9uLCBhbGlnbm1lbnQpIHtcbiAgICAgIHRoaXMudHJpZWRQb3NpdGlvbnNbcG9zaXRpb25dID0gdGhpcy50cmllZFBvc2l0aW9uc1twb3NpdGlvbl0gfHwgW107XG4gICAgICB0aGlzLnRyaWVkUG9zaXRpb25zW3Bvc2l0aW9uXS5wdXNoKGFsaWdubWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wb3NpdGlvbnNFeGhhdXN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc2l0aW9uc0V4aGF1c3RlZCgpIHtcbiAgICAgIHZhciBpc0V4aGF1c3RlZCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUE9TSVRJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlzRXhoYXVzdGVkID0gaXNFeGhhdXN0ZWQgJiYgdGhpcy5fYWxpZ25tZW50c0V4aGF1c3RlZChQT1NJVElPTlNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNFeGhhdXN0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hbGlnbm1lbnRzRXhoYXVzdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hbGlnbm1lbnRzRXhoYXVzdGVkKHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmllZFBvc2l0aW9uc1twb3NpdGlvbl0gJiYgdGhpcy50cmllZFBvc2l0aW9uc1twb3NpdGlvbl0ubGVuZ3RoID09IEFMSUdOTUVOVFNbcG9zaXRpb25dLmxlbmd0aDtcbiAgICB9IC8vIFdoZW4gd2UncmUgdHJ5aW5nIHRvIGNlbnRlciwgd2UgZG9uJ3Qgd2FudCB0byBhcHBseSBvZmZzZXQgdGhhdCdzIGdvaW5nIHRvXG4gICAgLy8gdGFrZSB1cyBqdXN0IG9mZiBjZW50ZXIsIHNvIHdyYXAgYXJvdW5kIHRvIHJldHVybiAwIGZvciB0aGUgYXBwcm9wcmlhdGVcbiAgICAvLyBvZmZzZXQgaW4gdGhvc2UgYWxpZ25tZW50cy4gIFRPRE86IEZpZ3VyZSBvdXQgaWYgd2Ugd2FudCB0byBtYWtlIHRoaXNcbiAgICAvLyBjb25maWd1cmFibGUgYmVoYXZpb3IuLi4gaXQgZmVlbHMgbW9yZSBpbnR1aXRpdmUsIGVzcGVjaWFsbHkgZm9yIHRvb2x0aXBzLCBidXRcbiAgICAvLyBpdCdzIHBvc3NpYmxlIHNvbWVvbmUgbWlnaHQgYWN0dWFsbHkgd2FudCB0byBzdGFydCBmcm9tIGNlbnRlciBhbmQgdGhlbiBudWRnZVxuICAgIC8vIHNsaWdodGx5IG9mZi5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWT2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52T2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0SE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SE9mZnNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaE9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigkYW5jaG9yLCAkZWxlbWVudCwgJHBhcmVudCkge1xuICAgICAgaWYgKCRhbmNob3IuYXR0cignYXJpYS1leHBhbmRlZCcpID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyICRlbGVEaW1zID0gQm94LkdldERpbWVuc2lvbnMoJGVsZW1lbnQpLFxuICAgICAgICAgICRhbmNob3JEaW1zID0gQm94LkdldERpbWVuc2lvbnMoJGFuY2hvcik7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93T3ZlcmxhcCkge1xuICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHBvc2l0aW9uICYgYWxpZ25tZW50IGJlZm9yZSBjaGVja2luZyBvdmVybGFwXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLm9yaWdpbmFsUG9zaXRpb247XG4gICAgICAgIHRoaXMuYWxpZ25tZW50ID0gdGhpcy5vcmlnaW5hbEFsaWdubWVudDtcbiAgICAgIH1cblxuICAgICAgJGVsZW1lbnQub2Zmc2V0KEJveC5HZXRFeHBsaWNpdE9mZnNldHMoJGVsZW1lbnQsICRhbmNob3IsIHRoaXMucG9zaXRpb24sIHRoaXMuYWxpZ25tZW50LCB0aGlzLl9nZXRWT2Zmc2V0KCksIHRoaXMuX2dldEhPZmZzZXQoKSkpO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd092ZXJsYXApIHtcbiAgICAgICAgdmFyIG1pbk92ZXJsYXAgPSAxMDAwMDAwMDA7IC8vIGRlZmF1bHQgY29vcmRpbmF0ZXMgdG8gaG93IHdlIHN0YXJ0LCBpbiBjYXNlIHdlIGNhbid0IGZpZ3VyZSBvdXQgYmV0dGVyXG5cbiAgICAgICAgdmFyIG1pbkNvb3JkaW5hdGVzID0ge1xuICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgIGFsaWdubWVudDogdGhpcy5hbGlnbm1lbnRcbiAgICAgICAgfTtcblxuICAgICAgICB3aGlsZSAoIXRoaXMuX3Bvc2l0aW9uc0V4aGF1c3RlZCgpKSB7XG4gICAgICAgICAgdmFyIG92ZXJsYXAgPSBCb3guT3ZlcmxhcEFyZWEoJGVsZW1lbnQsICRwYXJlbnQsIGZhbHNlLCBmYWxzZSwgdGhpcy5vcHRpb25zLmFsbG93Qm90dG9tT3ZlcmxhcCk7XG5cbiAgICAgICAgICBpZiAob3ZlcmxhcCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICBtaW5Db29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb24sXG4gICAgICAgICAgICAgIGFsaWdubWVudDogdGhpcy5hbGlnbm1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fcmVwb3NpdGlvbigpO1xuXG4gICAgICAgICAgJGVsZW1lbnQub2Zmc2V0KEJveC5HZXRFeHBsaWNpdE9mZnNldHMoJGVsZW1lbnQsICRhbmNob3IsIHRoaXMucG9zaXRpb24sIHRoaXMuYWxpZ25tZW50LCB0aGlzLl9nZXRWT2Zmc2V0KCksIHRoaXMuX2dldEhPZmZzZXQoKSkpO1xuICAgICAgICB9IC8vIElmIHdlIGdldCB0aHJvdWdoIHRoZSBlbnRpcmUgbG9vcCwgdGhlcmUgd2FzIG5vIG5vbi1vdmVybGFwcGluZ1xuICAgICAgICAvLyBwb3NpdGlvbiBhdmFpbGFibGUuIFBpY2sgdGhlIHZlcnNpb24gd2l0aCBsZWFzdCBvdmVybGFwLlxuXG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG1pbkNvb3JkaW5hdGVzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFsaWdubWVudCA9IG1pbkNvb3JkaW5hdGVzLmFsaWdubWVudDtcbiAgICAgICAgJGVsZW1lbnQub2Zmc2V0KEJveC5HZXRFeHBsaWNpdE9mZnNldHMoJGVsZW1lbnQsICRhbmNob3IsIHRoaXMucG9zaXRpb24sIHRoaXMuYWxpZ25tZW50LCB0aGlzLl9nZXRWT2Zmc2V0KCksIHRoaXMuX2dldEhPZmZzZXQoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb3NpdGlvbmFibGU7XG59KFBsdWdpbik7XG5cblBvc2l0aW9uYWJsZS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvc2l0aW9uIG9mIHBvc2l0aW9uYWJsZSByZWxhdGl2ZSB0byBhbmNob3IuIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG9yIGF1dG8uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2F1dG8nXG4gICAqL1xuICBwb3NpdGlvbjogJ2F1dG8nLFxuXG4gIC8qKlxuICAgKiBBbGlnbm1lbnQgb2YgcG9zaXRpb25hYmxlIHJlbGF0aXZlIHRvIGFuY2hvci4gQ2FuIGJlIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgY2VudGVyLCBvciBhdXRvLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xuICAgKi9cbiAgYWxpZ25tZW50OiAnYXV0bycsXG5cbiAgLyoqXG4gICAqIEFsbG93IG92ZXJsYXAgb2YgY29udGFpbmVyL3dpbmRvdy4gSWYgZmFsc2UsIGRyb3Bkb3duIHBvc2l0aW9uYWJsZSBmaXJzdFxuICAgKiB0cnkgdG8gcG9zaXRpb24gYXMgZGVmaW5lZCBieSBkYXRhLXBvc2l0aW9uIGFuZCBkYXRhLWFsaWdubWVudCwgYnV0XG4gICAqIHJlcG9zaXRpb24gaWYgaXQgd291bGQgY2F1c2UgYW4gb3ZlcmZsb3cuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhbGxvd092ZXJsYXA6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBBbGxvdyBvdmVybGFwIG9mIG9ubHkgdGhlIGJvdHRvbSBvZiB0aGUgY29udGFpbmVyLiBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vblxuICAgKiBiZWhhdmlvciBmb3IgZHJvcGRvd25zLCBhbGxvd2luZyB0aGUgZHJvcGRvd24gdG8gZXh0ZW5kIHRoZSBib3R0b20gb2YgdGhlXG4gICAqIHNjcmVlbiBidXQgbm90IG90aGVyd2lzZSBpbmZsdWVuY2Ugb3IgYnJlYWsgb3V0IG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGFsbG93Qm90dG9tT3ZlcmxhcDogdHJ1ZSxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0aGUgcG9zaXRpb25hYmxlIHNob3VsZCBiZSBzZXBhcmF0ZWQgdmVydGljYWxseSBmcm9tIGFuY2hvclxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHZPZmZzZXQ6IDAsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgdGhlIHBvc2l0aW9uYWJsZSBzaG91bGQgYmUgc2VwYXJhdGVkIGhvcml6b250YWxseSBmcm9tIGFuY2hvclxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGhPZmZzZXQ6IDBcbn07XG5cbi8qKlxuICogRHJvcGRvd24gbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICovXG5cbnZhciBEcm9wZG93biA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1Bvc2l0aW9uYWJsZSkge1xuICBfaW5oZXJpdHMoRHJvcGRvd24sIF9Qb3NpdGlvbmFibGUpO1xuXG4gIGZ1bmN0aW9uIERyb3Bkb3duKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKERyb3Bkb3duKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEcm9wZG93biwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgZHJvcGRvd24uXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgRHJvcGRvd25cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgZHJvcGRvd24uXG4gICAgICogICAgICAgIE9iamVjdCBzaG91bGQgYmUgb2YgdGhlIGRyb3Bkb3duIHBhbmVsLCByYXRoZXIgdGhhbiBpdHMgYW5jaG9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIERyb3Bkb3duLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdEcm9wZG93bic7IC8vIGllOSBiYWNrIGNvbXBhdFxuICAgICAgLy8gVHJpZ2dlcnMgaW5pdCBpcyBpZGVtcG90ZW50LCBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0IGlzIGluaXRpYWxpemVkXG5cbiAgICAgIFRyaWdnZXJzLmluaXQoJCk7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgS2V5Ym9hcmQucmVnaXN0ZXIoJ0Ryb3Bkb3duJywge1xuICAgICAgICAnRU5URVInOiAndG9nZ2xlJyxcbiAgICAgICAgJ1NQQUNFJzogJ3RvZ2dsZScsXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBieSBzZXR0aW5nL2NoZWNraW5nIG9wdGlvbnMgYW5kIGF0dHJpYnV0ZXMsIGFkZGluZyBoZWxwZXIgdmFyaWFibGVzLCBhbmQgc2F2aW5nIHRoZSBhbmNob3IuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyICRpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcbiAgICAgIHRoaXMuJGFuY2hvcnMgPSAkKFwiW2RhdGEtdG9nZ2xlPVxcXCJcIi5jb25jYXQoJGlkLCBcIlxcXCJdXCIpKS5sZW5ndGggPyAkKFwiW2RhdGEtdG9nZ2xlPVxcXCJcIi5jb25jYXQoJGlkLCBcIlxcXCJdXCIpKSA6ICQoXCJbZGF0YS1vcGVuPVxcXCJcIi5jb25jYXQoJGlkLCBcIlxcXCJdXCIpKTtcbiAgICAgIHRoaXMuJGFuY2hvcnMuYXR0cih7XG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogJGlkLFxuICAgICAgICAnZGF0YS1pcy1mb2N1cyc6IGZhbHNlLFxuICAgICAgICAnZGF0YS15ZXRpLWJveCc6ICRpZCxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fc2V0Q3VycmVudEFuY2hvcih0aGlzLiRhbmNob3JzLmZpcnN0KCkpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudENsYXNzKSB7XG4gICAgICAgIHRoaXMuJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQucGFyZW50cygnLicgKyB0aGlzLm9wdGlvbnMucGFyZW50Q2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kcGFyZW50ID0gbnVsbDtcbiAgICAgIH0gLy8gU2V0IFthcmlhLWxhYmVsbGVkYnldIG9uIHRoZSBEcm9wZG93biBpZiBpdCBpcyBub3Qgc2V0XG5cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtbGFiZWxsZWRieScpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBHZXQgdGhlIGFuY2hvciBJRCBvciBjcmVhdGUgb25lXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy4kY3VycmVudEFuY2hvci5hdHRyKCdpZCcpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuJGN1cnJlbnRBbmNob3IuYXR0cignaWQnLCBHZXRZb0RpZ2l0cyg2LCAnZGQtYW5jaG9yJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1sYWJlbGxlZGJ5JywgdGhpcy4kY3VycmVudEFuY2hvci5hdHRyKCdpZCcpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxuICAgICAgICAnZGF0YS15ZXRpLWJveCc6ICRpZCxcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogJGlkXG4gICAgICB9KTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24ucHJvdG90eXBlKSwgXCJfaW5pdFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERlZmF1bHRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdFBvc2l0aW9uKCkge1xuICAgICAgLy8gaGFuZGxlIGxlZ2FjeSBjbGFzc25hbWVzXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbSkvZyk7XG5cbiAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gcG9zaXRpb25bMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREZWZhdWx0QWxpZ25tZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREZWZhdWx0QWxpZ25tZW50KCkge1xuICAgICAgLy8gaGFuZGxlIGxlZ2FjeSBmbG9hdCBhcHByb2FjaFxuICAgICAgdmFyIGhvcml6b250YWxQb3NpdGlvbiA9IC9mbG9hdC0oXFxTKykvLmV4ZWModGhpcy4kY3VycmVudEFuY2hvci5hdHRyKCdjbGFzcycpKTtcblxuICAgICAgaWYgKGhvcml6b250YWxQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gaG9yaXpvbnRhbFBvc2l0aW9uWzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24ucHJvdG90eXBlKSwgXCJfZ2V0RGVmYXVsdEFsaWdubWVudFwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgdGhlIGRyb3Bkb3duIHBhbmUsIGNoZWNrcyBmb3IgY29sbGlzaW9ucyBpZiBhbGxvdy1vdmVybGFwIGlzIG5vdCB0cnVlLlxuICAgICAqIFJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiBpZiBhIGNvbGxpc2lvbiBpcyBkZXRlY3RlZCwgd2l0aCBhIG5ldyBwb3NpdGlvbiBjbGFzcy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJoYXMtcG9zaXRpb24tXCIuY29uY2F0KHRoaXMucG9zaXRpb24sIFwiIGhhcy1hbGlnbm1lbnQtXCIpLmNvbmNhdCh0aGlzLmFsaWdubWVudCkpO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihEcm9wZG93bi5wcm90b3R5cGUpLCBcIl9zZXRQb3NpdGlvblwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMuJGN1cnJlbnRBbmNob3IsIHRoaXMuJGVsZW1lbnQsIHRoaXMuJHBhcmVudCk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXCJoYXMtcG9zaXRpb24tXCIuY29uY2F0KHRoaXMucG9zaXRpb24sIFwiIGhhcy1hbGlnbm1lbnQtXCIpLmNvbmNhdCh0aGlzLmFsaWdubWVudCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlIGl0IGEgY3VycmVudCBhbmNob3IuXG4gICAgICogQ3VycmVudCBhbmNob3IgYXMgdGhlIHJlZmVyZW5jZSBmb3IgdGhlIHBvc2l0aW9uIG9mIERyb3Bkb3duIHBhbmVzLlxuICAgICAqIEBwYXJhbSB7SFRNTH0gZWwgLSBET00gZWxlbWVudCBvZiB0aGUgYW5jaG9yLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0Q3VycmVudEFuY2hvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q3VycmVudEFuY2hvcihlbCkge1xuICAgICAgdGhpcy4kY3VycmVudEFuY2hvciA9ICQoZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgZWxlbWVudCB1dGlsaXppbmcgdGhlIHRyaWdnZXJzIHV0aWxpdHkgbGlicmFyeS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcbiAgICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksXG4gICAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXG4gICAgICAgICdyZXNpemVtZS56Zi50cmlnZ2VyJzogdGhpcy5fc2V0UG9zaXRpb24uYmluZCh0aGlzKVxuICAgICAgfSk7XG4gICAgICB0aGlzLiRhbmNob3JzLm9mZignY2xpY2suemYudHJpZ2dlcicpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fc2V0Q3VycmVudEFuY2hvcih0aGlzKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyKSB7XG4gICAgICAgIHRoaXMuJGFuY2hvcnMub2ZmKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd24nKS5vbignbW91c2VlbnRlci56Zi5kcm9wZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5fc2V0Q3VycmVudEFuY2hvcih0aGlzKTtcblxuICAgICAgICAgIHZhciBib2R5RGF0YSA9ICQoJ2JvZHknKS5kYXRhKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGJvZHlEYXRhLndoYXRpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgfHwgYm9keURhdGEud2hhdGlucHV0ID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcblxuICAgICAgICAgICAgICBfdGhpcy4kYW5jaG9ycy5kYXRhKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJywgaWdub3JlTW91c2VkaXNhcHBlYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgICAgICBfdGhpcy4kYW5jaG9ycy5kYXRhKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlclBhbmUpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignbW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJykub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd24nLCBpZ25vcmVNb3VzZWRpc2FwcGVhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvcnMuZGF0YSgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLiRhbmNob3JzLmFkZCh0aGlzLiRlbGVtZW50KS5vbigna2V5ZG93bi56Zi5kcm9wZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciAkdGFyZ2V0ID0gJCh0aGlzKSxcbiAgICAgICAgICAgIHZpc2libGVGb2N1c2FibGVFbGVtZW50cyA9IEtleWJvYXJkLmZpbmRGb2N1c2FibGUoX3RoaXMuJGVsZW1lbnQpO1xuICAgICAgICBLZXlib2FyZC5oYW5kbGVLZXkoZSwgJ0Ryb3Bkb3duJywge1xuICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgICAgICBpZiAoJHRhcmdldC5pcyhfdGhpcy4kYW5jaG9ycykgJiYgISR0YXJnZXQuaXMoJ2lucHV0LCB0ZXh0YXJlYScpKSB7XG4gICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcblxuICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKS5mb2N1cygpO1xuXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgICAgIF90aGlzLiRhbmNob3JzLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGJvZHkgdG8gY2xvc2UgYW55IGRyb3Bkb3ducyBvbiBhIGNsaWNrLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQm9keUhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvZHlIYW5kbGVyKCkge1xuICAgICAgdmFyICRib2R5ID0gJChkb2N1bWVudC5ib2R5KS5ub3QodGhpcy4kZWxlbWVudCksXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAkYm9keS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duJykub24oJ2NsaWNrLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKF90aGlzLiRhbmNob3JzLmlzKGUudGFyZ2V0KSB8fCBfdGhpcy4kYW5jaG9ycy5maW5kKGUudGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuaXMoZS50YXJnZXQpIHx8IF90aGlzLiRlbGVtZW50LmZpbmQoZS50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgJGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93bicpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBkcm9wZG93biBwYW5lLCBhbmQgZmlyZXMgYSBidWJibGluZyBldmVudCB0byBjbG9zZSBvdGhlciBkcm9wZG93bnMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIERyb3Bkb3duI2Nsb3NlbWVcbiAgICAgKiBAZmlyZXMgRHJvcGRvd24jc2hvd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgLy8gdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB0byBjbG9zZSBvdGhlciBvcGVuIGRyb3Bkb3ducywgdHlwaWNhbGx5IHdoZW4gZHJvcGRvd24gaXMgb3BlbmluZ1xuICAgICAgICogQGV2ZW50IERyb3Bkb3duI2Nsb3NlbWVcbiAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZW1lLnpmLmRyb3Bkb3duJywgdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKTtcbiAgICAgIHRoaXMuJGFuY2hvcnMuYWRkQ2xhc3MoJ2hvdmVyJykuYXR0cih7XG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogdHJ1ZVxuICAgICAgfSk7IC8vIHRoaXMuJGVsZW1lbnQvKi5zaG93KCkqLztcblxuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnaXMtb3BlbmluZycpO1xuXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuaW5nJykuYWRkQ2xhc3MoJ2lzLW9wZW4nKS5hdHRyKHtcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Gb2N1cykge1xuICAgICAgICB2YXIgJGZvY3VzYWJsZSA9IEtleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCRmb2N1c2FibGUubGVuZ3RoKSB7XG4gICAgICAgICAgJGZvY3VzYWJsZS5lcSgwKS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhcEZvY3VzKSB7XG4gICAgICAgIEtleWJvYXJkLnRyYXBGb2N1cyh0aGlzLiRlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgb25jZSB0aGUgZHJvcGRvd24gaXMgdmlzaWJsZS5cbiAgICAgICAqIEBldmVudCBEcm9wZG93biNzaG93XG4gICAgICAgKi9cblxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYuZHJvcGRvd24nLCBbdGhpcy4kZWxlbWVudF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG9wZW4gZHJvcGRvd24gcGFuZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZmlyZXMgRHJvcGRvd24jaGlkZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKS5hdHRyKHtcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLiRhbmNob3JzLnJlbW92ZUNsYXNzKCdob3ZlcicpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIG9uY2UgdGhlIGRyb3Bkb3duIGlzIG5vIGxvbmdlciB2aXNpYmxlLlxuICAgICAgICogQGV2ZW50IERyb3Bkb3duI2hpZGVcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYuZHJvcGRvd24nLCBbdGhpcy4kZWxlbWVudF0pO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRyYXBGb2N1cykge1xuICAgICAgICBLZXlib2FyZC5yZWxlYXNlRm9jdXModGhpcy4kZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGRyb3Bkb3duIHBhbmUncyB2aXNpYmlsaXR5LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcbiAgICAgICAgaWYgKHRoaXMuJGFuY2hvcnMuZGF0YSgnaG92ZXInKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGRyb3Bkb3duLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXInKS5oaWRlKCk7XG4gICAgICB0aGlzLiRhbmNob3JzLm9mZignLnpmLmRyb3Bkb3duJyk7XG4gICAgICAkKGRvY3VtZW50LmJvZHkpLm9mZignY2xpY2suemYuZHJvcGRvd24nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRHJvcGRvd247XG59KFBvc2l0aW9uYWJsZSk7XG5cbkRyb3Bkb3duLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogQ2xhc3MgdGhhdCBkZXNpZ25hdGVzIGJvdW5kaW5nIGNvbnRhaW5lciBvZiBEcm9wZG93biAoZGVmYXVsdDogd2luZG93KVxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBwYXJlbnRDbGFzczogbnVsbCxcblxuICAvKipcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgb3BlbmluZyBhIHN1Ym1lbnUgb24gaG92ZXIgZXZlbnQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMjUwXG4gICAqL1xuICBob3ZlckRlbGF5OiAyNTAsXG5cbiAgLyoqXG4gICAqIEFsbG93IHN1Ym1lbnVzIHRvIG9wZW4gb24gaG92ZXIgZXZlbnRzXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBob3ZlcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIERvbid0IGNsb3NlIGRyb3Bkb3duIHdoZW4gaG92ZXJpbmcgb3ZlciBkcm9wZG93biBwYW5lXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBob3ZlclBhbmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB2T2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBoT2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiBvZiBkcm9wZG93bi4gQ2FuIGJlIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgb3IgYXV0by5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnYXV0bydcbiAgICovXG4gIHBvc2l0aW9uOiAnYXV0bycsXG5cbiAgLyoqXG4gICAqIEFsaWdubWVudCBvZiBkcm9wZG93biByZWxhdGl2ZSB0byBhbmNob3IuIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIGNlbnRlciwgb3IgYXV0by5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnYXV0bydcbiAgICovXG4gIGFsaWdubWVudDogJ2F1dG8nLFxuXG4gIC8qKlxuICAgKiBBbGxvdyBvdmVybGFwIG9mIGNvbnRhaW5lci93aW5kb3cuIElmIGZhbHNlLCBkcm9wZG93biB3aWxsIGZpcnN0IHRyeSB0byBwb3NpdGlvbiBhcyBkZWZpbmVkIGJ5IGRhdGEtcG9zaXRpb24gYW5kIGRhdGEtYWxpZ25tZW50LCBidXQgcmVwb3NpdGlvbiBpZiBpdCB3b3VsZCBjYXVzZSBhbiBvdmVyZmxvdy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFsbG93T3ZlcmxhcDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93IG92ZXJsYXAgb2Ygb25seSB0aGUgYm90dG9tIG9mIHRoZSBjb250YWluZXIuIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uXG4gICAqIGJlaGF2aW9yIGZvciBkcm9wZG93bnMsIGFsbG93aW5nIHRoZSBkcm9wZG93biB0byBleHRlbmQgdGhlIGJvdHRvbSBvZiB0aGVcbiAgICogc2NyZWVuIGJ1dCBub3Qgb3RoZXJ3aXNlIGluZmx1ZW5jZSBvciBicmVhayBvdXQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgYWxsb3dCb3R0b21PdmVybGFwOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgcGx1Z2luIHRvIHRyYXAgZm9jdXMgdG8gdGhlIGRyb3Bkb3duIHBhbmUgaWYgb3BlbmVkIHdpdGgga2V5Ym9hcmQgY29tbWFuZHMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB0cmFwRm9jdXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgcGx1Z2luIHRvIHNldCBmb2N1cyB0byB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBwYW5lLCByZWdhcmRsZXNzIG9mIG1ldGhvZCBvZiBvcGVuaW5nLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYXV0b0ZvY3VzOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3dzIGEgY2xpY2sgb24gdGhlIGJvZHkgdG8gY2xvc2UgdGhlIGRyb3Bkb3duLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY2xvc2VPbkNsaWNrOiBmYWxzZVxufTtcblxuLyoqXG4gKiBEcm9wZG93bk1lbnUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duLW1lbnVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcbiAqL1xuXG52YXIgRHJvcGRvd25NZW51ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhEcm9wZG93bk1lbnUsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIERyb3Bkb3duTWVudSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcGRvd25NZW51KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRHJvcGRvd25NZW51KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEcm9wZG93bk1lbnUsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBEcm9wZG93bk1lbnUuXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgRHJvcGRvd25NZW51XG4gICAgICogQGZpcmVzIERyb3Bkb3duTWVudSNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIGRyb3Bkb3duIG1lbnUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRHJvcGRvd25NZW51LmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdEcm9wZG93bk1lbnUnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICBLZXlib2FyZC5yZWdpc3RlcignRHJvcGRvd25NZW51Jywge1xuICAgICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAgICdTUEFDRSc6ICdvcGVuJyxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxuICAgICAgICAnQVJST1dfVVAnOiAndXAnLFxuICAgICAgICAnQVJST1dfRE9XTic6ICdkb3duJyxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnLFxuICAgICAgICAnRVNDQVBFJzogJ2Nsb3NlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4sIGFuZCBjYWxscyBfcHJlcGFyZU1lbnVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBOZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCwgJ2Ryb3Bkb3duJyk7XG4gICAgICB2YXIgc3VicyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpLmFkZENsYXNzKCdmaXJzdC1zdWInKTtcbiAgICAgIHRoaXMuJG1lbnVJdGVtcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW3JvbGU9XCJtZW51aXRlbVwiXScpO1xuICAgICAgdGhpcy4kdGFicyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ1tyb2xlPVwibWVudWl0ZW1cIl0nKTtcbiAgICAgIHRoaXMuJHRhYnMuZmluZCgndWwuaXMtZHJvcGRvd24tc3VibWVudScpLmFkZENsYXNzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbENsYXNzKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdhdXRvJykge1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMucmlnaHRDbGFzcykgfHwgcnRsKCkgfHwgdGhpcy4kZWxlbWVudC5wYXJlbnRzKCcudG9wLWJhci1yaWdodCcpLmlzKCcqJykpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICBzdWJzLmFkZENsYXNzKCdvcGVucy1sZWZ0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFsaWdubWVudCA9ICdsZWZ0JztcbiAgICAgICAgICBzdWJzLmFkZENsYXNzKCdvcGVucy1yaWdodCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHN1YnMuYWRkQ2xhc3MoJ29wZW5zLWxlZnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJzLmFkZENsYXNzKCdvcGVucy1yaWdodCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVmVydGljYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzVmVydGljYWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kdGFicy5jc3MoJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJyB8fCB0aGlzLiRlbGVtZW50LmNzcygnZmxleC1kaXJlY3Rpb24nKSA9PT0gJ2NvbHVtbic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc1J0bFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNSdGwoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWxpZ24tcmlnaHQnKSB8fCBydGwoKSAmJiAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWxpZ24tbGVmdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBoYXNUb3VjaCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCB0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgcGFyQ2xhc3MgPSAnaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnOyAvLyB1c2VkIGZvciBvbkNsaWNrIGFuZCBpbiB0aGUga2V5Ym9hcmQgaGFuZGxlcnNcblxuXG4gICAgICB2YXIgaGFuZGxlQ2xpY2tGbiA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrRm4oZSkge1xuICAgICAgICB2YXIgJGVsZW0gPSAkKGUudGFyZ2V0KS5wYXJlbnRzVW50aWwoJ3VsJywgXCIuXCIuY29uY2F0KHBhckNsYXNzKSksXG4gICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyksXG4gICAgICAgICAgICBoYXNDbGlja2VkID0gJGVsZW0uYXR0cignZGF0YS1pcy1jbGljaycpID09PSAndHJ1ZScsXG4gICAgICAgICAgICAkc3ViID0gJGVsZW0uY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51Jyk7XG5cbiAgICAgICAgaWYgKGhhc1N1Yikge1xuICAgICAgICAgIGlmIChoYXNDbGlja2VkKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIHx8ICFfdGhpcy5vcHRpb25zLmNsaWNrT3BlbiAmJiAhaGFzVG91Y2ggfHwgX3RoaXMub3B0aW9ucy5mb3JjZUZvbGxvdyAmJiBoYXNUb3VjaCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBfdGhpcy5fc2hvdygkc3ViKTtcblxuICAgICAgICAgICAgJGVsZW0uYWRkKCRlbGVtLnBhcmVudHNVbnRpbChfdGhpcy4kZWxlbWVudCwgXCIuXCIuY29uY2F0KHBhckNsYXNzKSkpLmF0dHIoJ2RhdGEtaXMtY2xpY2snLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xpY2tPcGVuIHx8IGhhc1RvdWNoKSB7XG4gICAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbignY2xpY2suemYuZHJvcGRvd25tZW51IHRvdWNoc3RhcnQuemYuZHJvcGRvd25tZW51JywgaGFuZGxlQ2xpY2tGbik7XG4gICAgICB9IC8vIEhhbmRsZSBMZWFmIGVsZW1lbnQgQ2xpY2tzXG5cblxuICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrSW5zaWRlKSB7XG4gICAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbignY2xpY2suemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyk7XG5cbiAgICAgICAgICBpZiAoIWhhc1N1Yikge1xuICAgICAgICAgICAgX3RoaXMuX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIpIHtcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3dubWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyICRlbGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO1xuXG4gICAgICAgICAgaWYgKGhhc1N1Yikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCRlbGVtLmRhdGEoJ19kZWxheScpKTtcbiAgICAgICAgICAgICRlbGVtLmRhdGEoJ19kZWxheScsIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKSk7XG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLmRyb3Bkb3duTWVudScsIGlnbm9yZU1vdXNlZGlzYXBwZWFyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyICRlbGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO1xuXG4gICAgICAgICAgaWYgKGhhc1N1YiAmJiBfdGhpcy5vcHRpb25zLmF1dG9jbG9zZSkge1xuICAgICAgICAgICAgaWYgKCRlbGVtLmF0dHIoJ2RhdGEtaXMtY2xpY2snKSA9PT0gJ3RydWUnICYmIF90aGlzLm9wdGlvbnMuY2xpY2tPcGVuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCRlbGVtLmRhdGEoJ19kZWxheScpKTtcbiAgICAgICAgICAgICRlbGVtLmRhdGEoJ19kZWxheScsIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmNsb3NpbmdUaW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbigna2V5ZG93bi56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGUudGFyZ2V0KS5wYXJlbnRzVW50aWwoJ3VsJywgJ1tyb2xlPVwibWVudWl0ZW1cIl0nKSxcbiAgICAgICAgICAgIGlzVGFiID0gX3RoaXMuJHRhYnMuaW5kZXgoJGVsZW1lbnQpID4gLTEsXG4gICAgICAgICAgICAkZWxlbWVudHMgPSBpc1RhYiA/IF90aGlzLiR0YWJzIDogJGVsZW1lbnQuc2libGluZ3MoJ2xpJykuYWRkKCRlbGVtZW50KSxcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudDtcbiAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBpZiAoJCh0aGlzKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShpIC0gMSk7XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoaSArIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gZnVuY3Rpb24gbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgICAgJG5leHRFbGVtZW50LmNoaWxkcmVuKCdhOmZpcnN0JykuZm9jdXMoKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2U2libGluZyA9IGZ1bmN0aW9uIHByZXZTaWJsaW5nKCkge1xuICAgICAgICAgICRwcmV2RWxlbWVudC5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgb3BlblN1YiA9IGZ1bmN0aW9uIG9wZW5TdWIoKSB7XG4gICAgICAgICAgdmFyICRzdWIgPSAkZWxlbWVudC5jaGlsZHJlbigndWwuaXMtZHJvcGRvd24tc3VibWVudScpO1xuXG4gICAgICAgICAgaWYgKCRzdWIubGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpcy5fc2hvdygkc3ViKTtcblxuICAgICAgICAgICAgJGVsZW1lbnQuZmluZCgnbGkgPiBhOmZpcnN0JykuZm9jdXMoKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlU3ViID0gZnVuY3Rpb24gY2xvc2VTdWIoKSB7XG4gICAgICAgICAgLy9pZiAoJGVsZW1lbnQuaXMoJzpmaXJzdC1jaGlsZCcpKSB7XG4gICAgICAgICAgdmFyIGNsb3NlID0gJGVsZW1lbnQucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKTtcbiAgICAgICAgICBjbG9zZS5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XG5cbiAgICAgICAgICBfdGhpcy5faGlkZShjbG9zZSk7XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBmdW5jdGlvbnMgPSB7XG4gICAgICAgICAgb3Blbjogb3BlblN1YixcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICBfdGhpcy5faGlkZShfdGhpcy4kZWxlbWVudCk7XG5cbiAgICAgICAgICAgIF90aGlzLiRtZW51SXRlbXMuZXEoMCkuY2hpbGRyZW4oJ2EnKS5mb2N1cygpOyAvLyBmb2N1cyB0byBmaXJzdCBlbGVtZW50XG5cblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc1RhYikge1xuICAgICAgICAgIGlmIChfdGhpcy5faXNWZXJ0aWNhbCgpKSB7XG4gICAgICAgICAgICAvLyB2ZXJ0aWNhbCBtZW51XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lzUnRsKCkpIHtcbiAgICAgICAgICAgICAgLy8gcmlnaHQgYWxpZ25lZFxuICAgICAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgbmV4dDogY2xvc2VTdWIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IG9wZW5TdWJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsZWZ0IGFsaWduZWRcbiAgICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgIG5leHQ6IG9wZW5TdWIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IGNsb3NlU3ViXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBob3Jpem9udGFsIG1lbnVcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNSdGwoKSkge1xuICAgICAgICAgICAgICAvLyByaWdodCBhbGlnbmVkXG4gICAgICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgICAgIG5leHQ6IHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBuZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICBkb3duOiBvcGVuU3ViLFxuICAgICAgICAgICAgICAgIHVwOiBjbG9zZVN1YlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGxlZnQgYWxpZ25lZFxuICAgICAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZG93bjogb3BlblN1YixcbiAgICAgICAgICAgICAgICB1cDogY2xvc2VTdWJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdCB0YWJzIC0+IG9uZSBzdWJcbiAgICAgICAgICBpZiAoX3RoaXMuX2lzUnRsKCkpIHtcbiAgICAgICAgICAgIC8vIHJpZ2h0IGFsaWduZWRcbiAgICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgICBuZXh0OiBjbG9zZVN1YixcbiAgICAgICAgICAgICAgcHJldmlvdXM6IG9wZW5TdWIsXG4gICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBsZWZ0IGFsaWduZWRcbiAgICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgICBuZXh0OiBvcGVuU3ViLFxuICAgICAgICAgICAgICBwcmV2aW91czogY2xvc2VTdWIsXG4gICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnRHJvcGRvd25NZW51JywgZnVuY3Rpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGJvZHkgdG8gY2xvc2UgYW55IGRyb3Bkb3ducyBvbiBhIGNsaWNrLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQm9keUhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvZHlIYW5kbGVyKCkge1xuICAgICAgdmFyICRib2R5ID0gJChkb2N1bWVudC5ib2R5KSxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICRib2R5Lm9mZignbW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51Jykub24oJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciAkbGluayA9IF90aGlzLiRlbGVtZW50LmZpbmQoZS50YXJnZXQpO1xuXG4gICAgICAgIGlmICgkbGluay5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5faGlkZSgpO1xuXG4gICAgICAgICRib2R5Lm9mZignbW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51Jyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBkcm9wZG93biBwYW5lLCBhbmQgY2hlY2tzIGZvciBjb2xsaXNpb25zIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkc3ViIC0gdWwgZWxlbWVudCB0aGF0IGlzIGEgc3VibWVudSB0byBzaG93XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZmlyZXMgRHJvcGRvd25tZW51I3Nob3dcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93KCRzdWIpIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLiR0YWJzLmluZGV4KHRoaXMuJHRhYnMuZmlsdGVyKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICByZXR1cm4gJChlbCkuZmluZCgkc3ViKS5sZW5ndGggPiAwO1xuICAgICAgfSkpO1xuICAgICAgdmFyICRzaWJzID0gJHN1Yi5wYXJlbnQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jykuc2libGluZ3MoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jyk7XG5cbiAgICAgIHRoaXMuX2hpZGUoJHNpYnMsIGlkeCk7XG5cbiAgICAgICRzdWIuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpLmFkZENsYXNzKCdqcy1kcm9wZG93bi1hY3RpdmUnKS5wYXJlbnQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgdmFyIGNsZWFyID0gQm94LkltTm90VG91Y2hpbmdZb3UoJHN1YiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgIGlmICghY2xlYXIpIHtcbiAgICAgICAgdmFyIG9sZENsYXNzID0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnID8gJy1yaWdodCcgOiAnLWxlZnQnLFxuICAgICAgICAgICAgJHBhcmVudExpID0gJHN1Yi5wYXJlbnQoJy5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO1xuICAgICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoXCJvcGVuc1wiLmNvbmNhdChvbGRDbGFzcykpLmFkZENsYXNzKFwib3BlbnMtXCIuY29uY2F0KHRoaXMub3B0aW9ucy5hbGlnbm1lbnQpKTtcbiAgICAgICAgY2xlYXIgPSBCb3guSW1Ob3RUb3VjaGluZ1lvdSgkc3ViLCBudWxsLCB0cnVlKTtcblxuICAgICAgICBpZiAoIWNsZWFyKSB7XG4gICAgICAgICAgJHBhcmVudExpLnJlbW92ZUNsYXNzKFwib3BlbnMtXCIuY29uY2F0KHRoaXMub3B0aW9ucy5hbGlnbm1lbnQpKS5hZGRDbGFzcygnb3BlbnMtaW5uZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgICRzdWIuY3NzKCd2aXNpYmlsaXR5JywgJycpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xuICAgICAgICB0aGlzLl9hZGRCb2R5SGFuZGxlcigpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBuZXcgZHJvcGRvd24gcGFuZSBpcyB2aXNpYmxlLlxuICAgICAgICogQGV2ZW50IERyb3Bkb3dubWVudSNzaG93XG4gICAgICAgKi9cblxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYuZHJvcGRvd25tZW51JywgWyRzdWJdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgYSBzaW5nbGUsIGN1cnJlbnRseSBvcGVuIGRyb3Bkb3duIHBhbmUsIGlmIHBhc3NlZCBhIHBhcmFtZXRlciwgb3RoZXJ3aXNlLCBoaWRlcyBldmVyeXRoaW5nLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gaGlkZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSBpbmRleCBvZiB0aGUgJHRhYnMgY29sbGVjdGlvbiB0byBoaWRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCRlbGVtLCBpZHgpIHtcbiAgICAgIHZhciAkdG9DbG9zZTtcblxuICAgICAgaWYgKCRlbGVtICYmICRlbGVtLmxlbmd0aCkge1xuICAgICAgICAkdG9DbG9zZSA9ICRlbGVtO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWR4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAkdG9DbG9zZSA9IHRoaXMuJHRhYnMubm90KGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICAgIHJldHVybiBpID09PSBpZHg7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHRvQ2xvc2UgPSB0aGlzLiRlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgc29tZXRoaW5nVG9DbG9zZSA9ICR0b0Nsb3NlLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSB8fCAkdG9DbG9zZS5maW5kKCcuaXMtYWN0aXZlJykubGVuZ3RoID4gMDtcblxuICAgICAgaWYgKHNvbWV0aGluZ1RvQ2xvc2UpIHtcbiAgICAgICAgJHRvQ2xvc2UuZmluZCgnbGkuaXMtYWN0aXZlJykuYWRkKCR0b0Nsb3NlKS5hdHRyKHtcbiAgICAgICAgICAnZGF0YS1pcy1jbGljayc6IGZhbHNlXG4gICAgICAgIH0pLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAgICAgJHRvQ2xvc2UuZmluZCgndWwuanMtZHJvcGRvd24tYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmNoYW5nZWQgfHwgJHRvQ2xvc2UuZmluZCgnb3BlbnMtaW5uZXInKS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgb2xkQ2xhc3MgPSB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuYWRkKCR0b0Nsb3NlKS5yZW1vdmVDbGFzcyhcIm9wZW5zLWlubmVyIG9wZW5zLVwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuYWxpZ25tZW50KSkuYWRkQ2xhc3MoXCJvcGVucy1cIi5jb25jYXQob2xkQ2xhc3MpKTtcbiAgICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgb3BlbiBtZW51cyBhcmUgY2xvc2VkLlxuICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd25tZW51I2hpZGVcbiAgICAgICAgICovXG5cblxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYuZHJvcGRvd25tZW51JywgWyR0b0Nsb3NlXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuJG1lbnVJdGVtcy5vZmYoJy56Zi5kcm9wZG93bm1lbnUnKS5yZW1vdmVBdHRyKCdkYXRhLWlzLWNsaWNrJykucmVtb3ZlQ2xhc3MoJ2lzLXJpZ2h0LWFycm93IGlzLWxlZnQtYXJyb3cgaXMtZG93bi1hcnJvdyBvcGVucy1yaWdodCBvcGVucy1sZWZ0IG9wZW5zLWlubmVyJyk7XG4gICAgICAkKGRvY3VtZW50LmJvZHkpLm9mZignLnpmLmRyb3Bkb3dubWVudScpO1xuICAgICAgTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsICdkcm9wZG93bicpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEcm9wZG93bk1lbnU7XG59KFBsdWdpbik7XG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICovXG5cblxuRHJvcGRvd25NZW51LmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogRGlzYWxsb3dzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgc3VibWVudXNcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVIb3ZlcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93IGEgc3VibWVudSB0byBhdXRvbWF0aWNhbGx5IGNsb3NlIG9uIGEgbW91c2VsZWF2ZSBldmVudCwgaWYgbm90IGNsaWNrZWQgb3Blbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgYXV0b2Nsb3NlOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCA1MFxuICAgKi9cbiAgaG92ZXJEZWxheTogNTAsXG5cbiAgLyoqXG4gICAqIEFsbG93IGEgc3VibWVudSB0byBvcGVuL3JlbWFpbiBvcGVuIG9uIHBhcmVudCBjbGljayBldmVudC4gQWxsb3dzIGN1cnNvciB0byBtb3ZlIGF3YXkgZnJvbSBtZW51LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY2xpY2tPcGVuOiBmYWxzZSxcblxuICAvKipcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgY2xvc2luZyBhIHN1Ym1lbnUgb24gYSBtb3VzZWxlYXZlIGV2ZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDUwMFxuICAgKi9cbiAgY2xvc2luZ1RpbWU6IDUwMCxcblxuICAvKipcbiAgICogUG9zaXRpb24gb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gd2hhdCBkaXJlY3Rpb24gdGhlIHN1Ym1lbnVzIHNob3VsZCBvcGVuLiBIYW5kbGVkIGJ5IEpTLiBDYW4gYmUgYCdhdXRvJ2AsIGAnbGVmdCdgIG9yIGAncmlnaHQnYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnYXV0bydcbiAgICovXG4gIGFsaWdubWVudDogJ2F1dG8nLFxuXG4gIC8qKlxuICAgKiBBbGxvdyBjbGlja3Mgb24gdGhlIGJvZHkgdG8gY2xvc2UgYW55IG9wZW4gc3VibWVudXMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGNsb3NlT25DbGljazogdHJ1ZSxcblxuICAvKipcbiAgICogQWxsb3cgY2xpY2tzIG9uIGxlYWYgYW5jaG9yIGxpbmtzIHRvIGNsb3NlIGFueSBvcGVuIHN1Ym1lbnVzLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2tJbnNpZGU6IHRydWUsXG5cbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdmVydGljYWwgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgdmVydGljYWxgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAndmVydGljYWwnXG4gICAqL1xuICB2ZXJ0aWNhbENsYXNzOiAndmVydGljYWwnLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHJpZ2h0LXNpZGUgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgYWxpZ24tcmlnaHRgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnYWxpZ24tcmlnaHQnXG4gICAqL1xuICByaWdodENsYXNzOiAnYWxpZ24tcmlnaHQnLFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIHRvIGZvcmNlIG92ZXJpZGUgdGhlIGNsaWNraW5nIG9mIGxpbmtzIHRvIHBlcmZvcm0gZGVmYXVsdCBhY3Rpb24sIG9uIHNlY29uZCB0b3VjaCBldmVudCBmb3IgbW9iaWxlLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBmb3JjZUZvbGxvdzogdHJ1ZVxufTtcblxuLyoqXG4gKiBFcXVhbGl6ZXIgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmVxdWFsaXplclxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyIGlmIGVxdWFsaXplciBjb250YWlucyBpbWFnZXNcbiAqL1xuXG52YXIgRXF1YWxpemVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhFcXVhbGl6ZXIsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIEVxdWFsaXplcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXF1YWxpemVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRXF1YWxpemVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFcXVhbGl6ZXIsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgRXF1YWxpemVyXG4gICAgICogQGZpcmVzIEVxdWFsaXplciNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBFcXVhbGl6ZXIuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0VxdWFsaXplcic7IC8vIGllOSBiYWNrIGNvbXBhdFxuXG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBFcXVhbGl6ZXIgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IGVxdWFsaXplciBmdW5jdGlvbmluZyBvbiBsb2FkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHZhciBlcUlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLWVxdWFsaXplcicpIHx8ICcnO1xuICAgICAgdmFyICR3YXRjaGVkID0gdGhpcy4kZWxlbWVudC5maW5kKFwiW2RhdGEtZXF1YWxpemVyLXdhdGNoPVxcXCJcIi5jb25jYXQoZXFJZCwgXCJcXFwiXVwiKSk7XG5cbiAgICAgIE1lZGlhUXVlcnkuX2luaXQoKTtcblxuICAgICAgdGhpcy4kd2F0Y2hlZCA9ICR3YXRjaGVkLmxlbmd0aCA/ICR3YXRjaGVkIDogdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1lcXVhbGl6ZXItd2F0Y2hdJyk7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtcmVzaXplJywgZXFJZCB8fCBHZXRZb0RpZ2l0cyg2LCAnZXEnKSk7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtbXV0YXRlJywgZXFJZCB8fCBHZXRZb0RpZ2l0cyg2LCAnZXEnKSk7XG4gICAgICB0aGlzLmhhc05lc3RlZCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyXScpLmxlbmd0aCA+IDA7XG4gICAgICB0aGlzLmlzTmVzdGVkID0gdGhpcy4kZWxlbWVudC5wYXJlbnRzVW50aWwoZG9jdW1lbnQuYm9keSwgJ1tkYXRhLWVxdWFsaXplcl0nKS5sZW5ndGggPiAwO1xuICAgICAgdGhpcy5pc09uID0gZmFsc2U7XG4gICAgICB0aGlzLl9iaW5kSGFuZGxlciA9IHtcbiAgICAgICAgb25SZXNpemVNZUJvdW5kOiB0aGlzLl9vblJlc2l6ZU1lLmJpbmQodGhpcyksXG4gICAgICAgIG9uUG9zdEVxdWFsaXplZEJvdW5kOiB0aGlzLl9vblBvc3RFcXVhbGl6ZWQuYmluZCh0aGlzKVxuICAgICAgfTtcbiAgICAgIHZhciBpbWdzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKTtcbiAgICAgIHZhciB0b29TbWFsbDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uKSB7XG4gICAgICAgIHRvb1NtYWxsID0gdGhpcy5fY2hlY2tNUSgpO1xuICAgICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX2NoZWNrTVEuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0b29TbWFsbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9vU21hbGwgPT09IGZhbHNlIHx8IHR5cGVvZiB0b29TbWFsbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKGltZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgb25JbWFnZXNMb2FkZWQoaW1ncywgdGhpcy5fcmVmbG93LmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlZmxvdygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGlmIHRoZSBicmVha3BvaW50IGlzIHRvbyBzbWFsbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhdXNlRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXVzZUV2ZW50cygpIHtcbiAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoe1xuICAgICAgICAnLnpmLmVxdWFsaXplcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kLFxuICAgICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCxcbiAgICAgICAgJ211dGF0ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmRcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0byBoYW5kbGUgJGVsZW1lbnRzIHJlc2l6ZW1lLnpmLnRyaWdnZXIsIHdpdGggYm91bmQgdGhpcyBvbiBfYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9vblJlc2l6ZU1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlc2l6ZU1lKGUpIHtcbiAgICAgIHRoaXMuX3JlZmxvdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0byBoYW5kbGUgJGVsZW1lbnRzIHBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyLCB3aXRoIGJvdW5kIHRoaXMgb24gX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9vblBvc3RFcXVhbGl6ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUG9zdEVxdWFsaXplZChlKSB7XG4gICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMuJGVsZW1lbnRbMF0pIHtcbiAgICAgICAgdGhpcy5fcmVmbG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgRXF1YWxpemVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG5cbiAgICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XG5cbiAgICAgIGlmICh0aGlzLmhhc05lc3RlZCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplcicsIHRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQpO1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtdXRhdGVtZS56Zi50cmlnZ2VyJywgdGhpcy5fYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc09uID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgdG8gdGhlIG1pbmltdW0gcmVxdWlyZWQgc2l6ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrTVFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrTVEoKSB7XG4gICAgICB2YXIgdG9vU21hbGwgPSAhTWVkaWFRdWVyeS5pcyh0aGlzLm9wdGlvbnMuZXF1YWxpemVPbik7XG5cbiAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICBpZiAodGhpcy5pc09uKSB7XG4gICAgICAgICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcblxuICAgICAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuaXNPbikge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b29TbWFsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBub29wIHZlcnNpb24gZm9yIHRoZSBwbHVnaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2tpbGxzd2l0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2tpbGxzd2l0Y2goKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIEVxdWFsaXplciB1cG9uIERPTSBjaGFuZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlZmxvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVmbG93KCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXF1YWxpemVPblN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1N0YWNrZWQoKSkge1xuICAgICAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVxdWFsaXplQnlSb3cpIHtcbiAgICAgICAgdGhpcy5nZXRIZWlnaHRzQnlSb3codGhpcy5hcHBseUhlaWdodEJ5Um93LmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRIZWlnaHRzKHRoaXMuYXBwbHlIZWlnaHQuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGRldGVybWluZXMgaWYgdGhlIGZpcnN0IDIgZWxlbWVudHMgYXJlICpOT1QqIHN0YWNrZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pc1N0YWNrZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzU3RhY2tlZCgpIHtcbiAgICAgIGlmICghdGhpcy4kd2F0Y2hlZFswXSB8fCAhdGhpcy4kd2F0Y2hlZFsxXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuJHdhdGNoZWRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICE9PSB0aGlzLiR3YXRjaGVkWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG91dGVyIGhlaWdodHMgb2YgY2hpbGRyZW4gY29udGFpbmVkIHdpdGhpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IGFuZCByZXR1cm5zIHRoZW0gaW4gYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgbm9uLW9wdGlvbmFsIGNhbGxiYWNrIHRvIHJldHVybiB0aGUgaGVpZ2h0cyBhcnJheSB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGhlaWdodHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWlnaHRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlaWdodHMoY2IpIHtcbiAgICAgIHZhciBoZWlnaHRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLiR3YXRjaGVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuJHdhdGNoZWRbaV0uc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICBoZWlnaHRzLnB1c2godGhpcy4kd2F0Y2hlZFtpXS5vZmZzZXRIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBjYihoZWlnaHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIG91dGVyIGhlaWdodHMgb2YgY2hpbGRyZW4gY29udGFpbmVkIHdpdGhpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IGFuZCByZXR1cm5zIHRoZW0gaW4gYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgbm9uLW9wdGlvbmFsIGNhbGxiYWNrIHRvIHJldHVybiB0aGUgaGVpZ2h0cyBhcnJheSB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGdyb3VwcyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXIgZ3JvdXBlZCBieSByb3cgd2l0aCBlbGVtZW50LGhlaWdodCBhbmQgbWF4IGFzIGxhc3QgY2hpbGRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEhlaWdodHNCeVJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWlnaHRzQnlSb3coY2IpIHtcbiAgICAgIHZhciBsYXN0RWxUb3BPZmZzZXQgPSB0aGlzLiR3YXRjaGVkLmxlbmd0aCA/IHRoaXMuJHdhdGNoZWQuZmlyc3QoKS5vZmZzZXQoKS50b3AgOiAwLFxuICAgICAgICAgIGdyb3VwcyA9IFtdLFxuICAgICAgICAgIGdyb3VwID0gMDsgLy9ncm91cCBieSBSb3dcblxuICAgICAgZ3JvdXBzW2dyb3VwXSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodCA9ICdhdXRvJzsgLy9tYXliZSBjb3VsZCB1c2UgdGhpcy4kd2F0Y2hlZFtpXS5vZmZzZXRUb3BcblxuICAgICAgICB2YXIgZWxPZmZzZXRUb3AgPSAkKHRoaXMuJHdhdGNoZWRbaV0pLm9mZnNldCgpLnRvcDtcblxuICAgICAgICBpZiAoZWxPZmZzZXRUb3AgIT0gbGFzdEVsVG9wT2Zmc2V0KSB7XG4gICAgICAgICAgZ3JvdXArKztcbiAgICAgICAgICBncm91cHNbZ3JvdXBdID0gW107XG4gICAgICAgICAgbGFzdEVsVG9wT2Zmc2V0ID0gZWxPZmZzZXRUb3A7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cHNbZ3JvdXBdLnB1c2goW3RoaXMuJHdhdGNoZWRbaV0sIHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0XSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBsbiA9IGdyb3Vwcy5sZW5ndGg7IGogPCBsbjsgaisrKSB7XG4gICAgICAgIHZhciBoZWlnaHRzID0gJChncm91cHNbal0pLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbMV07XG4gICAgICAgIH0pLmdldCgpO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgaGVpZ2h0cyk7XG4gICAgICAgIGdyb3Vwc1tqXS5wdXNoKG1heCk7XG4gICAgICB9XG5cbiAgICAgIGNiKGdyb3Vwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIENTUyBoZWlnaHQgcHJvcGVydHkgb2YgZWFjaCBjaGlsZCBpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IHRvIG1hdGNoIHRoZSB0YWxsZXN0XG4gICAgICogQHBhcmFtIHthcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlIZWlnaHQoaGVpZ2h0cykge1xuICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpO1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgYXJlIGFwcGxpZWRcbiAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAgICAgKi9cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XG4gICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgbWF4KTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBoYXZlIGJlZW4gYXBwbGllZFxuICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwb3N0ZXF1YWxpemVkXG4gICAgICAgKi9cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBDU1MgaGVpZ2h0IHByb3BlcnR5IG9mIGVhY2ggY2hpbGQgaW4gYW4gRXF1YWxpemVyIHBhcmVudCB0byBtYXRjaCB0aGUgdGFsbGVzdCBieSByb3dcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBncm91cHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyIGdyb3VwZWQgYnkgcm93IHdpdGggZWxlbWVudCxoZWlnaHQgYW5kIG1heCBhcyBsYXN0IGNoaWxkXG4gICAgICogQGZpcmVzIEVxdWFsaXplciNwcmVlcXVhbGl6ZWRcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZHJvd1xuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZHJvd1xuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlIZWlnaHRCeVJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUhlaWdodEJ5Um93KGdyb3Vwcykge1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgYXJlIGFwcGxpZWRcbiAgICAgICAqL1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBncm91cHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3Vwc0lMZW5ndGggPSBncm91cHNbaV0ubGVuZ3RoLFxuICAgICAgICAgICAgbWF4ID0gZ3JvdXBzW2ldW2dyb3Vwc0lMZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoZ3JvdXBzSUxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgJChncm91cHNbaV1bMF1bMF0pLmNzcyh7XG4gICAgICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgcGVyIHJvdyBhcmUgYXBwbGllZFxuICAgICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwcmVlcXVhbGl6ZWRyb3dcbiAgICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWRyb3cuemYuZXF1YWxpemVyJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbkogPSBncm91cHNJTGVuZ3RoIC0gMTsgaiA8IGxlbko7IGorKykge1xuICAgICAgICAgICQoZ3JvdXBzW2ldW2pdWzBdKS5jc3Moe1xuICAgICAgICAgICAgJ2hlaWdodCc6IG1heFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBwZXIgcm93IGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRyb3dcbiAgICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwb3N0ZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICAgKi9cblxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Bvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIEVxdWFsaXplci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcblxuICAgICAgdGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsICdhdXRvJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVxdWFsaXplcjtcbn0oUGx1Z2luKTtcbi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gKi9cblxuXG5FcXVhbGl6ZXIuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiB3aGVuIHN0YWNrZWQgb24gc21hbGxlciBzY3JlZW5zLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZXF1YWxpemVPblN0YWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogRW5hYmxlIGhlaWdodCBlcXVhbGl6YXRpb24gcm93IGJ5IHJvdy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGVxdWFsaXplQnlSb3c6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBtaW5pbXVtIGJyZWFrcG9pbnQgc2l6ZSB0aGUgcGx1Z2luIHNob3VsZCBlcXVhbGl6ZSBoZWlnaHRzIG9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICBlcXVhbGl6ZU9uOiAnJ1xufTtcblxuLyoqXG4gKiBJbnRlcmNoYW5nZSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uaW50ZXJjaGFuZ2VcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICovXG5cbnZhciBJbnRlcmNoYW5nZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoSW50ZXJjaGFuZ2UsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIEludGVyY2hhbmdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmNoYW5nZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEludGVyY2hhbmdlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbnRlcmNoYW5nZSwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEludGVyY2hhbmdlLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIEludGVyY2hhbmdlXG4gICAgICogQGZpcmVzIEludGVyY2hhbmdlI2luaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEludGVyY2hhbmdlLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMucnVsZXMgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudFBhdGggPSAnJztcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0ludGVyY2hhbmdlJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBJbnRlcmNoYW5nZSBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgaW50ZXJjaGFuZ2UgZnVuY3Rpb25pbmcgb24gbG9hZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBNZWRpYVF1ZXJ5Ll9pbml0KCk7XG5cbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgR2V0WW9EaWdpdHMoNiwgJ2ludGVyY2hhbmdlJyk7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAnZGF0YS1yZXNpemUnOiBpZCxcbiAgICAgICAgJ2lkJzogaWRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9hZGRCcmVha3BvaW50cygpO1xuXG4gICAgICB0aGlzLl9nZW5lcmF0ZVJ1bGVzKCk7XG5cbiAgICAgIHRoaXMuX3JlZmxvdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEludGVyY2hhbmdlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKS5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5fcmVmbG93KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgSW50ZXJjaGFuZ2UgdXBvbiBET00gY2hhbmdlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZWZsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZmxvdygpIHtcbiAgICAgIHZhciBtYXRjaDsgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSwgYnV0IG9ubHkgc2F2ZSB0aGUgbGFzdCBtYXRjaFxuXG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMucnVsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucnVsZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXNbaV07XG5cbiAgICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocnVsZS5xdWVyeSkubWF0Y2hlcykge1xuICAgICAgICAgICAgbWF0Y2ggPSBydWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlKG1hdGNoLnBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBGb3VuZGF0aW9uIGJyZWFrcG9pbnRzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIEludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFUyBvYmplY3QuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRCcmVha3BvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQnJlYWtwb2ludHMoKSB7XG4gICAgICBmb3IgKHZhciBpIGluIE1lZGlhUXVlcnkucXVlcmllcykge1xuICAgICAgICBpZiAoTWVkaWFRdWVyeS5xdWVyaWVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgdmFyIHF1ZXJ5ID0gTWVkaWFRdWVyeS5xdWVyaWVzW2ldO1xuICAgICAgICAgIEludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFU1txdWVyeS5uYW1lXSA9IHF1ZXJ5LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgSW50ZXJjaGFuZ2UgZWxlbWVudCBmb3IgdGhlIHByb3ZpZGVkIG1lZGlhIHF1ZXJ5ICsgY29udGVudCBwYWlyaW5nc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRoYXQgaXMgYW4gSW50ZXJjaGFuZ2UgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHNjZW5hcmlvcyAtIEFycmF5IG9mIG9iamVjdHMgdGhhdCBoYXZlICdtcScgYW5kICdwYXRoJyBrZXlzIHdpdGggY29ycmVzcG9uZGluZyBrZXlzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVSdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVSdWxlcyhlbGVtZW50KSB7XG4gICAgICB2YXIgcnVsZXNMaXN0ID0gW107XG4gICAgICB2YXIgcnVsZXM7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucnVsZXMpIHtcbiAgICAgICAgcnVsZXMgPSB0aGlzLm9wdGlvbnMucnVsZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydWxlcyA9IHRoaXMuJGVsZW1lbnQuZGF0YSgnaW50ZXJjaGFuZ2UnKTtcbiAgICAgIH1cblxuICAgICAgcnVsZXMgPSB0eXBlb2YgcnVsZXMgPT09ICdzdHJpbmcnID8gcnVsZXMubWF0Y2goL1xcWy4qPywgLio/XFxdL2cpIDogcnVsZXM7XG5cbiAgICAgIGZvciAodmFyIGkgaW4gcnVsZXMpIHtcbiAgICAgICAgaWYgKHJ1bGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXS5zbGljZSgxLCAtMSkuc3BsaXQoJywgJyk7XG4gICAgICAgICAgdmFyIHBhdGggPSBydWxlLnNsaWNlKDAsIC0xKS5qb2luKCcnKTtcbiAgICAgICAgICB2YXIgcXVlcnkgPSBydWxlW3J1bGUubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAoSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTW3F1ZXJ5XSkge1xuICAgICAgICAgICAgcXVlcnkgPSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJ1bGVzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJ1bGVzID0gcnVsZXNMaXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGBzcmNgIHByb3BlcnR5IG9mIGFuIGltYWdlLCBvciBjaGFuZ2UgdGhlIEhUTUwgb2YgYSBjb250YWluZXIsIHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIFBhdGggdG8gdGhlIGltYWdlIG9yIEhUTUwgcGFydGlhbC5cbiAgICAgKiBAZmlyZXMgSW50ZXJjaGFuZ2UjcmVwbGFjZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZShwYXRoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCA9PT0gcGF0aCkgcmV0dXJuO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIHRyaWdnZXIgPSAncmVwbGFjZWQuemYuaW50ZXJjaGFuZ2UnOyAvLyBSZXBsYWNpbmcgaW1hZ2VzXG5cblxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0ubm9kZU5hbWUgPT09ICdJTUcnKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignc3JjJywgcGF0aCkub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuY3VycmVudFBhdGggPSBwYXRoO1xuICAgICAgICB9KS50cmlnZ2VyKHRyaWdnZXIpO1xuICAgICAgfSAvLyBSZXBsYWNpbmcgYmFja2dyb3VuZCBpbWFnZXNcbiAgICAgIGVsc2UgaWYgKHBhdGgubWF0Y2goL1xcLihnaWZ8anBnfGpwZWd8cG5nfHN2Z3x0aWZmKShbPyNdLiopPy9pKSkge1xuICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKC9nLCAnJTI4JykucmVwbGFjZSgvXFwpL2csICclMjknKTtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICd1cmwoJyArIHBhdGggKyAnKSdcbiAgICAgICAgICB9KS50cmlnZ2VyKHRyaWdnZXIpO1xuICAgICAgICB9IC8vIFJlcGxhY2luZyBIVE1MXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJC5nZXQocGF0aCwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIF90aGlzLiRlbGVtZW50Lmh0bWwocmVzcG9uc2UpLnRyaWdnZXIodHJpZ2dlcik7XG5cbiAgICAgICAgICAgICAgJChyZXNwb25zZSkuZm91bmRhdGlvbigpO1xuICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50UGF0aCA9IHBhdGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gY29udGVudCBpbiBhbiBJbnRlcmNoYW5nZSBlbGVtZW50IGlzIGRvbmUgYmVpbmcgbG9hZGVkLlxuICAgICAgICogQGV2ZW50IEludGVyY2hhbmdlI3JlcGxhY2VkXG4gICAgICAgKi9cbiAgICAgIC8vIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncmVwbGFjZWQuemYuaW50ZXJjaGFuZ2UnKTtcblxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBpbnRlcmNoYW5nZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW50ZXJjaGFuZ2U7XG59KFBsdWdpbik7XG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICovXG5cblxuSW50ZXJjaGFuZ2UuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBSdWxlcyB0byBiZSBhcHBsaWVkIHRvIEludGVyY2hhbmdlIGVsZW1lbnRzLiBTZXQgd2l0aCB0aGUgYGRhdGEtaW50ZXJjaGFuZ2VgIGFycmF5IG5vdGF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHs/YXJyYXl9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIHJ1bGVzOiBudWxsXG59O1xuSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTID0ge1xuICAnbGFuZHNjYXBlJzogJ3NjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJyxcbiAgJ3BvcnRyYWl0JzogJ3NjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxuICAncmV0aW5hJzogJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksIG9ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KSdcbn07XG5cbi8qKlxuICogU21vb3RoU2Nyb2xsIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5zbW9vdGgtc2Nyb2xsXG4gKi9cblxudmFyIFNtb290aFNjcm9sbCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoU21vb3RoU2Nyb2xsLCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBTbW9vdGhTY3JvbGwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNtb290aFNjcm9sbCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNtb290aFNjcm9sbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU21vb3RoU2Nyb2xsLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgU21vb3RoU2Nyb2xsLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFNtb290aFNjcm9sbFxuICAgICAqIEBmaXJlcyBTbW9vdGhTY3JvbGwjaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgU21vb3RoU2Nyb2xsLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdTbW9vdGhTY3JvbGwnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBTbW9vdGhTY3JvbGwgcGx1Z2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBHZXRZb0RpZ2l0cyg2LCAnc21vb3RoLXNjcm9sbCcpO1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgaWQ6IGlkXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgU21vb3RoU2Nyb2xsLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdjbGljay56Zi5zbW9vdGhTY3JvbGwnLCB0aGlzLl9oYW5kbGVMaW5rQ2xpY2spO1xuICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suemYuc21vb3RoU2Nyb2xsJywgJ2FbaHJlZl49XCIjXCJdJywgdGhpcy5faGFuZGxlTGlua0NsaWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBnaXZlbiBldmVudCB0byBzbW9vdGhseSBzY3JvbGwgdG8gdGhlIGFuY2hvciBwb2ludGVkIGJ5IHRoZSBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHsqfSBlIC0gZXZlbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUxpbmtDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTGlua0NsaWNrKGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIEZvbGxvdyB0aGUgbGluayBpZiBpdCBkb2VzIG5vdCBwb2ludCB0byBhbiBhbmNob3IuXG4gICAgICBpZiAoISQoZS5jdXJyZW50VGFyZ2V0KS5pcygnYVtocmVmXj1cIiNcIl0nKSkgcmV0dXJuO1xuICAgICAgdmFyIGFycml2YWwgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICB0aGlzLl9pblRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgU21vb3RoU2Nyb2xsLnNjcm9sbFRvTG9jKGFycml2YWwsIHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5faW5UcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBTbW9vdGhTY3JvbGwgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2NsaWNrLnpmLnNtb290aFNjcm9sbCcsIHRoaXMuX2hhbmRsZUxpbmtDbGljayk7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYuc21vb3RoU2Nyb2xsJywgJ2FbaHJlZl49XCIjXCJdJywgdGhpcy5faGFuZGxlTGlua0NsaWNrKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJzY3JvbGxUb0xvY1wiLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gc2Nyb2xsIHRvIGEgZ2l2ZW4gbG9jYXRpb24gb24gdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxvYyAtIEEgcHJvcGVybHkgZm9ybWF0dGVkIGpRdWVyeSBpZCBzZWxlY3Rvci4gRXhhbXBsZTogJyNmb28nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1c2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxUb0xvYyhsb2MpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBTbW9vdGhTY3JvbGwuZGVmYXVsdHM7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciAkbG9jID0gJChsb2MpOyAvLyBEbyBub3RoaW5nIGlmIHRhcmdldCBkb2VzIG5vdCBleGlzdCB0byBwcmV2ZW50IGVycm9yc1xuXG4gICAgICBpZiAoISRsb2MubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgc2Nyb2xsUG9zID0gTWF0aC5yb3VuZCgkbG9jLm9mZnNldCgpLnRvcCAtIG9wdGlvbnMudGhyZXNob2xkIC8gMiAtIG9wdGlvbnMub2Zmc2V0KTtcbiAgICAgICQoJ2h0bWwsIGJvZHknKS5zdG9wKHRydWUpLmFuaW1hdGUoe1xuICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbFBvc1xuICAgICAgfSwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgb3B0aW9ucy5hbmltYXRpb25FYXNpbmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbW9vdGhTY3JvbGw7XG59KFBsdWdpbik7XG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpbi5cbiAqL1xuXG5cblNtb290aFNjcm9sbC5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lLCBpbiBtcywgdGhlIGFuaW1hdGVkIHNjcm9sbGluZyBzaG91bGQgdGFrZSBiZXR3ZWVuIGxvY2F0aW9ucy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCA1MDBcbiAgICovXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG5cbiAgLyoqXG4gICAqIEFuaW1hdGlvbiBzdHlsZSB0byB1c2Ugd2hlbiBzY3JvbGxpbmcgYmV0d2VlbiBsb2NhdGlvbnMuIENhbiBiZSBgJ3N3aW5nJ2Agb3IgYCdsaW5lYXInYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnbGluZWFyJ1xuICAgKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2FuaW1hdGV8SnF1ZXJ5IGFuaW1hdGV9XG4gICAqL1xuICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIHVzZSBhcyBhIG1hcmtlciBmb3IgbG9jYXRpb24gY2hhbmdlcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCA1MFxuICAgKi9cbiAgdGhyZXNob2xkOiA1MCxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0byBvZmZzZXQgdGhlIHNjcm9sbCBvZiB0aGUgcGFnZSBvbiBpdGVtIGNsaWNrIGlmIHVzaW5nIGEgc3RpY2t5IG5hdiBiYXIuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgb2Zmc2V0OiAwXG59O1xuXG4vKipcbiAqIE1hZ2VsbGFuIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5tYWdlbGxhblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24uc21vb3RoU2Nyb2xsXG4gKi9cblxudmFyIE1hZ2VsbGFuID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhNYWdlbGxhbiwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gTWFnZWxsYW4oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hZ2VsbGFuKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTWFnZWxsYW4pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hZ2VsbGFuLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgTWFnZWxsYW4uXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgTWFnZWxsYW5cbiAgICAgKiBAZmlyZXMgTWFnZWxsYW4jaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTWFnZWxsYW4uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ01hZ2VsbGFuJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgdGhpcy5jYWxjUG9pbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNYWdlbGxhbiBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBHZXRZb0RpZ2l0cyg2LCAnbWFnZWxsYW4nKTtcblxuICAgICAgdGhpcy4kdGFyZ2V0cyA9ICQoJ1tkYXRhLW1hZ2VsbGFuLXRhcmdldF0nKTtcbiAgICAgIHRoaXMuJGxpbmtzID0gdGhpcy4kZWxlbWVudC5maW5kKCdhJyk7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAnZGF0YS1yZXNpemUnOiBpZCxcbiAgICAgICAgJ2RhdGEtc2Nyb2xsJzogaWQsXG4gICAgICAgICdpZCc6IGlkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJGFjdGl2ZSA9ICQoKTtcbiAgICAgIHRoaXMuc2Nyb2xsUG9zID0gcGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LCAxMCk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuIGFycmF5IG9mIHBpeGVsIHZhbHVlcyB0aGF0IGFyZSB0aGUgZGVtYXJjYXRpb24gbGluZXMgYmV0d2VlbiBsb2NhdGlvbnMgb24gdGhlIHBhZ2UuXG4gICAgICogQ2FuIGJlIGludm9rZWQgaWYgbmV3IGVsZW1lbnRzIGFyZSBhZGRlZCBvciB0aGUgc2l6ZSBvZiBhIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNQb2ludHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICB0aGlzLndpbkhlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgod2luZG93LmlubmVySGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCkpO1xuICAgICAgdGhpcy5kb2NIZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5Lm9mZnNldEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLm9mZnNldEhlaWdodCkpO1xuICAgICAgdGhpcy4kdGFyZ2V0cy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0YXIgPSAkKHRoaXMpLFxuICAgICAgICAgICAgcHQgPSBNYXRoLnJvdW5kKCR0YXIub2Zmc2V0KCkudG9wIC0gX3RoaXMub3B0aW9ucy50aHJlc2hvbGQpO1xuICAgICAgICAkdGFyLnRhcmdldFBvaW50ID0gcHQ7XG5cbiAgICAgICAgX3RoaXMucG9pbnRzLnB1c2gocHQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgTWFnZWxsYW4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgJGJvZHkgPSAkKCdodG1sLCBib2R5JyksXG4gICAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgZHVyYXRpb246IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogX3RoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgIH07XG5cbiAgICAgICQod2luZG93KS5vbmUoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKSB7XG4gICAgICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKGxvY2F0aW9uLmhhc2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmNhbGNQb2ludHMoKTtcblxuICAgICAgICBfdGhpcy5fdXBkYXRlQWN0aXZlKCk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLm9uTG9hZExpc3RlbmVyID0gb25Mb2FkKCQod2luZG93KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiBfdGhpcy5yZWZsb3cuYmluZChfdGhpcyksXG4gICAgICAgICAgJ3Njcm9sbG1lLnpmLnRyaWdnZXInOiBfdGhpcy5fdXBkYXRlQWN0aXZlLmJpbmQoX3RoaXMpXG4gICAgICAgIH0pLm9uKCdjbGljay56Zi5tYWdlbGxhbicsICdhW2hyZWZePVwiI1wiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciBhcnJpdmFsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKGFycml2YWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWVwTGlua1Njcm9sbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKSB7XG4gICAgICAgICAgX3RoaXMuc2Nyb2xsVG9Mb2Mod2luZG93LmxvY2F0aW9uLmhhc2gpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLl9kZWVwTGlua1Njcm9sbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHNjcm9sbCB0byBhIGdpdmVuIGxvY2F0aW9uIG9uIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2MgLSBhIHByb3Blcmx5IGZvcm1hdHRlZCBqUXVlcnkgaWQgc2VsZWN0b3IuIEV4YW1wbGU6ICcjZm9vJ1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2Nyb2xsVG9Mb2NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsVG9Mb2MobG9jKSB7XG4gICAgICB0aGlzLl9pblRyYW5zaXRpb24gPSB0cnVlO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICB0aHJlc2hvbGQ6IHRoaXMub3B0aW9ucy50aHJlc2hvbGQsXG4gICAgICAgIG9mZnNldDogdGhpcy5vcHRpb25zLm9mZnNldFxuICAgICAgfTtcbiAgICAgIFNtb290aFNjcm9sbC5zY3JvbGxUb0xvYyhsb2MsIG9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2luVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIE1hZ2VsbGFuIHVwb24gRE9NIGNoYW5nZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZmxvdygpIHtcbiAgICAgIHRoaXMuY2FsY1BvaW50cygpO1xuXG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmlzaWJpbGl0eSBvZiBhbiBhY3RpdmUgbG9jYXRpb24gbGluaywgYW5kIHVwZGF0ZXMgdGhlIHVybCBoYXNoIGZvciB0aGUgcGFnZSwgaWYgZGVlcExpbmtpbmcgZW5hYmxlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBNYWdlbGxhbiN1cGRhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVBY3RpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUFjdGl2ZSgpXG4gICAgLypldnQsIGVsZW0sIHNjcm9sbFBvcyovXG4gICAge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pblRyYW5zaXRpb24pIHJldHVybjtcbiAgICAgIHZhciBuZXdTY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsIDEwKTtcbiAgICAgIHZhciBpc1Njcm9sbGluZ1VwID0gdGhpcy5zY3JvbGxQb3MgPiBuZXdTY3JvbGxQb3M7XG4gICAgICB0aGlzLnNjcm9sbFBvcyA9IG5ld1Njcm9sbFBvcztcbiAgICAgIHZhciBhY3RpdmVJZHg7IC8vIEJlZm9yZSB0aGUgZmlyc3QgcG9pbnQ6IG5vIGxpbmtcblxuICAgICAgaWYgKG5ld1Njcm9sbFBvcyA8IHRoaXMucG9pbnRzWzBdKSA7XG4gICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgICAvLyBBdCB0aGUgYm90dG9tIG9mIHRoZSBwYWdlOiBsYXN0IGxpbmtcbiAgICAgIGVsc2UgaWYgKG5ld1Njcm9sbFBvcyArIHRoaXMud2luSGVpZ2h0ID09PSB0aGlzLmRvY0hlaWdodCkge1xuICAgICAgICAgIGFjdGl2ZUlkeCA9IHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gLy8gT3RoZXJ3aGlzZSwgdXNlIHRoZSBsYXN0IHZpc2libGUgbGlua1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlTGlua3MgPSB0aGlzLnBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHAgLSBfdGhpczIub3B0aW9ucy5vZmZzZXQgLSAoaXNTY3JvbGxpbmdVcCA/IF90aGlzMi5vcHRpb25zLnRocmVzaG9sZCA6IDApIDw9IG5ld1Njcm9sbFBvcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWN0aXZlSWR4ID0gdmlzaWJsZUxpbmtzLmxlbmd0aCA/IHZpc2libGVMaW5rcy5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICB9IC8vIEdldCB0aGUgbmV3IGFjdGl2ZSBsaW5rXG5cblxuICAgICAgdmFyICRvbGRBY3RpdmUgPSB0aGlzLiRhY3RpdmU7XG4gICAgICB2YXIgYWN0aXZlSGFzaCA9ICcnO1xuXG4gICAgICBpZiAodHlwZW9mIGFjdGl2ZUlkeCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy4kYWN0aXZlID0gdGhpcy4kbGlua3MuZmlsdGVyKCdbaHJlZj1cIiMnICsgdGhpcy4kdGFyZ2V0cy5lcShhY3RpdmVJZHgpLmRhdGEoJ21hZ2VsbGFuLXRhcmdldCcpICsgJ1wiXScpO1xuICAgICAgICBpZiAodGhpcy4kYWN0aXZlLmxlbmd0aCkgYWN0aXZlSGFzaCA9IHRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGFjdGl2ZSA9ICQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzTmV3QWN0aXZlID0gISghdGhpcy4kYWN0aXZlLmxlbmd0aCAmJiAhJG9sZEFjdGl2ZS5sZW5ndGgpICYmICF0aGlzLiRhY3RpdmUuaXMoJG9sZEFjdGl2ZSk7XG4gICAgICB2YXIgaXNOZXdIYXNoID0gYWN0aXZlSGFzaCAhPT0gd2luZG93LmxvY2F0aW9uLmhhc2g7IC8vIFVwZGF0ZSB0aGUgYWN0aXZlIGxpbmsgZWxlbWVudFxuXG4gICAgICBpZiAoaXNOZXdBY3RpdmUpIHtcbiAgICAgICAgJG9sZEFjdGl2ZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICB0aGlzLiRhY3RpdmUuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcbiAgICAgIH0gLy8gVXBkYXRlIHRoZSBoYXNoIChpdCBtYXkgaGF2ZSBjaGFuZ2VkIHdpdGggdGhlIHNhbWUgYWN0aXZlIGxpbmspXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGlua2luZyAmJiBpc05ld0hhc2gpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSkge1xuICAgICAgICAgIC8vIFNldCBvciByZW1vdmUgdGhlIGhhc2ggKHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyOTg2ODQvNDMxNzM4NFxuICAgICAgICAgIHZhciB1cmwgPSBhY3RpdmVIYXNoID8gYWN0aXZlSGFzaCA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIHVybCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBhY3RpdmVIYXNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05ld0FjdGl2ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBtYWdlbGxhbiBpcyBmaW5pc2hlZCB1cGRhdGluZyB0byB0aGUgbmV3IGFjdGl2ZSBlbGVtZW50LlxuICAgICAgICAgKiBAZXZlbnQgTWFnZWxsYW4jdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3VwZGF0ZS56Zi5tYWdlbGxhbicsIFt0aGlzLiRhY3RpdmVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgTWFnZWxsYW4gYW5kIHJlc2V0cyB0aGUgdXJsIG9mIHRoZSB3aW5kb3cuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYubWFnZWxsYW4nKS5maW5kKFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKSB7XG4gICAgICAgIHZhciBoYXNoID0gdGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaC5yZXBsYWNlKGhhc2gsICcnKTtcbiAgICAgIH1cblxuICAgICAgJCh3aW5kb3cpLm9mZignaGFzaGNoYW5nZScsIHRoaXMuX2RlZXBMaW5rU2Nyb2xsKTtcbiAgICAgIGlmICh0aGlzLm9uTG9hZExpc3RlbmVyKSAkKHdpbmRvdykub2ZmKHRoaXMub25Mb2FkTGlzdGVuZXIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYWdlbGxhbjtcbn0oUGx1Z2luKTtcbi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gKi9cblxuXG5NYWdlbGxhbi5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lLCBpbiBtcywgdGhlIGFuaW1hdGVkIHNjcm9sbGluZyBzaG91bGQgdGFrZSBiZXR3ZWVuIGxvY2F0aW9ucy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCA1MDBcbiAgICovXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG5cbiAgLyoqXG4gICAqIEFuaW1hdGlvbiBzdHlsZSB0byB1c2Ugd2hlbiBzY3JvbGxpbmcgYmV0d2VlbiBsb2NhdGlvbnMuIENhbiBiZSBgJ3N3aW5nJ2Agb3IgYCdsaW5lYXInYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnbGluZWFyJ1xuICAgKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2FuaW1hdGV8SnF1ZXJ5IGFuaW1hdGV9XG4gICAqL1xuICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIHVzZSBhcyBhIG1hcmtlciBmb3IgbG9jYXRpb24gY2hhbmdlcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCA1MFxuICAgKi9cbiAgdGhyZXNob2xkOiA1MCxcblxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYWN0aXZlIGxvY2F0aW9ucyBsaW5rIG9uIHRoZSBtYWdlbGxhbiBjb250YWluZXIuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2lzLWFjdGl2ZSdcbiAgICovXG4gIGFjdGl2ZUNsYXNzOiAnaXMtYWN0aXZlJyxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSBzY3JpcHQgdG8gbWFuaXB1bGF0ZSB0aGUgdXJsIG9mIHRoZSBjdXJyZW50IHBhZ2UsIGFuZCBpZiBzdXBwb3J0ZWQsIGFsdGVyIHRoZSBoaXN0b3J5LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGVlcExpbmtpbmc6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIG9mZnNldCB0aGUgc2Nyb2xsIG9mIHRoZSBwYWdlIG9uIGl0ZW0gY2xpY2sgaWYgdXNpbmcgYSBzdGlja3kgbmF2IGJhci5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBvZmZzZXQ6IDBcbn07XG5cbi8qKlxuICogT2ZmQ2FudmFzIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5vZmZjYW52YXNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICovXG5cbnZhciBPZmZDYW52YXMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKE9mZkNhbnZhcywgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gT2ZmQ2FudmFzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPZmZDYW52YXMpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihPZmZDYW52YXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9mZkNhbnZhcywgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIG9mZi1jYW52YXMgd3JhcHBlci5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBPZmZDYW52YXNcbiAgICAgKiBAZmlyZXMgT2ZmQ2FudmFzI2luaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gaW5pdGlhbGl6ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnT2ZmQ2FudmFzJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIE9mZkNhbnZhcy5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jb250ZW50Q2xhc3NlcyA9IHtcbiAgICAgICAgYmFzZTogW10sXG4gICAgICAgIHJldmVhbDogW11cbiAgICAgIH07XG4gICAgICB0aGlzLiRsYXN0VHJpZ2dlciA9ICQoKTtcbiAgICAgIHRoaXMuJHRyaWdnZXJzID0gJCgpO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9ICdsZWZ0JztcbiAgICAgIHRoaXMuJGNvbnRlbnQgPSAkKCk7XG4gICAgICB0aGlzLm5lc3RlZCA9ICEhdGhpcy5vcHRpb25zLm5lc3RlZDsgLy8gRGVmaW5lcyB0aGUgQ1NTIHRyYW5zaXRpb24vcG9zaXRpb24gY2xhc3NlcyBvZiB0aGUgb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lci5cblxuICAgICAgJChbJ3B1c2gnLCAnb3ZlcmxhcCddKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XG4gICAgICAgIF90aGlzMi5jb250ZW50Q2xhc3Nlcy5iYXNlLnB1c2goJ2hhcy10cmFuc2l0aW9uLScgKyB2YWwpO1xuICAgICAgfSk7XG4gICAgICAkKFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10pLmVhY2goZnVuY3Rpb24gKGluZGV4LCB2YWwpIHtcbiAgICAgICAgX3RoaXMyLmNvbnRlbnRDbGFzc2VzLmJhc2UucHVzaCgnaGFzLXBvc2l0aW9uLScgKyB2YWwpO1xuXG4gICAgICAgIF90aGlzMi5jb250ZW50Q2xhc3Nlcy5yZXZlYWwucHVzaCgnaGFzLXJldmVhbC0nICsgdmFsKTtcbiAgICAgIH0pOyAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcblxuICAgICAgVHJpZ2dlcnMuaW5pdCgkKTtcblxuICAgICAgTWVkaWFRdWVyeS5faW5pdCgpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgICBLZXlib2FyZC5yZWdpc3RlcignT2ZmQ2FudmFzJywge1xuICAgICAgICAnRVNDQVBFJzogJ2Nsb3NlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBvZmYtY2FudmFzIHdyYXBwZXIgYnkgYWRkaW5nIHRoZSBleGl0IG92ZXJsYXkgKGlmIG5lZWRlZCkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7IC8vIEZpbmQgb2ZmLWNhbnZhcyBjb250ZW50LCBlaXRoZXIgYnkgSUQgKGlmIHNwZWNpZmllZCksIGJ5IHNpYmxpbmdzIG9yIGJ5IGNsb3Nlc3Qgc2VsZWN0b3IgKGZhbGxiYWNrKVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRJZCkge1xuICAgICAgICB0aGlzLiRjb250ZW50ID0gJCgnIycgKyB0aGlzLm9wdGlvbnMuY29udGVudElkKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiRjb250ZW50ID0gdGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmZpcnN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRjb250ZW50ID0gdGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykuZmlyc3QoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29udGVudElkKSB7XG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBvZmYtY2FudmFzIGVsZW1lbnQgaXMgbmVzdGVkIGlmIGl0IGlzbid0IGEgc2libGluZyBvZiB0aGUgY29udGVudFxuICAgICAgICB0aGlzLm5lc3RlZCA9IHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5sZW5ndGggPT09IDA7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50SWQgJiYgdGhpcy5vcHRpb25zLm5lc3RlZCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXYXJuaW5nIGlmIHVzaW5nIGNvbnRlbnQgSUQgd2l0aG91dCBzZXR0aW5nIHRoZSBuZXN0ZWQgb3B0aW9uXG4gICAgICAgIC8vIE9uY2UgdGhlIGVsZW1lbnQgaXMgbmVzdGVkIGl0IGlzIHJlcXVpcmVkIHRvIHdvcmsgcHJvcGVybHkgaW4gdGhpcyBjYXNlXG4gICAgICAgIGNvbnNvbGUud2FybignUmVtZW1iZXIgdG8gdXNlIHRoZSBuZXN0ZWQgb3B0aW9uIGlmIHVzaW5nIHRoZSBjb250ZW50IElEIG9wdGlvbiEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubmVzdGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIEZvcmNlIHRyYW5zaXRpb24gb3ZlcmxhcCBpZiBuZXN0ZWRcbiAgICAgICAgdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gPSAnb3ZlcmxhcCc7IC8vIFJlbW92ZSBhcHByb3ByaWF0ZSBjbGFzc2VzIGlmIGFscmVhZHkgYXNzaWduZWQgaW4gbWFya3VwXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtdHJhbnNpdGlvbi1wdXNoJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXCJpcy10cmFuc2l0aW9uLVwiLmNvbmNhdCh0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiwgXCIgaXMtY2xvc2VkXCIpKTsgLy8gRmluZCB0cmlnZ2VycyB0aGF0IGFmZmVjdCB0aGlzIGVsZW1lbnQgYW5kIGFkZCBhcmlhLWV4cGFuZGVkIHRvIHRoZW1cblxuICAgICAgdGhpcy4kdHJpZ2dlcnMgPSAkKGRvY3VtZW50KS5maW5kKCdbZGF0YS1vcGVuPVwiJyArIGlkICsgJ1wiXSwgW2RhdGEtY2xvc2U9XCInICsgaWQgKyAnXCJdLCBbZGF0YS10b2dnbGU9XCInICsgaWQgKyAnXCJdJykuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBpZCk7IC8vIEdldCBwb3NpdGlvbiBieSBjaGVja2luZyBmb3IgcmVsYXRlZCBDU1MgY2xhc3NcblxuICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMuJGVsZW1lbnQuaXMoJy5wb3NpdGlvbi1sZWZ0LCAucG9zaXRpb24tdG9wLCAucG9zaXRpb24tcmlnaHQsIC5wb3NpdGlvbi1ib3R0b20nKSA/IHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnKS5tYXRjaCgvcG9zaXRpb25cXC0obGVmdHx0b3B8cmlnaHR8Ym90dG9tKS8pWzFdIDogdGhpcy5wb3NpdGlvbjsgLy8gQWRkIGFuIG92ZXJsYXkgb3ZlciB0aGUgY29udGVudCBpZiBuZWNlc3NhcnlcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB2YXIgb3ZlcmxheVBvc2l0aW9uID0gJCh0aGlzLiRlbGVtZW50KS5jc3MoXCJwb3NpdGlvblwiKSA9PT0gJ2ZpeGVkJyA/ICdpcy1vdmVybGF5LWZpeGVkJyA6ICdpcy1vdmVybGF5LWFic29sdXRlJztcbiAgICAgICAgb3ZlcmxheS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2pzLW9mZi1jYW52YXMtb3ZlcmxheSAnICsgb3ZlcmxheVBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy4kb3ZlcmxheSA9ICQob3ZlcmxheSk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXlQb3NpdGlvbiA9PT0gJ2lzLW92ZXJsYXktZml4ZWQnKSB7XG4gICAgICAgICAgJCh0aGlzLiRvdmVybGF5KS5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRjb250ZW50LmFwcGVuZCh0aGlzLiRvdmVybGF5KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBHZXQgdGhlIHJldmVhbE9uIG9wdGlvbiBmcm9tIHRoZSBjbGFzcy5cblxuXG4gICAgICB2YXIgcmV2ZWFsT25SZWdFeHAgPSBuZXcgUmVnRXhwKFJlZ0V4cEVzY2FwZSh0aGlzLm9wdGlvbnMucmV2ZWFsQ2xhc3MpICsgJyhbXlxcXFxzXSspJywgJ2cnKTtcbiAgICAgIHZhciByZXZlYWxPbkNsYXNzID0gcmV2ZWFsT25SZWdFeHAuZXhlYyh0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZSk7XG5cbiAgICAgIGlmIChyZXZlYWxPbkNsYXNzKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5pc1JldmVhbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnJldmVhbE9uID0gdGhpcy5vcHRpb25zLnJldmVhbE9uIHx8IHJldmVhbE9uQ2xhc3NbMV07XG4gICAgICB9IC8vIEVuc3VyZSB0aGUgYHJldmVhbC1vbi0qYCBjbGFzcyBpcyBzZXQuXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc1JldmVhbGVkID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5yZXZlYWxPbikge1xuICAgICAgICB0aGlzLiRlbGVtZW50LmZpcnN0KCkuYWRkQ2xhc3MoXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLnJldmVhbENsYXNzKS5jb25jYXQodGhpcy5vcHRpb25zLnJldmVhbE9uKSk7XG5cbiAgICAgICAgdGhpcy5fc2V0TVFDaGVja2VyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCB0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUpO1xuICAgICAgfSAvLyBJbml0YWxseSByZW1vdmUgYWxsIHRyYW5zaXRpb24vcG9zaXRpb24gQ1NTIGNsYXNzZXMgZnJvbSBvZmYtY2FudmFzIGNvbnRlbnQgY29udGFpbmVyLlxuXG5cbiAgICAgIHRoaXMuX3JlbW92ZUNvbnRlbnRDbGFzc2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIG9mZi1jYW52YXMgd3JhcHBlciBhbmQgdGhlIGV4aXQgb3ZlcmxheS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXMnKS5vbih7XG4gICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcbiAgICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksXG4gICAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXG4gICAgICAgICdrZXlkb3duLnpmLm9mZmNhbnZhcyc6IHRoaXMuX2hhbmRsZUtleWJvYXJkLmJpbmQodGhpcylcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgJHRhcmdldCA9IHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA/IHRoaXMuJG92ZXJsYXkgOiB0aGlzLiRjb250ZW50O1xuICAgICAgICAkdGFyZ2V0Lm9uKHtcbiAgICAgICAgICAnY2xpY2suemYub2ZmY2FudmFzJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGV2ZW50IGxpc3RlbmVyIGZvciBlbGVtZW50cyB0aGF0IHdpbGwgcmV2ZWFsIGF0IGNlcnRhaW4gYnJlYWtwb2ludHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRNUUNoZWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldE1RQ2hlY2tlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMub25Mb2FkTGlzdGVuZXIgPSBvbkxvYWQoJCh3aW5kb3cpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChNZWRpYVF1ZXJ5LmF0TGVhc3QoX3RoaXMub3B0aW9ucy5yZXZlYWxPbikpIHtcbiAgICAgICAgICBfdGhpcy5yZXZlYWwodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChNZWRpYVF1ZXJ5LmF0TGVhc3QoX3RoaXMub3B0aW9ucy5yZXZlYWxPbikpIHtcbiAgICAgICAgICBfdGhpcy5yZXZlYWwodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMucmV2ZWFsKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIENTUyB0cmFuc2l0aW9uL3Bvc2l0aW9uIGNsYXNzZXMgb2YgdGhlIG9mZi1jYW52YXMgY29udGVudCBjb250YWluZXIuXG4gICAgICogUmVtb3ZpbmcgdGhlIGNsYXNzZXMgaXMgaW1wb3J0YW50IHdoZW4gYW5vdGhlciBvZmYtY2FudmFzIGdldHMgb3BlbmVkIHRoYXQgdXNlcyB0aGUgc2FtZSBjb250ZW50IGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGhhc1JldmVhbCAtIHRydWUgaWYgcmVsYXRlZCBvZmYtY2FudmFzIGVsZW1lbnQgaXMgcmV2ZWFsZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVDb250ZW50Q2xhc3Nlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlQ29udGVudENsYXNzZXMoaGFzUmV2ZWFsKSB7XG4gICAgICBpZiAodHlwZW9mIGhhc1JldmVhbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQucmVtb3ZlQ2xhc3ModGhpcy5jb250ZW50Q2xhc3Nlcy5iYXNlLmpvaW4oJyAnKSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1JldmVhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy4kY29udGVudC5yZW1vdmVDbGFzcyhcImhhcy1yZXZlYWwtXCIuY29uY2F0KHRoaXMucG9zaXRpb24pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgQ1NTIHRyYW5zaXRpb24vcG9zaXRpb24gY2xhc3NlcyBvZiB0aGUgb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lciwgYmFzZWQgb24gdGhlIG9wZW5pbmcgb2ZmLWNhbnZhcyBlbGVtZW50LlxuICAgICAqIEJlZm9yZWhhbmQgYW55IHRyYW5zaXRpb24vcG9zaXRpb24gY2xhc3MgZ2V0cyByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzUmV2ZWFsIC0gdHJ1ZSBpZiByZWxhdGVkIG9mZi1jYW52YXMgZWxlbWVudCBpcyByZXZlYWxlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZENvbnRlbnRDbGFzc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDb250ZW50Q2xhc3NlcyhoYXNSZXZlYWwpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUNvbnRlbnRDbGFzc2VzKGhhc1JldmVhbCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaGFzUmV2ZWFsICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy4kY29udGVudC5hZGRDbGFzcyhcImhhcy10cmFuc2l0aW9uLVwiLmNvbmNhdCh0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiwgXCIgaGFzLXBvc2l0aW9uLVwiKS5jb25jYXQodGhpcy5wb3NpdGlvbikpO1xuICAgICAgfSBlbHNlIGlmIChoYXNSZXZlYWwgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kY29udGVudC5hZGRDbGFzcyhcImhhcy1yZXZlYWwtXCIuY29uY2F0KHRoaXMucG9zaXRpb24pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgcmV2ZWFsaW5nL2hpZGluZyB0aGUgb2ZmLWNhbnZhcyBhdCBicmVha3BvaW50cywgbm90IHRoZSBzYW1lIGFzIG9wZW4uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1JldmVhbGVkIC0gdHJ1ZSBpZiBlbGVtZW50IHNob3VsZCBiZSByZXZlYWxlZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJldmVhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlYWwoaXNSZXZlYWxlZCkge1xuICAgICAgaWYgKGlzUmV2ZWFsZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLmlzUmV2ZWFsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXInKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtY2xvc2VkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzUmV2ZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXInKS5vbih7XG4gICAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLWNsb3NlZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hZGRDb250ZW50Q2xhc3Nlcyhpc1JldmVhbGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgc2Nyb2xsaW5nIG9mIHRoZSBib2R5IHdoZW4gb2ZmY2FudmFzIGlzIG9wZW4gb24gbW9iaWxlIFNhZmFyaSBhbmQgb3RoZXIgdHJvdWJsZXNvbWUgYnJvd3NlcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdG9wU2Nyb2xsaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wU2Nyb2xsaW5nKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBUYWtlbiBhbmQgYWRhcHRlZCBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY4ODk0NDcvcHJldmVudC1mdWxsLXBhZ2Utc2Nyb2xsaW5nLWlvc1xuICAgIC8vIE9ubHkgcmVhbGx5IHdvcmtzIGZvciB5LCBub3Qgc3VyZSBob3cgdG8gZXh0ZW5kIHRvIHggb3IgaWYgd2UgbmVlZCB0by5cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZWNvcmRTY3JvbGxhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWNvcmRTY3JvbGxhYmxlKGV2ZW50KSB7XG4gICAgICB2YXIgZWxlbSA9IHRoaXM7IC8vIGNhbGxlZCBmcm9tIGV2ZW50IGhhbmRsZXIgY29udGV4dCB3aXRoIHRoaXMgYXMgZWxlbVxuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgc2Nyb2xsYWJsZSAoY29udGVudCBvdmVyZmxvd3MpLCB0aGVuLi4uXG5cbiAgICAgIGlmIChlbGVtLnNjcm9sbEhlaWdodCAhPT0gZWxlbS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIHRvcCwgc2Nyb2xsIGRvd24gb25lIHBpeGVsIHRvIGFsbG93IHNjcm9sbGluZyB1cFxuICAgICAgICBpZiAoZWxlbS5zY3JvbGxUb3AgPT09IDApIHtcbiAgICAgICAgICBlbGVtLnNjcm9sbFRvcCA9IDE7XG4gICAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIGJvdHRvbSwgc2Nyb2xsIHVwIG9uZSBwaXhlbCB0byBhbGxvdyBzY3JvbGxpbmcgZG93blxuXG5cbiAgICAgICAgaWYgKGVsZW0uc2Nyb2xsVG9wID09PSBlbGVtLnNjcm9sbEhlaWdodCAtIGVsZW0uY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgZWxlbS5zY3JvbGxUb3AgPSBlbGVtLnNjcm9sbEhlaWdodCAtIGVsZW0uY2xpZW50SGVpZ2h0IC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGVtLmFsbG93VXAgPSBlbGVtLnNjcm9sbFRvcCA+IDA7XG4gICAgICBlbGVtLmFsbG93RG93biA9IGVsZW0uc2Nyb2xsVG9wIDwgZWxlbS5zY3JvbGxIZWlnaHQgLSBlbGVtLmNsaWVudEhlaWdodDtcbiAgICAgIGVsZW0ubGFzdFkgPSBldmVudC5vcmlnaW5hbEV2ZW50LnBhZ2VZO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc3RvcFNjcm9sbFByb3BhZ2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wU2Nyb2xsUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgICAgIHZhciBlbGVtID0gdGhpczsgLy8gY2FsbGVkIGZyb20gZXZlbnQgaGFuZGxlciBjb250ZXh0IHdpdGggdGhpcyBhcyBlbGVtXG5cbiAgICAgIHZhciB1cCA9IGV2ZW50LnBhZ2VZIDwgZWxlbS5sYXN0WTtcbiAgICAgIHZhciBkb3duID0gIXVwO1xuICAgICAgZWxlbS5sYXN0WSA9IGV2ZW50LnBhZ2VZO1xuXG4gICAgICBpZiAodXAgJiYgZWxlbS5hbGxvd1VwIHx8IGRvd24gJiYgZWxlbS5hbGxvd0Rvd24pIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgb2ZmLWNhbnZhcyBtZW51LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gdHJpZ2dlciAtIGVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIG9mZi1jYW52YXMgdG8gb3Blbi5cbiAgICAgKiBAZmlyZXMgT2ZmY2FudmFzI29wZW5lZFxuICAgICAqIEB0b2RvIGFsc28gdHJpZ2dlciAnb3BlbicgZXZlbnQ/XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oZXZlbnQsIHRyaWdnZXIpIHtcbiAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykgfHwgdGhpcy5pc1JldmVhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlVG8gPT09ICd0b3AnKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmNlVG8gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUgJiYgdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gIT09ICdvdmVybGFwJykge1xuICAgICAgICB0aGlzLiRlbGVtZW50LnNpYmxpbmdzKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykuY3NzKCd0cmFuc2l0aW9uLWR1cmF0aW9uJywgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLW9wZW4nKS5yZW1vdmVDbGFzcygnaXMtY2xvc2VkJyk7XG4gICAgICB0aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcbiAgICAgIHRoaXMuJGNvbnRlbnQuYWRkQ2xhc3MoJ2lzLW9wZW4tJyArIHRoaXMucG9zaXRpb24pOyAvLyBJZiBgY29udGVudFNjcm9sbGAgaXMgc2V0IHRvIGZhbHNlLCBhZGQgY2xhc3MgYW5kIGRpc2FibGUgc2Nyb2xsaW5nIG9uIHRvdWNoIGRldmljZXMuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudFNjcm9sbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgJCgnYm9keScpLmFkZENsYXNzKCdpcy1vZmYtY2FudmFzLW9wZW4nKS5vbigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbGluZyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RvdWNoc3RhcnQnLCB0aGlzLl9yZWNvcmRTY3JvbGxhYmxlKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbFByb3BhZ2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdpcy12aXNpYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdpcy1jbG9zYWJsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Gb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uZSh0cmFuc2l0aW9uZW5kKHRoaXMuJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFfdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGV4aXQgaWYgcHJlbWF0dXJlbHkgY2xvc2VkXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNhbnZhc0ZvY3VzID0gX3RoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtYXV0b2ZvY3VzXScpO1xuXG4gICAgICAgICAgaWYgKGNhbnZhc0ZvY3VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FudmFzRm9jdXMuZXEoMCkuZm9jdXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZmluZCgnYSwgYnV0dG9uJykuZXEoMCkuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRyYXBGb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRjb250ZW50LmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgIEtleWJvYXJkLnRyYXBGb2N1cyh0aGlzLiRlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkQ29udGVudENsYXNzZXMoKTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW5zLlxuICAgICAgICogQGV2ZW50IE9mZmNhbnZhcyNvcGVuZWRcbiAgICAgICAqL1xuXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb3BlbmVkLnpmLm9mZmNhbnZhcycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG9mZi1jYW52YXMgbWVudS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNiIHRvIGZpcmUgYWZ0ZXIgY2xvc3VyZS5cbiAgICAgKiBAZmlyZXMgT2ZmY2FudmFzI2Nsb3NlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoY2IpIHtcbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpIHx8IHRoaXMuaXNSZXZlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cbiAgICAgICAqIEBldmVudCBPZmZjYW52YXMjY2xvc2VkXG4gICAgICAgKi9cbiAgICAgIC50cmlnZ2VyKCdjbG9zZWQuemYub2ZmY2FudmFzJyk7XG4gICAgICB0aGlzLiRjb250ZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuLWxlZnQgaXMtb3Blbi10b3AgaXMtb3Blbi1yaWdodCBpcy1vcGVuLWJvdHRvbScpOyAvLyBJZiBgY29udGVudFNjcm9sbGAgaXMgc2V0IHRvIGZhbHNlLCByZW1vdmUgY2xhc3MgYW5kIHJlLWVuYWJsZSBzY3JvbGxpbmcgb24gdG91Y2ggZGV2aWNlcy5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50U2Nyb2xsID09PSBmYWxzZSkge1xuICAgICAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbicpLm9mZigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbGluZyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCd0b3VjaHN0YXJ0JywgdGhpcy5fcmVjb3JkU2Nyb2xsYWJsZSk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCd0b3VjaG1vdmUnLCB0aGlzLl9zdG9wU2Nyb2xsUHJvcGFnYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkucmVtb3ZlQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkucmVtb3ZlQ2xhc3MoJ2lzLWNsb3NhYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJHRyaWdnZXJzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kY29udGVudC5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuICAgICAgICBLZXlib2FyZC5yZWxlYXNlRm9jdXModGhpcy4kZWxlbWVudCk7XG4gICAgICB9IC8vIExpc3RlbiB0byB0cmFuc2l0aW9uRW5kIGFuZCBhZGQgY2xhc3Mgd2hlbiBkb25lLlxuXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub25lKHRyYW5zaXRpb25lbmQodGhpcy4kZWxlbWVudCksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy1jbG9zZWQnKTtcblxuICAgICAgICBfdGhpcy5fcmVtb3ZlQ29udGVudENsYXNzZXMoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBvZmYtY2FudmFzIG1lbnUgb3BlbiBvciBjbG9zZWQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgb2JqZWN0IHBhc3NlZCBmcm9tIGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShldmVudCwgdHJpZ2dlcikge1xuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xuICAgICAgICB0aGlzLmNsb3NlKGV2ZW50LCB0cmlnZ2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3BlbihldmVudCwgdHJpZ2dlcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMga2V5Ym9hcmQgaW5wdXQgd2hlbiBkZXRlY3RlZC4gV2hlbiB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkLCB0aGUgb2ZmLWNhbnZhcyBtZW51IGNsb3NlcywgYW5kIGZvY3VzIGlzIHJlc3RvcmVkIHRvIHRoZSBlbGVtZW50IHRoYXQgb3BlbmVkIHRoZSBtZW51LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlS2V5Ym9hcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUtleWJvYXJkKGUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBLZXlib2FyZC5oYW5kbGVLZXkoZSwgJ09mZkNhbnZhcycsIHtcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgIF90aGlzMy5jbG9zZSgpO1xuXG4gICAgICAgICAgX3RoaXMzLiRsYXN0VHJpZ2dlci5mb2N1cygpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQoKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgb2ZmY2FudmFzIHBsdWdpbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXMnKTtcbiAgICAgIHRoaXMuJG92ZXJsYXkub2ZmKCcuemYub2ZmY2FudmFzJyk7XG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikgJCh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2ZmQ2FudmFzO1xufShQbHVnaW4pO1xuXG5PZmZDYW52YXMuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgdXNlciB0byBjbGljayBvdXRzaWRlIG9mIHRoZSBtZW51IHRvIGNsb3NlIGl0LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2s6IHRydWUsXG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gb3ZlcmxheSBvbiB0b3Agb2YgYFtkYXRhLW9mZi1jYW52YXMtY29udGVudF1gLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBjb250ZW50T3ZlcmxheTogdHJ1ZSxcblxuICAvKipcbiAgICogVGFyZ2V0IGFuIG9mZi1jYW52YXMgY29udGVudCBjb250YWluZXIgYnkgSUQgdGhhdCBtYXkgYmUgcGxhY2VkIGFueXdoZXJlLiBJZiBudWxsIHRoZSBjbG9zZXN0IGNvbnRlbnQgY29udGFpbmVyIHdpbGwgYmUgdGFrZW4uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGNvbnRlbnRJZDogbnVsbCxcblxuICAvKipcbiAgICogRGVmaW5lIHRoZSBvZmYtY2FudmFzIGVsZW1lbnQgaXMgbmVzdGVkIGluIGFuIG9mZi1jYW52YXMgY29udGVudC4gVGhpcyBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIHRoZSBjb250ZW50SWQgb3B0aW9uIGZvciBhIG5lc3RlZCBlbGVtZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBuZXN0ZWQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgbWFpbiBjb250ZW50IHdoZW4gYW4gb2ZmIGNhbnZhcyBwYW5lbCBpcyBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBjb250ZW50U2Nyb2xsOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSBpbiBtcyB0aGUgb3BlbiBhbmQgY2xvc2UgdHJhbnNpdGlvbiByZXF1aXJlcy4gSWYgbm9uZSBzZWxlY3RlZCwgcHVsbHMgZnJvbSBib2R5IHN0eWxlLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIHRyYW5zaXRpb25UaW1lOiBudWxsLFxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIHRyYW5zaXRpb24gZm9yIHRoZSBvZmZjYW52YXMgbWVudS4gT3B0aW9ucyBhcmUgJ3B1c2gnLCAnZGV0YWNoZWQnIG9yICdzbGlkZScuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgcHVzaFxuICAgKi9cbiAgdHJhbnNpdGlvbjogJ3B1c2gnLFxuXG4gIC8qKlxuICAgKiBGb3JjZSB0aGUgcGFnZSB0byBzY3JvbGwgdG8gdG9wIG9yIGJvdHRvbSBvbiBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBmb3JjZVRvOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgb2ZmY2FudmFzIHRvIHJlbWFpbiBvcGVuIGZvciBjZXJ0YWluIGJyZWFrcG9pbnRzLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaXNSZXZlYWxlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEJyZWFrcG9pbnQgYXQgd2hpY2ggdG8gcmV2ZWFsLiBKUyB3aWxsIHVzZSBhIFJlZ0V4cCB0byB0YXJnZXQgc3RhbmRhcmQgY2xhc3NlcywgaWYgY2hhbmdpbmcgY2xhc3NuYW1lcywgcGFzcyB5b3VyIGNsYXNzIHdpdGggdGhlIGByZXZlYWxDbGFzc2Agb3B0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICByZXZlYWxPbjogbnVsbCxcblxuICAvKipcbiAgICogRm9yY2UgZm9jdXMgdG8gdGhlIG9mZmNhbnZhcyBvbiBvcGVuLiBJZiB0cnVlLCB3aWxsIGZvY3VzIHRoZSBvcGVuaW5nIHRyaWdnZXIgb24gY2xvc2UuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGF1dG9Gb2N1czogdHJ1ZSxcblxuICAvKipcbiAgICogQ2xhc3MgdXNlZCB0byBmb3JjZSBhbiBvZmZjYW52YXMgdG8gcmVtYWluIG9wZW4uIEZvdW5kYXRpb24gZGVmYXVsdHMgZm9yIHRoaXMgYXJlIGByZXZlYWwtZm9yLWxhcmdlYCAmIGByZXZlYWwtZm9yLW1lZGl1bWAuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgcmV2ZWFsLWZvci1cbiAgICogQHRvZG8gaW1wcm92ZSB0aGUgcmVnZXggdGVzdGluZyBmb3IgdGhpcy5cbiAgICovXG4gIHJldmVhbENsYXNzOiAncmV2ZWFsLWZvci0nLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBvcHRpb25hbCBmb2N1cyB0cmFwcGluZyB3aGVuIG9wZW5pbmcgYW4gb2ZmY2FudmFzLiBTZXRzIHRhYmluZGV4IG9mIFtkYXRhLW9mZi1jYW52YXMtY29udGVudF0gdG8gLTEgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB0cmFwRm9jdXM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9yYml0IG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5vcmJpdFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuaW1hZ2VMb2FkZXJcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudG91Y2hcbiAqL1xuXG52YXIgT3JiaXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKE9yYml0LCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBPcmJpdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3JiaXQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihPcmJpdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT3JiaXQsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIG9yYml0IGNhcm91c2VsLlxuICAgICogQGNsYXNzXG4gICAgKiBAbmFtZSBPcmJpdFxuICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBPcmJpdCBDYXJvdXNlbC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgT3JiaXQuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ09yYml0JzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIFRvdWNoLmluaXQoJCk7IC8vIFRvdWNoIGluaXQgaXMgaWRlbXBvdGVudCwgd2UganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCdzIGluaXRpYWxpZWQuXG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgS2V5Ym9hcmQucmVnaXN0ZXIoJ09yYml0Jywge1xuICAgICAgICAnbHRyJzoge1xuICAgICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcbiAgICAgICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cydcbiAgICAgICAgfSxcbiAgICAgICAgJ3J0bCc6IHtcbiAgICAgICAgICAnQVJST1dfTEVGVCc6ICduZXh0JyxcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAncHJldmlvdXMnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4gYnkgY3JlYXRpbmcgalF1ZXJ5IGNvbGxlY3Rpb25zLCBzZXR0aW5nIGF0dHJpYnV0ZXMsIGFuZCBzdGFydGluZyB0aGUgYW5pbWF0aW9uLlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIC8vIEBUT0RPOiBjb25zaWRlciBkaXNjdXNzaW9uIG9uIFBSICM5Mjc4IGFib3V0IERPTSBwb2xsdXRpb24gYnkgY2hhbmdlU2xpZGVcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG5cbiAgICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcykpO1xuICAgICAgdGhpcy4kc2xpZGVzID0gdGhpcy4kZWxlbWVudC5maW5kKFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpO1xuICAgICAgdmFyICRpbWFnZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2ltZycpLFxuICAgICAgICAgIGluaXRBY3RpdmUgPSB0aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJyksXG4gICAgICAgICAgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEdldFlvRGlnaXRzKDYsICdvcmJpdCcpO1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogaWQsXG4gICAgICAgICdpZCc6IGlkXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFpbml0QWN0aXZlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiRzbGlkZXMuZXEoMCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VNVUkpIHtcbiAgICAgICAgdGhpcy4kc2xpZGVzLmFkZENsYXNzKCduby1tb3Rpb251aScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgb25JbWFnZXNMb2FkZWQoJGltYWdlcywgdGhpcy5fcHJlcGFyZUZvck9yYml0LmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvck9yYml0KCk7IC8vaGVoZVxuXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xuICAgICAgICB0aGlzLl9sb2FkQnVsbGV0cygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ldmVudHMoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSAmJiB0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLmdlb1N5bmMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY2Nlc3NpYmxlKSB7XG4gICAgICAgIC8vIGFsbG93IHdyYXBwZXIgdG8gYmUgZm9jdXNhYmxlIHRvIGVuYWJsZSBhcnJvdyBuYXZpZ2F0aW9uXG4gICAgICAgIHRoaXMuJHdyYXBwZXIuYXR0cigndGFiaW5kZXgnLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgYnVsbGV0cywgaWYgdGhleSBhcmUgYmVpbmcgdXNlZC5cbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvYWRCdWxsZXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkQnVsbGV0cygpIHtcbiAgICAgIHRoaXMuJGJ1bGxldHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5ib3hPZkJ1bGxldHMpKS5maW5kKCdidXR0b24nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIGEgYHRpbWVyYCBvYmplY3Qgb24gdGhlIG9yYml0LCBhbmQgc3RhcnRzIHRoZSBjb3VudGVyIGZvciB0aGUgbmV4dCBzbGlkZS5cbiAgICAqIEBmdW5jdGlvblxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZW9TeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlb1N5bmMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLnRpbWVyID0gbmV3IFRpbWVyKHRoaXMuJGVsZW1lbnQsIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy50aW1lckRlbGF5LFxuICAgICAgICBpbmZpbml0ZTogZmFsc2VcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGltZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIHdyYXBwZXIgYW5kIHNsaWRlIGhlaWdodHMgZm9yIHRoZSBvcmJpdC5cbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3ByZXBhcmVGb3JPcmJpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZUZvck9yYml0KCkge1xuXG4gICAgICB0aGlzLl9zZXRXcmFwcGVySGVpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQ2FsdWxhdGVzIHRoZSBoZWlnaHQgb2YgZWFjaCBzbGlkZSBpbiB0aGUgY29sbGVjdGlvbiwgYW5kIHVzZXMgdGhlIHRhbGxlc3Qgb25lIGZvciB0aGUgd3JhcHBlciBoZWlnaHQuXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSB3aGVuIGNvbXBsZXRlLlxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0V3JhcHBlckhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0V3JhcHBlckhlaWdodChjYikge1xuICAgICAgLy9yZXdyaXRlIHRoaXMgdG8gYGZvcmAgbG9vcFxuICAgICAgdmFyIG1heCA9IDAsXG4gICAgICAgICAgdGVtcCxcbiAgICAgICAgICBjb3VudGVyID0gMCxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAkKHRoaXMpLmF0dHIoJ2RhdGEtc2xpZGUnLCBjb3VudGVyKTsgLy8gaGlkZSBhbGwgc2xpZGVzIGJ1dCB0aGUgYWN0aXZlIG9uZVxuXG4gICAgICAgIGlmICghL211aS9nLnRlc3QoJCh0aGlzKVswXS5jbGFzc05hbWUpICYmIF90aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJylbMF0gIT09IF90aGlzLiRzbGlkZXMuZXEoY291bnRlcilbMF0pIHtcbiAgICAgICAgICAkKHRoaXMpLmNzcyh7XG4gICAgICAgICAgICAnZGlzcGxheSc6ICdub25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF4ID0gdGVtcCA+IG1heCA/IHRlbXAgOiBtYXg7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY291bnRlciA9PT0gdGhpcy4kc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiR3cmFwcGVyLmNzcyh7XG4gICAgICAgICAgJ2hlaWdodCc6IG1heFxuICAgICAgICB9KTsgLy9vbmx5IGNoYW5nZSB0aGUgd3JhcHBlciBoZWlnaHQgcHJvcGVydHkgb25jZS5cblxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihtYXgpO1xuICAgICAgICB9IC8vZmlyZSBjYWxsYmFjayB3aXRoIG1heCBoZWlnaHQgZGltZW5zaW9uLlxuXG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogU2V0cyB0aGUgbWF4LWhlaWdodCBvZiBlYWNoIHNsaWRlLlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U2xpZGVIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNsaWRlSGVpZ2h0KGhlaWdodCkge1xuICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAkKHRoaXMpLmNzcygnbWF4LWhlaWdodCcsIGhlaWdodCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byBiYXNpY2FsbHkgZXZlcnl0aGluZyB3aXRoaW4gdGhlIGVsZW1lbnQuXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAvLyoqTm93IHVzaW5nIGN1c3RvbSBldmVudCAtIHRoYW5rcyB0bzoqKlxuICAgICAgLy8qKiAgICAgIFlvaGFpIEFyYXJhdCBvZiBUb3JvbnRvICAgICAgKipcbiAgICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAvL1xuXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcucmVzaXplbWUuemYudHJpZ2dlcicpLm9uKHtcbiAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9wcmVwYXJlRm9yT3JiaXQuYmluZCh0aGlzKVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN3aXBlKSB7XG4gICAgICAgICAgdGhpcy4kc2xpZGVzLm9mZignc3dpcGVsZWZ0LnpmLm9yYml0IHN3aXBlcmlnaHQuemYub3JiaXQnKS5vbignc3dpcGVsZWZ0LnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XG4gICAgICAgICAgfSkub24oJ3N3aXBlcmlnaHQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkpIHtcbiAgICAgICAgICB0aGlzLiRzbGlkZXMub24oJ2NsaWNrLnpmLm9yYml0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJywgX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykgPyBmYWxzZSA6IHRydWUpO1xuXG4gICAgICAgICAgICBfdGhpcy50aW1lcltfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nKSA/ICdwYXVzZScgOiAnc3RhcnQnXSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXVzZU9uSG92ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZW50ZXIuemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLnRpbWVyLnBhdXNlKCk7XG4gICAgICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5vcmJpdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubmF2QnV0dG9ucykge1xuICAgICAgICAgIHZhciAkY29udHJvbHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5uZXh0Q2xhc3MsIFwiLCAuXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMucHJldkNsYXNzKSk7XG4gICAgICAgICAgJGNvbnRyb2xzLmF0dHIoJ3RhYmluZGV4JywgMCkgLy9hbHNvIG5lZWQgdG8gaGFuZGxlIGVudGVyL3JldHVybiBhbmQgc3BhY2ViYXIga2V5IHByZXNzZXNcbiAgICAgICAgICAub24oJ2NsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoJCh0aGlzKS5oYXNDbGFzcyhfdGhpcy5vcHRpb25zLm5leHRDbGFzcykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRzKSB7XG4gICAgICAgICAgdGhpcy4kYnVsbGV0cy5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoL2lzLWFjdGl2ZS9nLnRlc3QodGhpcy5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gLy9pZiB0aGlzIGlzIGFjdGl2ZSwga2ljayBvdXQgb2YgZnVuY3Rpb24uXG5cblxuICAgICAgICAgICAgdmFyIGlkeCA9ICQodGhpcykuZGF0YSgnc2xpZGUnKSxcbiAgICAgICAgICAgICAgICBsdHIgPSBpZHggPiBfdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLmRhdGEoJ3NsaWRlJyksXG4gICAgICAgICAgICAgICAgJHNsaWRlID0gX3RoaXMuJHNsaWRlcy5lcShpZHgpO1xuXG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShsdHIsICRzbGlkZSwgaWR4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWNjZXNzaWJsZSkge1xuICAgICAgICAgIHRoaXMuJHdyYXBwZXIuYWRkKHRoaXMuJGJ1bGxldHMpLm9uKCdrZXlkb3duLnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbiAgICAgICAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnT3JiaXQnLCB7XG4gICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShmYWxzZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYnVsbGV0IGlzIGZvY3VzZWQsIG1ha2Ugc3VyZSBmb2N1cyBtb3Zlc1xuICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyhfdGhpcy4kYnVsbGV0cykpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLiRidWxsZXRzLmZpbHRlcignLmlzLWFjdGl2ZScpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgT3JiaXQgc28gaXQgY2FuIGJlIHJlaW5pdGlhbGl6ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXQoKSB7XG4gICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGVyZSBhcmUgbm8gc2xpZGVzIChmaXJzdCBydW4pXG4gICAgICBpZiAodHlwZW9mIHRoaXMuJHNsaWRlcyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBSZW1vdmUgb2xkIGV2ZW50c1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLm9yYml0JykuZmluZCgnKicpLm9mZignLnpmLm9yYml0Jyk7IC8vIFJlc3RhcnQgdGltZXIgaWYgYXV0b1BsYXkgaXMgZW5hYmxlZFxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkpIHtcbiAgICAgICAgICB0aGlzLnRpbWVyLnJlc3RhcnQoKTtcbiAgICAgICAgfSAvLyBSZXNldCBhbGwgc2xpZGRlc1xuXG5cbiAgICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgJChlbCkucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1hY3RpdmUgaXMtaW4nKS5yZW1vdmVBdHRyKCdhcmlhLWxpdmUnKS5oaWRlKCk7XG4gICAgICAgIH0pOyAvLyBTaG93IHRoZSBmaXJzdCBzbGlkZVxuXG4gICAgICAgIHRoaXMuJHNsaWRlcy5maXJzdCgpLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5zaG93KCk7IC8vIFRyaWdnZXJzIHdoZW4gdGhlIHNsaWRlIGhhcyBmaW5pc2hlZCBhbmltYXRpbmdcblxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3NsaWRlY2hhbmdlLnpmLm9yYml0JywgW3RoaXMuJHNsaWRlcy5maXJzdCgpXSk7IC8vIFNlbGVjdCBmaXJzdCBidWxsZXQgaWYgYnVsbGV0cyBhcmUgcHJlc2VudFxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJ1bGxldHMoMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHNsaWRlIHRvIGEgbmV3IG9uZS5cbiAgICAqIEBmdW5jdGlvblxuICAgICogQHBhcmFtIHtCb29sZWFufSBpc0xUUiAtIGlmIHRydWUgdGhlIHNsaWRlIG1vdmVzIGZyb20gcmlnaHQgdG8gbGVmdCwgaWYgZmFsc2UgdGhlIHNsaWRlIG1vdmVzIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAqIEBwYXJhbSB7alF1ZXJ5fSBjaG9zZW5TbGlkZSAtIHRoZSBqUXVlcnkgZWxlbWVudCBvZiB0aGUgc2xpZGUgdG8gc2hvdyBuZXh0LCBpZiBvbmUgaXMgc2VsZWN0ZWQuXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBuZXcgc2xpZGUgaW4gaXRzIGNvbGxlY3Rpb24sIGlmIG9uZSBjaG9zZW4uXG4gICAgKiBAZmlyZXMgT3JiaXQjc2xpZGVjaGFuZ2VcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhbmdlU2xpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hhbmdlU2xpZGUoaXNMVFIsIGNob3NlblNsaWRlLCBpZHgpIHtcbiAgICAgIGlmICghdGhpcy4kc2xpZGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRG9uJ3QgZnJlYWsgb3V0IGlmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgY2xlYW51cFxuXG5cbiAgICAgIHZhciAkY3VyU2xpZGUgPSB0aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZXEoMCk7XG5cbiAgICAgIGlmICgvbXVpL2cudGVzdCgkY3VyU2xpZGVbMF0uY2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vaWYgdGhlIHNsaWRlIGlzIGN1cnJlbnRseSBhbmltYXRpbmcsIGtpY2sgb3V0IG9mIHRoZSBmdW5jdGlvblxuXG5cbiAgICAgIHZhciAkZmlyc3RTbGlkZSA9IHRoaXMuJHNsaWRlcy5maXJzdCgpLFxuICAgICAgICAgICRsYXN0U2xpZGUgPSB0aGlzLiRzbGlkZXMubGFzdCgpLFxuICAgICAgICAgIGRpckluID0gaXNMVFIgPyAnUmlnaHQnIDogJ0xlZnQnLFxuICAgICAgICAgIGRpck91dCA9IGlzTFRSID8gJ0xlZnQnIDogJ1JpZ2h0JyxcbiAgICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgJG5ld1NsaWRlO1xuXG4gICAgICBpZiAoIWNob3NlblNsaWRlKSB7XG4gICAgICAgIC8vbW9zdCBvZiB0aGUgdGltZSwgdGhpcyB3aWxsIGJlIGF1dG8gcGxheWVkIG9yIGNsaWNrZWQgZnJvbSB0aGUgbmF2QnV0dG9ucy5cbiAgICAgICAgJG5ld1NsaWRlID0gaXNMVFIgPyAvL2lmIHdyYXBwaW5nIGVuYWJsZWQsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGBuZXh0YCBvciBgcHJldmAgc2libGluZywgaWYgbm90LCBzZWxlY3QgdGhlIGZpcnN0IG9yIGxhc3Qgc2xpZGUgdG8gZmlsbCBpbi4gaWYgd3JhcHBpbmcgbm90IGVuYWJsZWQsIGF0dGVtcHQgdG8gc2VsZWN0IGBuZXh0YCBvciBgcHJldmAsIGlmIHRoZXJlJ3Mgbm90aGluZyB0aGVyZSwgdGhlIGZ1bmN0aW9uIHdpbGwga2ljayBvdXQgb24gbmV4dCBzdGVwLiBDUkFaWSBORVNURUQgVEVSTkFSSUVTISEhISFcbiAgICAgICAgdGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/ICRjdXJTbGlkZS5uZXh0KFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpLmxlbmd0aCA/ICRjdXJTbGlkZS5uZXh0KFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpIDogJGZpcnN0U2xpZGUgOiAkY3VyU2xpZGUubmV4dChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpKSA6IC8vcGljayBuZXh0IHNsaWRlIGlmIG1vdmluZyBsZWZ0IHRvIHJpZ2h0XG4gICAgICAgIHRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXAgPyAkY3VyU2xpZGUucHJldihcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpKS5sZW5ndGggPyAkY3VyU2xpZGUucHJldihcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpKSA6ICRsYXN0U2xpZGUgOiAkY3VyU2xpZGUucHJldihcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpKTsgLy9waWNrIHByZXYgc2xpZGUgaWYgbW92aW5nIHJpZ2h0IHRvIGxlZnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRuZXdTbGlkZSA9IGNob3NlblNsaWRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJG5ld1NsaWRlLmxlbmd0aCkge1xuICAgICAgICAvKipcbiAgICAgICAgKiBUcmlnZ2VycyBiZWZvcmUgdGhlIG5leHQgc2xpZGUgc3RhcnRzIGFuaW1hdGluZyBpbiBhbmQgb25seSBpZiBhIG5leHQgc2xpZGUgaGFzIGJlZW4gZm91bmQuXG4gICAgICAgICogQGV2ZW50IE9yYml0I2JlZm9yZXNsaWRlY2hhbmdlXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignYmVmb3Jlc2xpZGVjaGFuZ2UuemYub3JiaXQnLCBbJGN1clNsaWRlLCAkbmV3U2xpZGVdKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcbiAgICAgICAgICBpZHggPSBpZHggfHwgdGhpcy4kc2xpZGVzLmluZGV4KCRuZXdTbGlkZSk7IC8vZ3JhYiBpbmRleCB0byB1cGRhdGUgYnVsbGV0c1xuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnVsbGV0cyhpZHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VNVUkgJiYgIXRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgIE1vdGlvbi5hbmltYXRlSW4oJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUnKSwgdGhpcy5vcHRpb25zW1wiYW5pbUluRnJvbVwiLmNvbmNhdChkaXJJbildLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkbmV3U2xpZGUuY3NzKHtcbiAgICAgICAgICAgICAgJ2Rpc3BsYXknOiAnYmxvY2snXG4gICAgICAgICAgICB9KS5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgTW90aW9uLmFuaW1hdGVPdXQoJGN1clNsaWRlLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKSwgdGhpcy5vcHRpb25zW1wiYW5pbU91dFRvXCIuY29uY2F0KGRpck91dCldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkY3VyU2xpZGUucmVtb3ZlQXR0cignYXJpYS1saXZlJyk7XG5cbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmICFfdGhpcy50aW1lci5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICBfdGhpcy50aW1lci5yZXN0YXJ0KCk7XG4gICAgICAgICAgICB9IC8vZG8gc3R1ZmY/XG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkY3VyU2xpZGUucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1pbicpLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpLmhpZGUoKTtcbiAgICAgICAgICAkbmV3U2xpZGUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1pbicpLmF0dHIoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKS5zaG93KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmICF0aGlzLnRpbWVyLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyLnJlc3RhcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICogVHJpZ2dlcnMgd2hlbiB0aGUgc2xpZGUgaGFzIGZpbmlzaGVkIGFuaW1hdGluZyBpbi5cbiAgICAgICAgKiBAZXZlbnQgT3JiaXQjc2xpZGVjaGFuZ2VcbiAgICAgICAgKi9cblxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2xpZGVjaGFuZ2UuemYub3JiaXQnLCBbJG5ld1NsaWRlXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogVXBkYXRlcyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBidWxsZXRzLCBpZiBkaXNwbGF5ZWQuXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHNsaWRlLlxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQnVsbGV0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQnVsbGV0cyhpZHgpIHtcbiAgICAgIHZhciAkb2xkQnVsbGV0ID0gdGhpcy4kZWxlbWVudC5maW5kKFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzKSkuZmluZCgnLmlzLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5ibHVyKCksXG4gICAgICAgICAgc3BhbiA9ICRvbGRCdWxsZXQuZmluZCgnc3BhbjpsYXN0JykuZGV0YWNoKCksXG4gICAgICAgICAgJG5ld0J1bGxldCA9IHRoaXMuJGJ1bGxldHMuZXEoaWR4KS5hZGRDbGFzcygnaXMtYWN0aXZlJykuYXBwZW5kKHNwYW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIERlc3Ryb3lzIHRoZSBjYXJvdXNlbCBhbmQgaGlkZXMgdGhlIGVsZW1lbnQuXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLm9yYml0JykuZmluZCgnKicpLm9mZignLnpmLm9yYml0JykuZW5kKCkuaGlkZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPcmJpdDtcbn0oUGx1Z2luKTtcblxuT3JiaXQuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAqIFRlbGxzIHRoZSBKUyB0byBsb29rIGZvciBhbmQgbG9hZEJ1bGxldHMuXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKiBAZGVmYXVsdCB0cnVlXG4gICovXG4gIGJ1bGxldHM6IHRydWUsXG5cbiAgLyoqXG4gICogVGVsbHMgdGhlIEpTIHRvIGFwcGx5IGV2ZW50IGxpc3RlbmVycyB0byBuYXYgYnV0dG9uc1xuICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICogQGRlZmF1bHQgdHJ1ZVxuICAqL1xuICBuYXZCdXR0b25zOiB0cnVlLFxuXG4gIC8qKlxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICogQGRlZmF1bHQgJ3NsaWRlLWluLXJpZ2h0J1xuICAqL1xuICBhbmltSW5Gcm9tUmlnaHQ6ICdzbGlkZS1pbi1yaWdodCcsXG5cbiAgLyoqXG4gICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxuICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgKiBAZGVmYXVsdCAnc2xpZGUtb3V0LXJpZ2h0J1xuICAqL1xuICBhbmltT3V0VG9SaWdodDogJ3NsaWRlLW91dC1yaWdodCcsXG5cbiAgLyoqXG4gICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxuICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgKiBAZGVmYXVsdCAnc2xpZGUtaW4tbGVmdCdcbiAgKlxuICAqL1xuICBhbmltSW5Gcm9tTGVmdDogJ3NsaWRlLWluLWxlZnQnLFxuXG4gIC8qKlxuICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICogQGRlZmF1bHQgJ3NsaWRlLW91dC1sZWZ0J1xuICAqL1xuICBhbmltT3V0VG9MZWZ0OiAnc2xpZGUtb3V0LWxlZnQnLFxuXG4gIC8qKlxuICAqIEFsbG93cyBPcmJpdCB0byBhdXRvbWF0aWNhbGx5IGFuaW1hdGUgb24gcGFnZSBsb2FkLlxuICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICogQGRlZmF1bHQgdHJ1ZVxuICAqL1xuICBhdXRvUGxheTogdHJ1ZSxcblxuICAvKipcbiAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIGJldHdlZW4gc2xpZGUgdHJhbnNpdGlvbnNcbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICogQGRlZmF1bHQgNTAwMFxuICAqL1xuICB0aW1lckRlbGF5OiA1MDAwLFxuXG4gIC8qKlxuICAqIEFsbG93cyBPcmJpdCB0byBpbmZpbml0ZWx5IGxvb3AgdGhyb3VnaCB0aGUgc2xpZGVzXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKiBAZGVmYXVsdCB0cnVlXG4gICovXG4gIGluZmluaXRlV3JhcDogdHJ1ZSxcblxuICAvKipcbiAgKiBBbGxvd3MgdGhlIE9yYml0IHNsaWRlcyB0byBiaW5kIHRvIHN3aXBlIGV2ZW50cyBmb3IgbW9iaWxlLCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHV0aWwgbGlicmFyeVxuICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICogQGRlZmF1bHQgdHJ1ZVxuICAqL1xuICBzd2lwZTogdHJ1ZSxcblxuICAvKipcbiAgKiBBbGxvd3MgdGhlIHRpbWluZyBmdW5jdGlvbiB0byBwYXVzZSBhbmltYXRpb24gb24gaG92ZXIuXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKiBAZGVmYXVsdCB0cnVlXG4gICovXG4gIHBhdXNlT25Ib3ZlcjogdHJ1ZSxcblxuICAvKipcbiAgKiBBbGxvd3MgT3JiaXQgdG8gYmluZCBrZXlib2FyZCBldmVudHMgdG8gdGhlIHNsaWRlciwgdG8gYW5pbWF0ZSBmcmFtZXMgd2l0aCBhcnJvdyBrZXlzXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKiBAZGVmYXVsdCB0cnVlXG4gICovXG4gIGFjY2Vzc2libGU6IHRydWUsXG5cbiAgLyoqXG4gICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGFpbmVyIG9mIE9yYml0XG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAqIEBkZWZhdWx0ICdvcmJpdC1jb250YWluZXInXG4gICovXG4gIGNvbnRhaW5lckNsYXNzOiAnb3JiaXQtY29udGFpbmVyJyxcblxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIGluZGl2aWR1YWwgc2xpZGVzLlxuICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgKiBAZGVmYXVsdCAnb3JiaXQtc2xpZGUnXG4gICovXG4gIHNsaWRlQ2xhc3M6ICdvcmJpdC1zbGlkZScsXG5cbiAgLyoqXG4gICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYnVsbGV0IGNvbnRhaW5lci4gWW91J3JlIHdlbGNvbWUuXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAqIEBkZWZhdWx0ICdvcmJpdC1idWxsZXRzJ1xuICAqL1xuICBib3hPZkJ1bGxldHM6ICdvcmJpdC1idWxsZXRzJyxcblxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBgbmV4dGAgbmF2aWdhdGlvbiBidXR0b24uXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAqIEBkZWZhdWx0ICdvcmJpdC1uZXh0J1xuICAqL1xuICBuZXh0Q2xhc3M6ICdvcmJpdC1uZXh0JyxcblxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBgcHJldmlvdXNgIG5hdmlnYXRpb24gYnV0dG9uLlxuICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgKiBAZGVmYXVsdCAnb3JiaXQtcHJldmlvdXMnXG4gICovXG4gIHByZXZDbGFzczogJ29yYml0LXByZXZpb3VzJyxcblxuICAvKipcbiAgKiBCb29sZWFuIHRvIGZsYWcgdGhlIGpzIHRvIHVzZSBtb3Rpb24gdWkgY2xhc3NlcyBvciBub3QuIERlZmF1bHQgdG8gdHJ1ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKiBAZGVmYXVsdCB0cnVlXG4gICovXG4gIHVzZU1VSTogdHJ1ZVxufTtcblxudmFyIE1lbnVQbHVnaW5zID0ge1xuICBkcm9wZG93bjoge1xuICAgIGNzc0NsYXNzOiAnZHJvcGRvd24nLFxuICAgIHBsdWdpbjogRHJvcGRvd25NZW51XG4gIH0sXG4gIGRyaWxsZG93bjoge1xuICAgIGNzc0NsYXNzOiAnZHJpbGxkb3duJyxcbiAgICBwbHVnaW46IERyaWxsZG93blxuICB9LFxuICBhY2NvcmRpb246IHtcbiAgICBjc3NDbGFzczogJ2FjY29yZGlvbi1tZW51JyxcbiAgICBwbHVnaW46IEFjY29yZGlvbk1lbnVcbiAgfVxufTsgLy8gaW1wb3J0IFwiZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzLmpzXCI7XG5cbi8qKlxuICogUmVzcG9uc2l2ZU1lbnUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVNZW51XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqL1xuXG52YXIgUmVzcG9uc2l2ZU1lbnUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKFJlc3BvbnNpdmVNZW51LCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBSZXNwb25zaXZlTWVudSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZU1lbnUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihSZXNwb25zaXZlTWVudSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVzcG9uc2l2ZU1lbnUsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgbWVudS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBSZXNwb25zaXZlTWVudVxuICAgICAqIEBmaXJlcyBSZXNwb25zaXZlTWVudSNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIGRyb3Bkb3duIG1lbnUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICB0aGlzLnJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKCdyZXNwb25zaXZlLW1lbnUnKTtcbiAgICAgIHRoaXMuY3VycmVudE1xID0gbnVsbDtcbiAgICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG51bGw7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXNwb25zaXZlTWVudSc7IC8vIGllOSBiYWNrIGNvbXBhdFxuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgTWVudSBieSBwYXJzaW5nIHRoZSBjbGFzc2VzIGZyb20gdGhlICdkYXRhLVJlc3BvbnNpdmVNZW51JyBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgTWVkaWFRdWVyeS5faW5pdCgpOyAvLyBUaGUgZmlyc3QgdGltZSBhbiBJbnRlcmNoYW5nZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQsIHRoaXMucnVsZXMgaXMgY29udmVydGVkIGZyb20gYSBzdHJpbmcgb2YgXCJjbGFzc2VzXCIgdG8gYW4gb2JqZWN0IG9mIHJ1bGVzXG5cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnJ1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcnVsZXNUcmVlID0ge307IC8vIFBhcnNlIHJ1bGVzIGZyb20gXCJjbGFzc2VzXCIgcHVsbGVkIGZyb20gZGF0YSBhdHRyaWJ1dGVcblxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzLnNwbGl0KCcgJyk7IC8vIEl0ZXJhdGUgdGhyb3VnaCBldmVyeSBydWxlIGZvdW5kXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaV0uc3BsaXQoJy0nKTtcbiAgICAgICAgICB2YXIgcnVsZVNpemUgPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzBdIDogJ3NtYWxsJztcbiAgICAgICAgICB2YXIgcnVsZVBsdWdpbiA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMV0gOiBydWxlWzBdO1xuXG4gICAgICAgICAgaWYgKE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dICE9PSBudWxsKSB7XG4gICAgICAgICAgICBydWxlc1RyZWVbcnVsZVNpemVdID0gTWVudVBsdWdpbnNbcnVsZVBsdWdpbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzVHJlZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEkLmlzRW1wdHlPYmplY3QodGhpcy5ydWxlcykpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcbiAgICAgIH0gLy8gQWRkIGRhdGEtbXV0YXRlIHNpbmNlIGNoaWxkcmVuIG1heSBuZWVkIGl0LlxuXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1tdXRhdGUnLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtbXV0YXRlJykgfHwgR2V0WW9EaWdpdHMoNiwgJ3Jlc3BvbnNpdmUtbWVudScpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciB0aGUgTWVudS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuICAgICAgfSk7IC8vICQod2luZG93KS5vbigncmVzaXplLnpmLlJlc3BvbnNpdmVNZW51JywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIF90aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuICAgICAgLy8gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBzY3JlZW4gd2lkdGggYWdhaW5zdCBhdmFpbGFibGUgbWVkaWEgcXVlcmllcy4gSWYgdGhlIG1lZGlhIHF1ZXJ5IGhhcyBjaGFuZ2VkLCBhbmQgdGhlIHBsdWdpbiBuZWVkZWQgaGFzIGNoYW5nZWQsIHRoZSBwbHVnaW5zIHdpbGwgc3dhcCBvdXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja01lZGlhUXVlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tNZWRpYVF1ZXJpZXMoKSB7XG4gICAgICB2YXIgbWF0Y2hlZE1xLFxuICAgICAgICAgIF90aGlzID0gdGhpczsgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSBhbmQgZmluZCB0aGUgbGFzdCBtYXRjaGluZyBydWxlXG5cblxuICAgICAgJC5lYWNoKHRoaXMucnVsZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKE1lZGlhUXVlcnkuYXRMZWFzdChrZXkpKSB7XG4gICAgICAgICAgbWF0Y2hlZE1xID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gTm8gbWF0Y2g/IE5vIGRpY2VcblxuICAgICAgaWYgKCFtYXRjaGVkTXEpIHJldHVybjsgLy8gUGx1Z2luIGFscmVhZHkgaW5pdGlhbGl6ZWQ/IFdlIGdvb2RcblxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4pIHJldHVybjsgLy8gUmVtb3ZlIGV4aXN0aW5nIHBsdWdpbi1zcGVjaWZpYyBDU1MgY2xhc3Nlc1xuXG4gICAgICAkLmVhY2goTWVudVBsdWdpbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIF90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHZhbHVlLmNzc0NsYXNzKTtcbiAgICAgIH0pOyAvLyBBZGQgdGhlIENTUyBjbGFzcyBmb3IgdGhlIG5ldyBwbHVnaW5cblxuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW21hdGNoZWRNcV0uY3NzQ2xhc3MpOyAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIG5ldyBwbHVnaW5cblxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbikgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG5ldyB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKHRoaXMuJGVsZW1lbnQsIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IHBsdWdpbiBvbiB0aGlzIGVsZW1lbnQsIGFzIHdlbGwgYXMgdGhlIHdpbmRvdyByZXNpemUgaGFuZGxlciB0aGF0IHN3aXRjaGVzIHRoZSBwbHVnaW5zIG91dC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcbiAgICAgICQod2luZG93KS5vZmYoJy56Zi5SZXNwb25zaXZlTWVudScpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNwb25zaXZlTWVudTtcbn0oUGx1Z2luKTtcblxuUmVzcG9uc2l2ZU1lbnUuZGVmYXVsdHMgPSB7fTtcblxuLyoqXG4gKiBSZXNwb25zaXZlVG9nZ2xlIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXNwb25zaXZlVG9nZ2xlXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gKi9cblxudmFyIFJlc3BvbnNpdmVUb2dnbGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKFJlc3BvbnNpdmVUb2dnbGUsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNpdmVUb2dnbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNpdmVUb2dnbGUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihSZXNwb25zaXZlVG9nZ2xlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlVG9nZ2xlLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVGFiIEJhci5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBSZXNwb25zaXZlVG9nZ2xlXG4gICAgICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjaW5pdFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhdHRhY2ggdGFiIGJhciBmdW5jdGlvbmFsaXR5IHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Jlc3BvbnNpdmVUb2dnbGUnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYiBiYXIgYnkgZmluZGluZyB0aGUgdGFyZ2V0IGVsZW1lbnQsIHRvZ2dsaW5nIGVsZW1lbnQsIGFuZCBydW5uaW5nIHVwZGF0ZSgpLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIE1lZGlhUXVlcnkuX2luaXQoKTtcblxuICAgICAgdmFyIHRhcmdldElEID0gdGhpcy4kZWxlbWVudC5kYXRhKCdyZXNwb25zaXZlLXRvZ2dsZScpO1xuXG4gICAgICBpZiAoIXRhcmdldElEKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdXIgdGFiIGJhciBuZWVkcyBhbiBJRCBvZiBhIE1lbnUgYXMgdGhlIHZhbHVlIG9mIGRhdGEtdGFiLWJhci4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kdGFyZ2V0TWVudSA9ICQoXCIjXCIuY29uY2F0KHRhcmdldElEKSk7XG4gICAgICB0aGlzLiR0b2dnbGVyID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS10b2dnbGVdJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9ICQodGhpcykuZGF0YSgndG9nZ2xlJyk7XG4gICAgICAgIHJldHVybiB0YXJnZXQgPT09IHRhcmdldElEIHx8IHRhcmdldCA9PT0gXCJcIjtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgdGhpcy4kdGFyZ2V0TWVudS5kYXRhKCkpOyAvLyBJZiB0aGV5IHdlcmUgc2V0LCBwYXJzZSB0aGUgYW5pbWF0aW9uIGNsYXNzZXNcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KCcgJyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSW4gPSBpbnB1dFswXTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25PdXQgPSBpbnB1dFsxXSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSB0YWIgYmFyIHRvIHdvcmsuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcblxuICAgICAgdGhpcy5fdXBkYXRlTXFIYW5kbGVyID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3VwZGF0ZU1xSGFuZGxlcik7XG4gICAgICB0aGlzLiR0b2dnbGVyLm9uKCdjbGljay56Zi5yZXNwb25zaXZlVG9nZ2xlJywgdGhpcy50b2dnbGVNZW51LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgbWVkaWEgcXVlcnkgdG8gZGV0ZXJtaW5lIGlmIHRoZSB0YWIgYmFyIHNob3VsZCBiZSB2aXNpYmxlIG9yIGhpZGRlbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuICAgICAgLy8gTW9iaWxlXG4gICAgICBpZiAoIU1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5zaG93KCk7XG4gICAgICAgIHRoaXMuJHRhcmdldE1lbnUuaGlkZSgpO1xuICAgICAgfSAvLyBEZXNrdG9wXG4gICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKTtcbiAgICAgICAgICB0aGlzLiR0YXJnZXRNZW51LnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyLiBUaGUgdG9nZ2xlIG9ubHkgaGFwcGVucyBpZiB0aGUgc2NyZWVuIGlzIHNtYWxsIGVub3VnaCB0byBhbGxvdyBpdC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZmlyZXMgUmVzcG9uc2l2ZVRvZ2dsZSN0b2dnbGVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVNZW51XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZU1lbnUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCFNZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyIHRvZ2dsZXMuXG4gICAgICAgICAqIEBldmVudCBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgICAgIGlmICh0aGlzLiR0YXJnZXRNZW51LmlzKCc6aGlkZGVuJykpIHtcbiAgICAgICAgICAgIE1vdGlvbi5hbmltYXRlSW4odGhpcy4kdGFyZ2V0TWVudSwgdGhpcy5hbmltYXRpb25JbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczIuJGVsZW1lbnQudHJpZ2dlcigndG9nZ2xlZC56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XG5cbiAgICAgICAgICAgICAgX3RoaXMyLiR0YXJnZXRNZW51LmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VySGFuZGxlcignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJHRhcmdldE1lbnUsIHRoaXMuYW5pbWF0aW9uT3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiR0YXJnZXRNZW51LnRvZ2dsZSgwKTtcbiAgICAgICAgICB0aGlzLiR0YXJnZXRNZW51LmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xuICAgICAgdGhpcy4kdG9nZ2xlci5vZmYoJy56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XG4gICAgICAkKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl91cGRhdGVNcUhhbmRsZXIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNwb25zaXZlVG9nZ2xlO1xufShQbHVnaW4pO1xuXG5SZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogVGhlIGJyZWFrcG9pbnQgYWZ0ZXIgd2hpY2ggdGhlIG1lbnUgaXMgYWx3YXlzIHNob3duLCBhbmQgdGhlIHRhYiBiYXIgaXMgaGlkZGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdtZWRpdW0nXG4gICAqL1xuICBoaWRlRm9yOiAnbWVkaXVtJyxcblxuICAvKipcbiAgICogVG8gZGVjaWRlIGlmIHRoZSB0b2dnbGUgc2hvdWxkIGJlIGFuaW1hdGVkIG9yIG5vdC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFuaW1hdGU6IGZhbHNlXG59O1xuXG4vKipcbiAqIFJldmVhbCBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmV2ZWFsXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uIGlmIHVzaW5nIGFuaW1hdGlvbnNcbiAqL1xuXG52YXIgUmV2ZWFsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhSZXZlYWwsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIFJldmVhbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmV2ZWFsKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUmV2ZWFsKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXZlYWwsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXZlYWwuXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgUmV2ZWFsXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBmb3IgdGhlIG1vZGFsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFJldmVhbC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmV2ZWFsJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuX2luaXQoKTsgLy8gVHJpZ2dlcnMgaW5pdCBpcyBpZGVtcG90ZW50LCBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0IGlzIGluaXRpYWxpemVkXG5cblxuICAgICAgVHJpZ2dlcnMuaW5pdCgkKTtcbiAgICAgIEtleWJvYXJkLnJlZ2lzdGVyKCdSZXZlYWwnLCB7XG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZGFsIGJ5IGFkZGluZyB0aGUgb3ZlcmxheSBhbmQgY2xvc2UgYnV0dG9ucywgKGlmIHNlbGVjdGVkKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgTWVkaWFRdWVyeS5faW5pdCgpO1xuXG4gICAgICB0aGlzLmlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jYWNoZWQgPSB7XG4gICAgICAgIG1xOiBNZWRpYVF1ZXJ5LmN1cnJlbnRcbiAgICAgIH07XG4gICAgICB0aGlzLiRhbmNob3IgPSAkKFwiW2RhdGEtb3Blbj1cXFwiXCIuY29uY2F0KHRoaXMuaWQsIFwiXFxcIl1cIikpLmxlbmd0aCA/ICQoXCJbZGF0YS1vcGVuPVxcXCJcIi5jb25jYXQodGhpcy5pZCwgXCJcXFwiXVwiKSkgOiAkKFwiW2RhdGEtdG9nZ2xlPVxcXCJcIi5jb25jYXQodGhpcy5pZCwgXCJcXFwiXVwiKSk7XG4gICAgICB0aGlzLiRhbmNob3IuYXR0cih7XG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogdGhpcy5pZCxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgICAndGFiaW5kZXgnOiAwXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2Z1bGwnKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbiA9IHRydWU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vdmVybGF5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiAhdGhpcy4kb3ZlcmxheSkge1xuICAgICAgICB0aGlzLiRvdmVybGF5ID0gdGhpcy5fbWFrZU92ZXJsYXkodGhpcy5pZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgICdyb2xlJzogJ2RpYWxvZycsXG4gICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAgICdkYXRhLXlldGktYm94JzogdGhpcy5pZCxcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogdGhpcy5pZFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLiRvdmVybGF5KSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZGV0YWNoKCkuYXBwZW5kVG8odGhpcy4kb3ZlcmxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKCQodGhpcy5vcHRpb25zLmFwcGVuZFRvKSk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ3dpdGhvdXQtb3ZlcmxheScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ldmVudHMoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluayAmJiB3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gXCIjXCIuY29uY2F0KHRoaXMuaWQpKSB7XG4gICAgICAgIHRoaXMub25Mb2FkTGlzdGVuZXIgPSBvbkxvYWQoJCh3aW5kb3cpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5vcGVuKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkgZGl2IHRvIGRpc3BsYXkgYmVoaW5kIHRoZSBtb2RhbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VPdmVybGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlT3ZlcmxheSgpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsT3ZlcmxheUNsYXNzZXMgPSAnJztcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRpdGlvbmFsT3ZlcmxheUNsYXNzZXMpIHtcbiAgICAgICAgYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzID0gJyAnICsgdGhpcy5vcHRpb25zLmFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3JldmVhbC1vdmVybGF5JyArIGFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlcykuYXBwZW5kVG8odGhpcy5vcHRpb25zLmFwcGVuZFRvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBwb3NpdGlvbiBvZiBtb2RhbFxuICAgICAqIFRPRE86ICBGaWd1cmUgb3V0IGlmIHdlIGFjdHVhbGx5IG5lZWQgdG8gY2FjaGUgdGhlc2UgdmFsdWVzIG9yIGlmIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLiRlbGVtZW50Lm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciBvdXRlcldpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpO1xuICAgICAgdmFyIG91dGVySGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuICAgICAgdmFyIGxlZnQsXG4gICAgICAgICAgdG9wID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oT2Zmc2V0ID09PSAnYXV0bycpIHtcbiAgICAgICAgbGVmdCA9IHBhcnNlSW50KChvdXRlcldpZHRoIC0gd2lkdGgpIC8gMiwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy5oT2Zmc2V0LCAxMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudk9mZnNldCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGlmIChoZWlnaHQgPiBvdXRlckhlaWdodCkge1xuICAgICAgICAgIHRvcCA9IHBhcnNlSW50KE1hdGgubWluKDEwMCwgb3V0ZXJIZWlnaHQgLyAxMCksIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3AgPSBwYXJzZUludCgob3V0ZXJIZWlnaHQgLSBoZWlnaHQpIC8gNCwgMTApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy52T2Zmc2V0ICE9PSBudWxsKSB7XG4gICAgICAgIHRvcCA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy52T2Zmc2V0LCAxMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3AgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgICAgIHRvcDogdG9wICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gb25seSB3b3JyeSBhYm91dCBsZWZ0IGlmIHdlIGRvbid0IGhhdmUgYW4gb3ZlcmxheSBvciB3ZSBoYXZlIGEgaG9yaXpvbnRhbCBvZmZzZXQsXG4gICAgICAvLyBvdGhlcndpc2Ugd2UncmUgcGVyZmVjdGx5IGluIHRoZSBtaWRkbGVcblxuXG4gICAgICBpZiAoIXRoaXMuJG92ZXJsYXkgfHwgdGhpcy5vcHRpb25zLmhPZmZzZXQgIT09ICdhdXRvJykge1xuICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICAgICAgbGVmdDogbGVmdCArICdweCdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgICAgICBtYXJnaW46ICcwcHgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgbW9kYWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcbiAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgICAnY2xvc2UuemYudHJpZ2dlcic6IGZ1bmN0aW9uIGNsb3NlWmZUcmlnZ2VyKGV2ZW50LCAkZWxlbWVudCkge1xuICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8ICQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCdbZGF0YS1jbG9zYWJsZV0nKVswXSA9PT0gJGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgY2xvc2UgcmV2ZWFsIHdoZW4gaXQncyBleHBsaWNpdGx5IGNhbGxlZFxuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5jbG9zZS5hcHBseShfdGhpczMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcbiAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiBmdW5jdGlvbiByZXNpemVtZVpmVHJpZ2dlcigpIHtcbiAgICAgICAgICBfdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmIHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkub2ZmKCcuemYucmV2ZWFsJykub24oJ2NsaWNrLnpmLnJldmVhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCAkLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLCBlLnRhcmdldCkgfHwgISQuY29udGFpbnMoZG9jdW1lbnQsIGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICAgICQod2luZG93KS5vbihcImhhc2hjaGFuZ2UuemYucmV2ZWFsOlwiLmNvbmNhdCh0aGlzLmlkKSwgdGhpcy5faGFuZGxlU3RhdGUuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbW9kYWwgbWV0aG9kcyBvbiBiYWNrL2ZvcndhcmQgYnV0dG9uIGNsaWNrcyBvciBhbnkgb3RoZXIgZXZlbnQgdGhhdCB0cmlnZ2VycyBoYXNoY2hhbmdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVN0YXRlKGUpIHtcbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gJyMnICsgdGhpcy5pZCAmJiAhdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBEaXNhYmxlcyB0aGUgc2Nyb2xsIHdoZW4gUmV2ZWFsIGlzIHNob3duIHRvIHByZXZlbnQgdGhlIGJhY2tncm91bmQgZnJvbSBzaGlmdGluZ1xuICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFRvcCAtIFNjcm9sbCB0byB2aXN1YWxseSBhcHBseSwgd2luZG93IGN1cnJlbnQgc2Nyb2xsIGJ5IGRlZmF1bHRcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rpc2FibGVTY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc2FibGVTY3JvbGwoc2Nyb2xsVG9wKSB7XG4gICAgICBzY3JvbGxUb3AgPSBzY3JvbGxUb3AgfHwgJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXG4gICAgICBpZiAoJChkb2N1bWVudCkuaGVpZ2h0KCkgPiAkKHdpbmRvdykuaGVpZ2h0KCkpIHtcbiAgICAgICAgJChcImh0bWxcIikuY3NzKFwidG9wXCIsIC1zY3JvbGxUb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIFJlZW5hYmxlcyB0aGUgc2Nyb2xsIHdoZW4gUmV2ZWFsIGNsb3Nlc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFRvcCAtIFNjcm9sbCB0byByZXN0b3JlLCBodG1sIFwidG9wXCIgcHJvcGVydHkgYnkgZGVmYXVsdCAoYXMgc2V0IGJ5IGBfZGlzYWJsZVNjcm9sbGApXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbmFibGVTY3JvbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VuYWJsZVNjcm9sbChzY3JvbGxUb3ApIHtcbiAgICAgIHNjcm9sbFRvcCA9IHNjcm9sbFRvcCB8fCBwYXJzZUludCgkKFwiaHRtbFwiKS5jc3MoXCJ0b3BcIikpO1xuXG4gICAgICBpZiAoJChkb2N1bWVudCkuaGVpZ2h0KCkgPiAkKHdpbmRvdykuaGVpZ2h0KCkpIHtcbiAgICAgICAgJChcImh0bWxcIikuY3NzKFwidG9wXCIsIFwiXCIpO1xuICAgICAgICAkKHdpbmRvdykuc2Nyb2xsVG9wKC1zY3JvbGxUb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgbW9kYWwgY29udHJvbGxlZCBieSBgdGhpcy4kYW5jaG9yYCwgYW5kIGNsb3NlcyBhbGwgb3RoZXJzIGJ5IGRlZmF1bHQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIFJldmVhbCNjbG9zZW1lXG4gICAgICogQGZpcmVzIFJldmVhbCNvcGVuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgLy8gZWl0aGVyIHVwZGF0ZSBvciByZXBsYWNlIGJyb3dzZXIgaGlzdG9yeVxuICAgICAgdmFyIGhhc2ggPSBcIiNcIi5jb25jYXQodGhpcy5pZCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmsgJiYgd2luZG93LmxvY2F0aW9uLmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlSGlzdG9yeSkge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgaGFzaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIGhhc2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGhhc2g7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVtZW1iZXIgYW5jaG9yIHRoYXQgb3BlbmVkIGl0IHRvIHNldCBmb2N1cyBiYWNrIGxhdGVyLCBoYXZlIGdlbmVyYWwgYW5jaG9ycyBhcyBmYWxsYmFja1xuXG5cbiAgICAgIHRoaXMuJGFjdGl2ZUFuY2hvciA9ICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuaXModGhpcy4kYW5jaG9yKSA/ICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgOiB0aGlzLiRhbmNob3I7XG4gICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTsgLy8gTWFrZSBlbGVtZW50cyBpbnZpc2libGUsIGJ1dCByZW1vdmUgZGlzcGxheTogbm9uZSBzbyB3ZSBjYW4gZ2V0IHNpemUgYW5kIHBvc2l0aW9uaW5nXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgICAgJ3Zpc2liaWxpdHknOiAnaGlkZGVuJ1xuICAgICAgfSkuc2hvdygpLnNjcm9sbFRvcCgwKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkuY3NzKHtcbiAgICAgICAgICAndmlzaWJpbGl0eSc6ICdoaWRkZW4nXG4gICAgICAgIH0pLnNob3coKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKCkuY3NzKHtcbiAgICAgICAgJ3Zpc2liaWxpdHknOiAnJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLiRvdmVybGF5KSB7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkuY3NzKHtcbiAgICAgICAgICAndmlzaWJpbGl0eSc6ICcnXG4gICAgICAgIH0pLmhpZGUoKTtcblxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFzdCcpKSB7XG4gICAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnZmFzdCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3Nsb3cnKSkge1xuICAgICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ3Nsb3cnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aXBsZU9wZW5lZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBtb2RhbCBvcGVucy5cbiAgICAgICAgICogQ2xvc2VzIGFueSBvdGhlciBtb2RhbHMgdGhhdCBhcmUgY3VycmVudGx5IG9wZW5cbiAgICAgICAgICogQGV2ZW50IFJldmVhbCNjbG9zZW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYucmV2ZWFsJywgdGhpcy5pZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rpc2FibGVTY3JvbGwoKTtcblxuICAgICAgdmFyIF90aGlzID0gdGhpczsgLy8gTW90aW9uIFVJIG1ldGhvZCBvZiByZXZlYWxcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbkluKSB7XG4gICAgICAgIHZhciBhZnRlckFuaW1hdGlvbiA9IGZ1bmN0aW9uIGFmdGVyQW5pbWF0aW9uKCkge1xuICAgICAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2UsXG4gICAgICAgICAgICAndGFiaW5kZXgnOiAtMVxuICAgICAgICAgIH0pLmZvY3VzKCk7XG5cbiAgICAgICAgICBfdGhpcy5fYWRkR2xvYmFsQ2xhc3NlcygpO1xuXG4gICAgICAgICAgS2V5Ym9hcmQudHJhcEZvY3VzKF90aGlzLiRlbGVtZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgICBNb3Rpb24uYW5pbWF0ZUluKHRoaXMuJG92ZXJsYXksICdmYWRlLWluJyk7XG4gICAgICAgIH1cblxuICAgICAgICBNb3Rpb24uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucy5hbmltYXRpb25JbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpczQuJGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHByb3RlY3QgYWdhaW5zdCBvYmplY3QgaGF2aW5nIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgX3RoaXM0LmZvY3VzYWJsZUVsZW1lbnRzID0gS2V5Ym9hcmQuZmluZEZvY3VzYWJsZShfdGhpczQuJGVsZW1lbnQpO1xuICAgICAgICAgICAgYWZ0ZXJBbmltYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBqUXVlcnkgbWV0aG9kIG9mIHJldmVhbFxuICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgICAgICB0aGlzLiRvdmVybGF5LnNob3coMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5zaG93KHRoaXMub3B0aW9ucy5zaG93RGVsYXkpO1xuICAgICAgICB9IC8vIGhhbmRsZSBhY2Nlc3NpYmlsaXR5XG5cblxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2UsXG4gICAgICAgICd0YWJpbmRleCc6IC0xXG4gICAgICB9KS5mb2N1cygpO1xuICAgICAgS2V5Ym9hcmQudHJhcEZvY3VzKHRoaXMuJGVsZW1lbnQpO1xuXG4gICAgICB0aGlzLl9hZGRHbG9iYWxDbGFzc2VzKCk7XG5cbiAgICAgIHRoaXMuX2FkZEdsb2JhbExpc3RlbmVycygpO1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBoYXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cbiAgICAgICAqIEBldmVudCBSZXZlYWwjb3BlblxuICAgICAgICovXG5cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvcGVuLnpmLnJldmVhbCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGNsYXNzZXMgYW5kIGxpc3RlbmVycyBvbiBkb2N1bWVudCByZXF1aXJlZCBieSBvcGVuIG1vZGFscy5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgY2xhc3NlcyBhcmUgYWRkZWQgYW5kIHVwZGF0ZWQ6XG4gICAgICogLSBgLmlzLXJldmVhbC1vcGVuYCAtIFByZXZlbnRzIHRoZSBzY3JvbGwgb24gZG9jdW1lbnRcbiAgICAgKiAtIGAuemYtaGFzLXNjcm9sbGAgIC0gRGlzcGxheXMgYSBkaXNhYmxlZCBzY3JvbGxiYXIgb24gZG9jdW1lbnQgaWYgcmVxdWlyZWQgbGlrZSBpZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsIHdhcyBub3QgZGlzYWJsZWQuIFRoaXMgcHJldmVudCBhIFwic2hpZnRcIiBvZiB0aGUgcGFnZSBjb250ZW50IGR1ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgc2Nyb2xsYmFyIGRpc2FwcGVhcmluZyB3aGVuIHRoZSBtb2RhbCBvcGVucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkR2xvYmFsQ2xhc3Nlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkR2xvYmFsQ2xhc3NlcygpIHtcbiAgICAgIHZhciB1cGRhdGVTY3JvbGxiYXJDbGFzcyA9IGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhckNsYXNzKCkge1xuICAgICAgICAkKCdodG1sJykudG9nZ2xlQ2xhc3MoJ3pmLWhhcy1zY3JvbGwnLCAhISgkKGRvY3VtZW50KS5oZWlnaHQoKSA+ICQod2luZG93KS5oZWlnaHQoKSkpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy4kZWxlbWVudC5vbigncmVzaXplbWUuemYudHJpZ2dlci5yZXZlYWxTY3JvbGxiYXJMaXN0ZW5lcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhckNsYXNzKCk7XG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhckNsYXNzKCk7XG4gICAgICAkKCdodG1sJykuYWRkQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgY2xhc3NlcyBhbmQgbGlzdGVuZXJzIG9uIGRvY3VtZW50IHRoYXQgd2VyZSByZXF1aXJlZCBieSBvcGVuIG1vZGFscy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUdsb2JhbENsYXNzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUdsb2JhbENsYXNzZXMoKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlci5yZXZlYWxTY3JvbGxiYXJMaXN0ZW5lcicpO1xuICAgICAgJCgnaHRtbCcpLnJlbW92ZUNsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xuICAgICAgJCgnaHRtbCcpLnJlbW92ZUNsYXNzKCd6Zi1oYXMtc2Nyb2xsJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZXh0cmEgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBib2R5IGFuZCB3aW5kb3cgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkR2xvYmFsTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRHbG9iYWxMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuJGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGNsZWFudXAsIGRvbid0IGZyZWFrIG91dFxuXG5cbiAgICAgIHRoaXMuZm9jdXNhYmxlRWxlbWVudHMgPSBLZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5vdmVybGF5ICYmIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgIXRoaXMub3B0aW9ucy5mdWxsU2NyZWVuKSB7XG4gICAgICAgICQoJ2JvZHknKS5vbignY2xpY2suemYucmV2ZWFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8ICQuY29udGFpbnMoX3RoaXMuJGVsZW1lbnRbMF0sIGUudGFyZ2V0KSB8fCAhJC5jb250YWlucyhkb2N1bWVudCwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xuICAgICAgICAkKHdpbmRvdykub24oJ2tleWRvd24uemYucmV2ZWFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBLZXlib2FyZC5oYW5kbGVLZXkoZSwgJ1JldmVhbCcsIHtcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgbW9kYWwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIFJldmVhbCNjbG9zZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8ICF0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzID0gdGhpczsgLy8gTW90aW9uIFVJIG1ldGhvZCBvZiBoaWRpbmdcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgICBNb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRvdmVybGF5LCAnZmFkZS1vdXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucy5hbmltYXRpb25PdXQsIGZpbmlzaFVwKTtcbiAgICAgIH0gLy8galF1ZXJ5IG1ldGhvZCBvZiBoaWRpbmdcbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSh0aGlzLm9wdGlvbnMuaGlkZURlbGF5KTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy4kb3ZlcmxheS5oaWRlKDAsIGZpbmlzaFVwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmluaXNoVXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ29uZGl0aW9uYWxzIHRvIHJlbW92ZSBleHRyYSBldmVudCBsaXN0ZW5lcnMgYWRkZWQgb24gb3BlblxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xuICAgICAgICAkKHdpbmRvdykub2ZmKCdrZXlkb3duLnpmLnJldmVhbCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5vdmVybGF5ICYmIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcbiAgICAgICAgJCgnYm9keScpLm9mZignY2xpY2suemYucmV2ZWFsJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLnpmLnJldmVhbCcpO1xuXG4gICAgICBmdW5jdGlvbiBmaW5pc2hVcCgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRvcCBiZWZvcmUgdGhlIG1vZGFsIGlzIGNsb3NlZCBhbmQgcmVzdG9yZSB0aGUgc2Nyb2xsIGFmdGVyLlxuICAgICAgICAvLyBUT0RPOiB1c2UgY29tcG9uZW50IHByb3BlcnRpZXMgaW5zdGVhZCBvZiBIVE1MIHByb3BlcnRpZXNcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS96dXJiL2ZvdW5kYXRpb24tc2l0ZXMvcHVsbC8xMDc4NlxuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gcGFyc2VJbnQoJChcImh0bWxcIikuY3NzKFwidG9wXCIpKTtcblxuICAgICAgICBpZiAoJCgnLnJldmVhbDp2aXNpYmxlJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgX3RoaXMuX3JlbW92ZUdsb2JhbENsYXNzZXMoKTsgLy8gYWxzbyByZW1vdmUgLmlzLXJldmVhbC1vcGVuIGZyb20gdGhlIGh0bWwgZWxlbWVudCB3aGVuIHRoZXJlIGlzIG5vIG9wZW5lZCByZXZlYWxcblxuICAgICAgICB9XG5cbiAgICAgICAgS2V5Ym9hcmQucmVsZWFzZUZvY3VzKF90aGlzLiRlbGVtZW50KTtcblxuICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgICAgIF90aGlzLl9lbmFibGVTY3JvbGwoc2Nyb2xsVG9wKTtcbiAgICAgICAgLyoqXG4gICAgICAgICogRmlyZXMgd2hlbiB0aGUgbW9kYWwgaXMgZG9uZSBjbG9zaW5nLlxuICAgICAgICAqIEBldmVudCBSZXZlYWwjY2xvc2VkXG4gICAgICAgICovXG5cblxuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYucmV2ZWFsJyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICogUmVzZXRzIHRoZSBtb2RhbCBjb250ZW50XG4gICAgICAqIFRoaXMgcHJldmVudHMgYSBydW5uaW5nIHZpZGVvIHRvIGtlZXAgZ29pbmcgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICovXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNldE9uQ2xvc2UpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5odG1sKHRoaXMuJGVsZW1lbnQuaHRtbCgpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlOyAvLyBJZiBkZWVwTGluayBhbmQgd2UgZGlkIG5vdCBzd2l0Y2hlZCB0byBhbiBvdGhlciBtb2RhbC4uLlxuXG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5kZWVwTGluayAmJiB3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gXCIjXCIuY29uY2F0KHRoaXMuaWQpKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgaGlzdG9yeSBoYXNoXG4gICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcbiAgICAgICAgICB2YXIgdXJsV2l0aG91dEhhc2ggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVIaXN0b3J5KSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCB1cmxXaXRob3V0SGFzaCk7IC8vIHJlbW92ZSB0aGUgaGFzaFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoJycsIGRvY3VtZW50LnRpdGxlLCB1cmxXaXRob3V0SGFzaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy4kYWN0aXZlQW5jaG9yLmZvY3VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2VkIHN0YXRlIG9mIGEgbW9kYWwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhIG1vZGFsLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZFRvKCQodGhpcy5vcHRpb25zLmFwcGVuZFRvKSk7IC8vIG1vdmUgJGVsZW1lbnQgb3V0c2lkZSBvZiAkb3ZlcmxheSB0byBwcmV2ZW50IGVycm9yIHVucmVnaXN0ZXJQbHVnaW4oKVxuXG4gICAgICAgIHRoaXMuJG92ZXJsYXkuaGlkZSgpLm9mZigpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKS5vZmYoKTtcbiAgICAgIHRoaXMuJGFuY2hvci5vZmYoJy56ZicpO1xuICAgICAgJCh3aW5kb3cpLm9mZihcIi56Zi5yZXZlYWw6XCIuY29uY2F0KHRoaXMuaWQpKTtcbiAgICAgIGlmICh0aGlzLm9uTG9hZExpc3RlbmVyKSAkKHdpbmRvdykub2ZmKHRoaXMub25Mb2FkTGlzdGVuZXIpO1xuXG4gICAgICBpZiAoJCgnLnJldmVhbDp2aXNpYmxlJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUdsb2JhbENsYXNzZXMoKTsgLy8gYWxzbyByZW1vdmUgLmlzLXJldmVhbC1vcGVuIGZyb20gdGhlIGh0bWwgZWxlbWVudCB3aGVuIHRoZXJlIGlzIG5vIG9wZW5lZCByZXZlYWxcblxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXZlYWw7XG59KFBsdWdpbik7XG5cblJldmVhbC5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIE1vdGlvbi1VSSBjbGFzcyB0byB1c2UgZm9yIGFuaW1hdGVkIGVsZW1lbnRzLiBJZiBub25lIHVzZWQsIGRlZmF1bHRzIHRvIHNpbXBsZSBzaG93L2hpZGUuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIGFuaW1hdGlvbkluOiAnJyxcblxuICAvKipcbiAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgYW5pbWF0aW9uT3V0OiAnJyxcblxuICAvKipcbiAgICogVGltZSwgaW4gbXMsIHRvIGRlbGF5IHRoZSBvcGVuaW5nIG9mIGEgbW9kYWwgYWZ0ZXIgYSBjbGljayBpZiBubyBhbmltYXRpb24gdXNlZC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBzaG93RGVsYXk6IDAsXG5cbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCB0byBkZWxheSB0aGUgY2xvc2luZyBvZiBhIG1vZGFsIGFmdGVyIGEgY2xpY2sgaWYgbm8gYW5pbWF0aW9uIHVzZWQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgaGlkZURlbGF5OiAwLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSBjbGljayBvbiB0aGUgYm9keS9vdmVybGF5IHRvIGNsb3NlIHRoZSBtb2RhbC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGNsb3NlIGlmIHRoZSB1c2VyIHByZXNzZXMgdGhlIGBFU0NBUEVgIGtleS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgY2xvc2VPbkVzYzogdHJ1ZSxcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgYWxsb3dzIG11bHRpcGxlIG1vZGFscyB0byBiZSBkaXNwbGF5ZWQgYXQgb25jZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIG11bHRpcGxlT3BlbmVkOiBmYWxzZSxcblxuICAvKipcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIG1vZGFsIHNob3VsZCBwdXNoIGRvd24gZnJvbSB0aGUgdG9wIG9mIHRoZSBzY3JlZW4uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XG4gICAqIEBkZWZhdWx0IGF1dG9cbiAgICovXG4gIHZPZmZzZXQ6ICdhdXRvJyxcblxuICAvKipcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIG1vZGFsIHNob3VsZCBwdXNoIGluIGZyb20gdGhlIHNpZGUgb2YgdGhlIHNjcmVlbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cbiAgICogQGRlZmF1bHQgYXV0b1xuICAgKi9cbiAgaE9mZnNldDogJ2F1dG8nLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGJlIGZ1bGxzY3JlZW4sIGNvbXBsZXRlbHkgYmxvY2tpbmcgb3V0IHRoZSByZXN0IG9mIHRoZSB2aWV3LiBKUyBjaGVja3MgZm9yIHRoaXMgYXMgd2VsbC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGZ1bGxTY3JlZW46IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGdlbmVyYXRlIGFuIG92ZXJsYXkgZGl2LCB3aGljaCB3aWxsIGNvdmVyIHRoZSB2aWV3IHdoZW4gbW9kYWwgb3BlbnMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIG92ZXJsYXk6IHRydWUsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gcmVtb3ZlIGFuZCByZWluamVjdCBtYXJrdXAgb24gY2xvc2UuIFNob3VsZCBiZSB0cnVlIGlmIHVzaW5nIHZpZGVvIGVsZW1lbnRzIHcvbyB1c2luZyBwcm92aWRlcidzIGFwaSwgb3RoZXJ3aXNlLCB2aWRlb3Mgd2lsbCBjb250aW51ZSB0byBwbGF5IGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVzZXRPbkNsb3NlOiBmYWxzZSxcblxuICAvKipcbiAgICogTGluayB0aGUgbG9jYXRpb24gaGFzaCB0byB0aGUgbW9kYWwuXG4gICAqIFNldCB0aGUgbG9jYXRpb24gaGFzaCB3aGVuIHRoZSBtb2RhbCBpcyBvcGVuZWQvY2xvc2VkLCBhbmQgb3Blbi9jbG9zZSB0aGUgbW9kYWwgd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlZXBMaW5rOiBmYWxzZSxcblxuICAvKipcbiAgICogSWYgYGRlZXBMaW5rYCBpcyBlbmFibGVkLCB1cGRhdGUgdGhlIGJyb3dzZXIgaGlzdG9yeSB3aXRoIHRoZSBvcGVuIG1vZGFsXG4gICAqIEBvcHRpb25cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHVwZGF0ZUhpc3Rvcnk6IGZhbHNlLFxuXG4gIC8qKlxuICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gYXBwZW5kIHRvIGN1c3RvbSBkaXYuXG4gICogQG9wdGlvblxuICAqIEB0eXBlIHtzdHJpbmd9XG4gICogQGRlZmF1bHQgXCJib2R5XCJcbiAgKi9cbiAgYXBwZW5kVG86IFwiYm9keVwiLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYWRkaW5nIGFkZGl0aW9uYWwgY2xhc3MgbmFtZXMgdG8gdGhlIHJldmVhbCBvdmVybGF5LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICBhZGRpdGlvbmFsT3ZlcmxheUNsYXNzZXM6ICcnXG59O1xuXG4vKipcbiAqIFNsaWRlciBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uc2xpZGVyXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxuICovXG5cbnZhciBTbGlkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKFNsaWRlciwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gU2xpZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbGlkZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTbGlkZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNsaWRlciwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgc2xpZGVyIGNvbnRyb2wuXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgU2xpZGVyXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIHNsaWRlciBjb250cm9sLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFNsaWRlci5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU2xpZGVyJzsgLy8gaWU5IGJhY2sgY29tcGF0XG4gICAgICAvLyBUb3VjaCBhbmQgVHJpZ2dlcnMgaW5pdHMgYXJlIGlkZW1wb3RlbnQsIHdlIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQncyBpbml0aWFsaWVkLlxuXG4gICAgICBUb3VjaC5pbml0KCQpO1xuICAgICAgVHJpZ2dlcnMuaW5pdCgkKTtcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICBLZXlib2FyZC5yZWdpc3RlcignU2xpZGVyJywge1xuICAgICAgICAnbHRyJzoge1xuICAgICAgICAgICdBUlJPV19SSUdIVCc6ICdpbmNyZWFzZScsXG4gICAgICAgICAgJ0FSUk9XX1VQJzogJ2luY3JlYXNlJyxcbiAgICAgICAgICAnQVJST1dfRE9XTic6ICdkZWNyZWFzZScsXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAnZGVjcmVhc2UnLFxuICAgICAgICAgICdTSElGVF9BUlJPV19SSUdIVCc6ICdpbmNyZWFzZV9mYXN0JyxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfVVAnOiAnaW5jcmVhc2VfZmFzdCcsXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX0RPV04nOiAnZGVjcmVhc2VfZmFzdCcsXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX0xFRlQnOiAnZGVjcmVhc2VfZmFzdCcsXG4gICAgICAgICAgJ0hPTUUnOiAnbWluJyxcbiAgICAgICAgICAnRU5EJzogJ21heCdcbiAgICAgICAgfSxcbiAgICAgICAgJ3J0bCc6IHtcbiAgICAgICAgICAnQVJST1dfTEVGVCc6ICdpbmNyZWFzZScsXG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ2RlY3JlYXNlJyxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfTEVGVCc6ICdpbmNyZWFzZV9mYXN0JyxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfUklHSFQnOiAnZGVjcmVhc2VfZmFzdCdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpbGl6ZXMgdGhlIHBsdWdpbiBieSByZWFkaW5nL3NldHRpbmcgYXR0cmlidXRlcywgY3JlYXRpbmcgY29sbGVjdGlvbnMgYW5kIHNldHRpbmcgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIGhhbmRsZShzKS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICB0aGlzLmlucHV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKTtcbiAgICAgIHRoaXMuaGFuZGxlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc2xpZGVyLWhhbmRsZV0nKTtcbiAgICAgIHRoaXMuJGhhbmRsZSA9IHRoaXMuaGFuZGxlcy5lcSgwKTtcbiAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy5pbnB1dHMubGVuZ3RoID8gdGhpcy5pbnB1dHMuZXEoMCkgOiAkKFwiI1wiLmNvbmNhdCh0aGlzLiRoYW5kbGUuYXR0cignYXJpYS1jb250cm9scycpKSk7XG4gICAgICB0aGlzLiRmaWxsID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zbGlkZXItZmlsbF0nKS5jc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLCAwKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSAkKCkuYWRkKHRoaXMuJGlucHV0KTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmJpbmRpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRJbml0QXR0cigwKTtcblxuICAgICAgaWYgKHRoaXMuaGFuZGxlc1sxXSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLiRoYW5kbGUyID0gdGhpcy5oYW5kbGVzLmVxKDEpO1xuICAgICAgICB0aGlzLiRpbnB1dDIgPSB0aGlzLmlucHV0cy5sZW5ndGggPiAxID8gdGhpcy5pbnB1dHMuZXEoMSkgOiAkKFwiI1wiLmNvbmNhdCh0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtY29udHJvbHMnKSkpO1xuXG4gICAgICAgIGlmICghdGhpcy5pbnB1dHNbMV0pIHtcbiAgICAgICAgICB0aGlzLmlucHV0cyA9IHRoaXMuaW5wdXRzLmFkZCh0aGlzLiRpbnB1dDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0SW5pdEF0dHIoMSk7XG4gICAgICB9IC8vIFNldCBoYW5kbGUgcG9zaXRpb25zXG5cblxuICAgICAgdGhpcy5zZXRIYW5kbGVzKCk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRIYW5kbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhhbmRsZXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaGFuZGxlc1sxXSkge1xuICAgICAgICB0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLCB0aGlzLmlucHV0cy5lcSgwKS52YWwoKSwgdHJ1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5fc2V0SGFuZGxlUG9zKF90aGlzMi4kaGFuZGxlMiwgX3RoaXMyLmlucHV0cy5lcSgxKS52YWwoKSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSwgdGhpcy5pbnB1dHMuZXEoMCkudmFsKCksIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVmbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XG4gICAgICB0aGlzLnNldEhhbmRsZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBmbG9hdGluZyBwb2ludCAodGhlIHZhbHVlKSB0byBiZSB0cmFuc2Zvcm1lZCB1c2luZyB0byBhIHJlbGF0aXZlIHBvc2l0aW9uIG9uIHRoZSBzbGlkZXIgKHRoZSBpbnZlcnNlIG9mIF92YWx1ZSlcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BjdE9mQmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wY3RPZkJhcih2YWx1ZSkge1xuICAgICAgdmFyIHBjdE9mQmFyID0gcGVyY2VudCh2YWx1ZSAtIHRoaXMub3B0aW9ucy5zdGFydCwgdGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCk7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbikge1xuICAgICAgICBjYXNlIFwicG93XCI6XG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9sb2dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgICBwY3RPZkJhciA9IHRoaXMuX3Bvd1RyYW5zZm9ybShwY3RPZkJhcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwY3RPZkJhci50b0ZpeGVkKDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBwY3RPZkJhciAtIGZsb2F0aW5nIHBvaW50LCB0aGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIHNsaWRlciAodHlwaWNhbGx5IGJldHdlZW4gMC0xKSB0byBiZSB0cmFuc2Zvcm1lZCB0byBhIHZhbHVlXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl92YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsdWUocGN0T2ZCYXIpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbikge1xuICAgICAgICBjYXNlIFwicG93XCI6XG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9wb3dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgICBwY3RPZkJhciA9IHRoaXMuX2xvZ1RyYW5zZm9ybShwY3RPZkJhcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9ICh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAqIHBjdE9mQmFyICsgcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuc3RhcnQpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBsb2cgZnVuY3Rpb25cbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvZ1RyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nVHJhbnNmb3JtKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUxvZyh0aGlzLm9wdGlvbnMubm9uTGluZWFyQmFzZSwgdmFsdWUgKiAodGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UgLSAxKSArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBwb3dlciBmdW5jdGlvblxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcG93VHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb3dUcmFuc2Zvcm0odmFsdWUpIHtcbiAgICAgIHJldHVybiAoTWF0aC5wb3codGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UsIHZhbHVlKSAtIDEpIC8gKHRoaXMub3B0aW9ucy5ub25MaW5lYXJCYXNlIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBoYW5kbGUgYW5kIGZpbGwgYmFyLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRobmRsIC0gdGhlIHNlbGVjdGVkIGhhbmRsZSB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhdGlvbiAtIGZsb2F0aW5nIHBvaW50IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIG9mIHRoZSBzbGlkZXIgYmFyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBvbiBjb21wbGV0aW9uLlxuICAgICAqIEBmaXJlcyBTbGlkZXIjbW92ZWRcbiAgICAgKiBAZmlyZXMgU2xpZGVyI2NoYW5nZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRIYW5kbGVQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEhhbmRsZVBvcygkaG5kbCwgbG9jYXRpb24sIG5vSW52ZXJ0LCBjYikge1xuICAgICAgLy8gZG9uJ3QgbW92ZSBpZiB0aGUgc2xpZGVyIGhhcyBiZWVuIGRpc2FibGVkIHNpbmNlIGl0cyBpbml0aWFsaXphdGlvblxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy9taWdodCBuZWVkIHRvIGFsdGVyIHRoYXQgc2xpZ2h0bHkgZm9yIGJhcnMgdGhhdCB3aWxsIGhhdmUgb2RkIG51bWJlciBzZWxlY3Rpb25zLlxuXG5cbiAgICAgIGxvY2F0aW9uID0gcGFyc2VGbG9hdChsb2NhdGlvbik7IC8vb24gaW5wdXQgY2hhbmdlIGV2ZW50cywgY29udmVydCBzdHJpbmcgdG8gbnVtYmVyLi4uZ3J1bWJsZS5cbiAgICAgIC8vIHByZXZlbnQgc2xpZGVyIGZyb20gcnVubmluZyBvdXQgb2YgYm91bmRzLCBpZiB2YWx1ZSBleGNlZWRzIHRoZSBsaW1pdHMgc2V0IHRocm91Z2ggb3B0aW9ucywgb3ZlcnJpZGUgdGhlIHZhbHVlIHRvIG1pbi9tYXhcblxuICAgICAgaWYgKGxvY2F0aW9uIDwgdGhpcy5vcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLnN0YXJ0O1xuICAgICAgfSBlbHNlIGlmIChsb2NhdGlvbiA+IHRoaXMub3B0aW9ucy5lbmQpIHtcbiAgICAgICAgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuZW5kO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNEYmwgPSB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ7IC8vdGhpcyBpcyBmb3Igc2luZ2xlLWhhbmRsZWQgdmVydGljYWwgc2xpZGVycywgaXQgYWRqdXN0cyB0aGUgdmFsdWUgdG8gYWNjb3VudCBmb3IgdGhlIHNsaWRlciBiZWluZyBcInVwc2lkZS1kb3duXCJcbiAgICAgIC8vZm9yIGNsaWNrIGFuZCBkcmFnIGV2ZW50cywgaXQncyB3ZWlyZCBkdWUgdG8gdGhlIHNjYWxlKC0xLCAxKSBjc3MgcHJvcGVydHlcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCAmJiAhbm9JbnZlcnQpIHtcbiAgICAgICAgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuZW5kIC0gbG9jYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RibCkge1xuICAgICAgICAvL3RoaXMgYmxvY2sgaXMgdG8gcHJldmVudCAyIGhhbmRsZXMgZnJvbSBjcm9zc2luZyBlYWNob3RoZXIuIENvdWxkL3Nob3VsZCBiZSBpbXByb3ZlZC5cbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDApIHtcbiAgICAgICAgICB2YXIgaDJWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZTIuYXR0cignYXJpYS12YWx1ZW5vdycpKTtcbiAgICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uID49IGgyVmFsID8gaDJWYWwgLSB0aGlzLm9wdGlvbnMuc3RlcCA6IGxvY2F0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBoMVZhbCA9IHBhcnNlRmxvYXQodGhpcy4kaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XG4gICAgICAgICAgbG9jYXRpb24gPSBsb2NhdGlvbiA8PSBoMVZhbCA/IGgxVmFsICsgdGhpcy5vcHRpb25zLnN0ZXAgOiBsb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIHZlcnQgPSB0aGlzLm9wdGlvbnMudmVydGljYWwsXG4gICAgICAgICAgaE9yVyA9IHZlcnQgPyAnaGVpZ2h0JyA6ICd3aWR0aCcsXG4gICAgICAgICAgbE9yVCA9IHZlcnQgPyAndG9wJyA6ICdsZWZ0JyxcbiAgICAgICAgICBoYW5kbGVEaW0gPSAkaG5kbFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtoT3JXXSxcbiAgICAgICAgICBlbGVtRGltID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtoT3JXXSxcbiAgICAgICAgICAvL3BlcmNlbnRhZ2Ugb2YgYmFyIG1pbi9tYXggdmFsdWUgYmFzZWQgb24gY2xpY2sgb3IgZHJhZyBwb2ludFxuICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9wY3RPZkJhcihsb2NhdGlvbiksXG4gICAgICAgICAgLy9udW1iZXIgb2YgYWN0dWFsIHBpeGVscyB0byBzaGlmdCB0aGUgaGFuZGxlLCBiYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBvYnRhaW5lZCBhYm92ZVxuICAgICAgcHhUb01vdmUgPSAoZWxlbURpbSAtIGhhbmRsZURpbSkgKiBwY3RPZkJhcixcbiAgICAgICAgICAvL3BlcmNlbnRhZ2Ugb2YgYmFyIHRvIHNoaWZ0IHRoZSBoYW5kbGVcbiAgICAgIG1vdmVtZW50ID0gKHBlcmNlbnQocHhUb01vdmUsIGVsZW1EaW0pICogMTAwKS50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKTsgLy9maXhpbmcgdGhlIGRlY2ltYWwgdmFsdWUgZm9yIHRoZSBsb2NhdGlvbiBudW1iZXIsIGlzIHBhc3NlZCB0byBvdGhlciBtZXRob2RzIGFzIGEgZml4ZWQgZmxvYXRpbmctcG9pbnQgdmFsdWVcblxuXG4gICAgICBsb2NhdGlvbiA9IHBhcnNlRmxvYXQobG9jYXRpb24udG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCkpOyAvLyBkZWNsYXJlIGVtcHR5IG9iamVjdCBmb3IgY3NzIGFkanVzdG1lbnRzLCBvbmx5IHVzZWQgd2l0aCAyIGhhbmRsZWQtc2xpZGVyc1xuXG4gICAgICB2YXIgY3NzID0ge307XG5cbiAgICAgIHRoaXMuX3NldFZhbHVlcygkaG5kbCwgbG9jYXRpb24pOyAvLyBUT0RPIHVwZGF0ZSB0byBjYWxjdWxhdGUgYmFzZWQgb24gdmFsdWVzIHNldCB0byByZXNwZWN0aXZlIGlucHV0cz8/XG5cblxuICAgICAgaWYgKGlzRGJsKSB7XG4gICAgICAgIHZhciBpc0xlZnRIbmRsID0gdGhpcy5oYW5kbGVzLmluZGV4KCRobmRsKSA9PT0gMCxcbiAgICAgICAgICAgIC8vZW1wdHkgdmFyaWFibGUsIHdpbGwgYmUgdXNlZCBmb3IgbWluLWhlaWdodC93aWR0aCBmb3IgZmlsbCBiYXJcbiAgICAgICAgZGltLFxuICAgICAgICAgICAgLy9wZXJjZW50YWdlIHcvaCBvZiB0aGUgaGFuZGxlIGNvbXBhcmVkIHRvIHRoZSBzbGlkZXIgYmFyXG4gICAgICAgIGhhbmRsZVBjdCA9IH5+KHBlcmNlbnQoaGFuZGxlRGltLCBlbGVtRGltKSAqIDEwMCk7IC8vaWYgbGVmdCBoYW5kbGUsIHRoZSBtYXRoIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGlmIGl0J3MgdGhlIHJpZ2h0IGhhbmRsZSwgYW5kIHRoZSBsZWZ0L3RvcCBwcm9wZXJ0eSBuZWVkcyB0byBiZSBjaGFuZ2VkIGZvciB0aGUgZmlsbCBiYXJcblxuICAgICAgICBpZiAoaXNMZWZ0SG5kbCkge1xuICAgICAgICAgIC8vbGVmdCBvciB0b3AgcGVyY2VudGFnZSB2YWx1ZSB0byBhcHBseSB0byB0aGUgZmlsbCBiYXIuXG4gICAgICAgICAgY3NzW2xPclRdID0gXCJcIi5jb25jYXQobW92ZW1lbnQsIFwiJVwiKTsgLy9jYWxjdWxhdGUgdGhlIG5ldyBtaW4taGVpZ2h0L3dpZHRoIGZvciB0aGUgZmlsbCBiYXIuXG5cbiAgICAgICAgICBkaW0gPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZTJbMF0uc3R5bGVbbE9yVF0pIC0gbW92ZW1lbnQgKyBoYW5kbGVQY3Q7IC8vdGhpcyBjYWxsYmFjayBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCBlcnJvcnMgYW5kIGFsbG93IHRoZSBwcm9wZXIgcGxhY2VtZW50IGFuZCBpbml0aWFsaXphdGlvbiBvZiBhIDItaGFuZGxlZCBzbGlkZXJcbiAgICAgICAgICAvL3BsdXMsIGl0IG1lYW5zIHdlIGRvbid0IGNhcmUgaWYgJ2RpbScgaXNOYU4gb24gaW5pdCwgaXQgd29uJ3QgYmUgaW4gdGhlIGZ1dHVyZS5cblxuICAgICAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfSAvL3RoaXMgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsaXphdGlvbiBvZiAyIGhhbmRsZWQgc2xpZGVyc1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9qdXN0IGNhY2hpbmcgdGhlIHZhbHVlIG9mIHRoZSBsZWZ0L2JvdHRvbSBoYW5kbGUncyBsZWZ0L3RvcCBwcm9wZXJ0eVxuICAgICAgICAgIHZhciBoYW5kbGVQb3MgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZVswXS5zdHlsZVtsT3JUXSk7IC8vY2FsY3VsYXRlIHRoZSBuZXcgbWluLWhlaWdodC93aWR0aCBmb3IgdGhlIGZpbGwgYmFyLiBVc2UgaXNOYU4gdG8gcHJldmVudCBmYWxzZSBwb3NpdGl2ZXMgZm9yIG51bWJlcnMgPD0gMFxuICAgICAgICAgIC8vYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2Ugb2YgbW92ZW1lbnQgb2YgdGhlIGhhbmRsZSBiZWluZyBtYW5pcHVsYXRlZCwgbGVzcyB0aGUgb3Bwb3NpbmcgaGFuZGxlJ3MgbGVmdC90b3AgcG9zaXRpb24sIHBsdXMgdGhlIHBlcmNlbnRhZ2Ugdy9oIG9mIHRoZSBoYW5kbGUgaXRzZWxmXG5cbiAgICAgICAgICBkaW0gPSBtb3ZlbWVudCAtIChpc05hTihoYW5kbGVQb3MpID8gKHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpIC8gKCh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAvIDEwMCkgOiBoYW5kbGVQb3MpICsgaGFuZGxlUGN0O1xuICAgICAgICB9IC8vIGFzc2lnbiB0aGUgbWluLWhlaWdodC93aWR0aCB0byBvdXIgY3NzIG9iamVjdFxuXG5cbiAgICAgICAgY3NzW1wibWluLVwiLmNvbmNhdChoT3JXKV0gPSBcIlwiLmNvbmNhdChkaW0sIFwiJVwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5vbmUoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoYW5kbGUgaXMgZG9uZSBtb3ZpbmcuXG4gICAgICAgICAqIEBldmVudCBTbGlkZXIjbW92ZWRcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ21vdmVkLnpmLnNsaWRlcicsIFskaG5kbF0pO1xuICAgICAgfSk7IC8vYmVjYXVzZSB3ZSBkb24ndCBrbm93IGV4YWN0bHkgaG93IHRoZSBoYW5kbGUgd2lsbCBiZSBtb3ZlZCwgY2hlY2sgdGhlIGFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIG1vdmUuXG5cbiAgICAgIHZhciBtb3ZlVGltZSA9IHRoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnKSA/IDEwMDAgLyA2MCA6IHRoaXMub3B0aW9ucy5tb3ZlVGltZTtcbiAgICAgIE1vdmUobW92ZVRpbWUsICRobmRsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGFkanVzdGluZyB0aGUgbGVmdC90b3AgcHJvcGVydHkgb2YgdGhlIGhhbmRsZSwgYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2UgY2FsY3VsYXRlZCBhYm92ZVxuICAgICAgICAvLyBpZiBtb3ZlbWVudCBpc05hTiwgdGhhdCBpcyBiZWNhdXNlIHRoZSBzbGlkZXIgaXMgaGlkZGVuIGFuZCB3ZSBjYW5ub3QgZGV0ZXJtaW5lIGhhbmRsZSB3aWR0aCxcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIG5leHQgYmVzdCBndWVzcy5cbiAgICAgICAgaWYgKGlzTmFOKG1vdmVtZW50KSkge1xuICAgICAgICAgICRobmRsLmNzcyhsT3JULCBcIlwiLmNvbmNhdChwY3RPZkJhciAqIDEwMCwgXCIlXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkaG5kbC5jc3MobE9yVCwgXCJcIi5jb25jYXQobW92ZW1lbnQsIFwiJVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQpIHtcbiAgICAgICAgICAvL2lmIHNpbmdsZS1oYW5kbGVkLCBhIHNpbXBsZSBtZXRob2QgdG8gZXhwYW5kIHRoZSBmaWxsIGJhclxuICAgICAgICAgIF90aGlzLiRmaWxsLmNzcyhoT3JXLCBcIlwiLmNvbmNhdChwY3RPZkJhciAqIDEwMCwgXCIlXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL290aGVyd2lzZSwgdXNlIHRoZSBjc3Mgb2JqZWN0IHdlIGNyZWF0ZWQgYWJvdmVcbiAgICAgICAgICBfdGhpcy4kZmlsbC5jc3MoY3NzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjaGFuZ2UgZm9yIGEgZ2l2ZW4gdGltZS5cbiAgICAgICAqIEBldmVudCBTbGlkZXIjY2hhbmdlZFxuICAgICAgICovXG5cbiAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlZC56Zi5zbGlkZXInLCBbJGhuZGxdKTtcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMuY2hhbmdlZERlbGF5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5pdGlhbCBhdHRyaWJ1dGUgZm9yIHRoZSBzbGlkZXIgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSBpbmRleCBvZiB0aGUgY3VycmVudCBoYW5kbGUvaW5wdXQgdG8gdXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEluaXRBdHRyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRJbml0QXR0cihpZHgpIHtcbiAgICAgIHZhciBpbml0VmFsID0gaWR4ID09PSAwID8gdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCA6IHRoaXMub3B0aW9ucy5pbml0aWFsRW5kO1xuICAgICAgdmFyIGlkID0gdGhpcy5pbnB1dHMuZXEoaWR4KS5hdHRyKCdpZCcpIHx8IEdldFlvRGlnaXRzKDYsICdzbGlkZXInKTtcbiAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkuYXR0cih7XG4gICAgICAgICdpZCc6IGlkLFxuICAgICAgICAnbWF4JzogdGhpcy5vcHRpb25zLmVuZCxcbiAgICAgICAgJ21pbic6IHRoaXMub3B0aW9ucy5zdGFydCxcbiAgICAgICAgJ3N0ZXAnOiB0aGlzLm9wdGlvbnMuc3RlcFxuICAgICAgfSk7XG4gICAgICB0aGlzLmlucHV0cy5lcShpZHgpLnZhbChpbml0VmFsKTtcbiAgICAgIHRoaXMuaGFuZGxlcy5lcShpZHgpLmF0dHIoe1xuICAgICAgICAncm9sZSc6ICdzbGlkZXInLFxuICAgICAgICAnYXJpYS1jb250cm9scyc6IGlkLFxuICAgICAgICAnYXJpYS12YWx1ZW1heCc6IHRoaXMub3B0aW9ucy5lbmQsXG4gICAgICAgICdhcmlhLXZhbHVlbWluJzogdGhpcy5vcHRpb25zLnN0YXJ0LFxuICAgICAgICAnYXJpYS12YWx1ZW5vdyc6IGluaXRWYWwsXG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogdGhpcy5vcHRpb25zLnZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcbiAgICAgICAgJ3RhYmluZGV4JzogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGlucHV0IGFuZCBgYXJpYS12YWx1ZW5vd2AgdmFsdWVzIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaGFuZGxlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSBmbG9hdGluZyBwb2ludCBvZiB0aGUgbmV3IHZhbHVlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVzKCRoYW5kbGUsIHZhbCkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA/IHRoaXMuaGFuZGxlcy5pbmRleCgkaGFuZGxlKSA6IDA7XG4gICAgICB0aGlzLmlucHV0cy5lcShpZHgpLnZhbCh2YWwpO1xuICAgICAgJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JywgdmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBldmVudHMgb24gdGhlIHNsaWRlciBlbGVtZW50LlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG5ldyBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCBoYW5kbGUuXG4gICAgICogSWYgdGhlcmUgYXJlIHR3byBoYW5kbGVzIGFuZCB0aGUgYmFyIHdhcyBjbGlja2VkLCBpdCBkZXRlcm1pbmVzIHdoaWNoIGhhbmRsZSB0byBtb3ZlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgLSB0aGUgYGV2ZW50YCBvYmplY3QgcGFzc2VkIGZyb20gdGhlIGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnQgaGFuZGxlIHRvIGNhbGN1bGF0ZSBmb3IsIGlmIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSBmbG9hdGluZyBwb2ludCBudW1iZXIgZm9yIHRoZSBuZXcgdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICAgKiBUT0RPIGNsZWFuIHRoaXMgdXAsIHRoZXJlJ3MgYSBsb3Qgb2YgcmVwZWF0ZWQgY29kZSBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBfc2V0SGFuZGxlUG9zIGZuLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVFdmVudChlLCAkaGFuZGxlLCB2YWwpIHtcbiAgICAgIHZhciB2YWx1ZSwgaGFzVmFsO1xuXG4gICAgICBpZiAoIXZhbCkge1xuICAgICAgICAvL2NsaWNrIG9yIGRyYWcgZXZlbnRzXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgdmVydGljYWwgPSB0aGlzLm9wdGlvbnMudmVydGljYWwsXG4gICAgICAgICAgICBwYXJhbSA9IHZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGV2ZW50T2Zmc2V0ID0gdmVydGljYWwgPyBlLnBhZ2VZIDogZS5wYWdlWCxcbiAgICAgICAgICAgIGhhbGZPZkhhbmRsZSA9IHRoaXMuJGhhbmRsZVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0gLyAyLFxuICAgICAgICAgICAgYmFyRGltID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0sXG4gICAgICAgICAgICB3aW5kb3dTY3JvbGwgPSB2ZXJ0aWNhbCA/ICQod2luZG93KS5zY3JvbGxUb3AoKSA6ICQod2luZG93KS5zY3JvbGxMZWZ0KCk7XG5cbiAgICAgICAgdmFyIGVsZW1PZmZzZXQgPSB0aGlzLiRlbGVtZW50Lm9mZnNldCgpW2RpcmVjdGlvbl07IC8vIHRvdWNoIGV2ZW50cyBlbXVsYXRlZCBieSB0aGUgdG91Y2ggdXRpbCBnaXZlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHNjcmVlbiwgYWRkIHdpbmRvdy5zY3JvbGwgdG8gZXZlbnQgY29vcmRpbmF0ZXMuLi5cbiAgICAgICAgLy8gYmVzdCB3YXkgdG8gZ3Vlc3MgdGhpcyBpcyBzaW11bGF0ZWQgaXMgaWYgY2xpZW50WSA9PSBwYWdlWVxuXG4gICAgICAgIGlmIChlLmNsaWVudFkgPT09IGUucGFnZVkpIHtcbiAgICAgICAgICBldmVudE9mZnNldCA9IGV2ZW50T2Zmc2V0ICsgd2luZG93U2Nyb2xsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50RnJvbUJhciA9IGV2ZW50T2Zmc2V0IC0gZWxlbU9mZnNldDtcbiAgICAgICAgdmFyIGJhclhZO1xuXG4gICAgICAgIGlmIChldmVudEZyb21CYXIgPCAwKSB7XG4gICAgICAgICAgYmFyWFkgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50RnJvbUJhciA+IGJhckRpbSkge1xuICAgICAgICAgIGJhclhZID0gYmFyRGltO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhclhZID0gZXZlbnRGcm9tQmFyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldFBjdCA9IHBlcmNlbnQoYmFyWFksIGJhckRpbSk7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fdmFsdWUob2Zmc2V0UGN0KTsgLy8gdHVybiBldmVyeXRoaW5nIGFyb3VuZCBmb3IgUlRMLCB5YXkgbWF0aCFcblxuICAgICAgICBpZiAocnRsKCkgJiYgIXRoaXMub3B0aW9ucy52ZXJ0aWNhbCkge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zLmVuZCAtIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBfdGhpcy5fYWRqdXN0VmFsdWUobnVsbCwgdmFsdWUpOyAvL2Jvb2xlYW4gZmxhZyBmb3IgdGhlIHNldEhhbmRsZVBvcyBmbiwgc3BlY2lmaWNhbGx5IGZvciB2ZXJ0aWNhbCBzbGlkZXJzXG5cbiAgICAgICAgaGFzVmFsID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCEkaGFuZGxlKSB7XG4gICAgICAgICAgLy9maWd1cmUgb3V0IHdoaWNoIGhhbmRsZSBpdCBpcywgcGFzcyBpdCB0byB0aGUgbmV4dCBmdW5jdGlvbi5cbiAgICAgICAgICB2YXIgZmlyc3RIbmRsUG9zID0gYWJzUG9zaXRpb24odGhpcy4kaGFuZGxlLCBkaXJlY3Rpb24sIGJhclhZLCBwYXJhbSksXG4gICAgICAgICAgICAgIHNlY25kSG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZTIsIGRpcmVjdGlvbiwgYmFyWFksIHBhcmFtKTtcbiAgICAgICAgICAkaGFuZGxlID0gZmlyc3RIbmRsUG9zIDw9IHNlY25kSG5kbFBvcyA/IHRoaXMuJGhhbmRsZSA6IHRoaXMuJGhhbmRsZTI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vY2hhbmdlIGV2ZW50IG9uIGlucHV0XG4gICAgICAgIHZhbHVlID0gdGhpcy5fYWRqdXN0VmFsdWUobnVsbCwgdmFsKTtcbiAgICAgICAgaGFzVmFsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKCRoYW5kbGUsIHZhbHVlLCBoYXNWYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3RlcyB2YWx1ZSBmb3IgaGFuZGxlIGluIHJlZ2FyZCB0byBzdGVwIHZhbHVlLiByZXR1cm5zIGFkanVzdGVkIHZhbHVlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBzZWxlY3RlZCBoYW5kbGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdmFsdWUgdG8gYWRqdXN0LiB1c2VkIGlmICRoYW5kbGUgaXMgZmFsc3lcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGp1c3RWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRqdXN0VmFsdWUoJGhhbmRsZSwgdmFsdWUpIHtcbiAgICAgIHZhciB2YWwsXG4gICAgICAgICAgc3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwLFxuICAgICAgICAgIGRpdiA9IHBhcnNlRmxvYXQoc3RlcCAvIDIpLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcHJldl92YWwsXG4gICAgICAgICAgbmV4dF92YWw7XG5cbiAgICAgIGlmICghISRoYW5kbGUpIHtcbiAgICAgICAgdmFsID0gcGFyc2VGbG9hdCgkaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbCA+PSAwKSB7XG4gICAgICAgIGxlZnQgPSB2YWwgJSBzdGVwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IHN0ZXAgKyB2YWwgJSBzdGVwO1xuICAgICAgfVxuXG4gICAgICBwcmV2X3ZhbCA9IHZhbCAtIGxlZnQ7XG4gICAgICBuZXh0X3ZhbCA9IHByZXZfdmFsICsgc3RlcDtcblxuICAgICAgaWYgKGxlZnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cblxuICAgICAgdmFsID0gdmFsID49IHByZXZfdmFsICsgZGl2ID8gbmV4dF92YWwgOiBwcmV2X3ZhbDtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzbGlkZXIgZWxlbWVudHMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHRoaXMuX2V2ZW50c0ZvckhhbmRsZSh0aGlzLiRoYW5kbGUpO1xuXG4gICAgICBpZiAodGhpcy5oYW5kbGVzWzFdKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c0ZvckhhbmRsZSh0aGlzLiRoYW5kbGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgYSBwYXJ0aWN1bGFyIGhhbmRsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgY3VycmVudCBoYW5kbGUgdG8gYXBwbHkgbGlzdGVuZXJzIHRvLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c0ZvckhhbmRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzRm9ySGFuZGxlKCRoYW5kbGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgY3VySGFuZGxlO1xuXG4gICAgICB2YXIgaGFuZGxlQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VFdmVudChlKSB7XG4gICAgICAgIHZhciBpZHggPSBfdGhpcy5pbnB1dHMuaW5kZXgoJCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIF90aGlzLmhhbmRsZXMuZXEoaWR4KSwgJCh0aGlzKS52YWwoKSk7XG4gICAgICB9OyAvLyBJRSBvbmx5IHRyaWdnZXJzIHRoZSBjaGFuZ2UgZXZlbnQgd2hlbiB0aGUgaW5wdXQgbG9zZXMgZm9jdXMgd2hpY2ggc3RyaWN0bHkgZm9sbG93cyB0aGUgSFRNTCBzcGVjaWZpY2F0aW9uXG4gICAgICAvLyBsaXN0ZW4gZm9yIHRoZSBlbnRlciBrZXkgYW5kIHRyaWdnZXIgYSBjaGFuZ2VcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCNjb21tb24taW5wdXQtZWxlbWVudC1ldmVudHNcblxuXG4gICAgICB0aGlzLmlucHV0cy5vZmYoJ2tleXVwLnpmLnNsaWRlcicpLm9uKCdrZXl1cC56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKSBoYW5kbGVDaGFuZ2VFdmVudC5jYWxsKHRoaXMsIGUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmlucHV0cy5vZmYoJ2NoYW5nZS56Zi5zbGlkZXInKS5vbignY2hhbmdlLnpmLnNsaWRlcicsIGhhbmRsZUNoYW5nZUV2ZW50KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja1NlbGVjdCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYuc2xpZGVyJykub24oJ2NsaWNrLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoISQoZS50YXJnZXQpLmlzKCdbZGF0YS1zbGlkZXItaGFuZGxlXScpKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xuICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgX3RoaXMuJGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVzLmFkZFRvdWNoKCk7XG4gICAgICAgIHZhciAkYm9keSA9ICQoJ2JvZHknKTtcbiAgICAgICAgJGhhbmRsZS5vZmYoJ21vdXNlZG93bi56Zi5zbGlkZXInKS5vbignbW91c2Vkb3duLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgJGhhbmRsZS5hZGRDbGFzcygnaXMtZHJhZ2dpbmcnKTtcblxuICAgICAgICAgIF90aGlzLiRmaWxsLmFkZENsYXNzKCdpcy1kcmFnZ2luZycpOyAvL1xuXG5cbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycsIHRydWUpO1xuXG4gICAgICAgICAgY3VySGFuZGxlID0gJChlLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICRib2R5Lm9uKCdtb3VzZW1vdmUuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XG4gICAgICAgICAgfSkub24oJ21vdXNldXAuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBjdXJIYW5kbGUpO1xuXG4gICAgICAgICAgICAkaGFuZGxlLnJlbW92ZUNsYXNzKCdpcy1kcmFnZ2luZycpO1xuXG4gICAgICAgICAgICBfdGhpcy4kZmlsbC5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcblxuICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICRib2R5Lm9mZignbW91c2Vtb3ZlLnpmLnNsaWRlciBtb3VzZXVwLnpmLnNsaWRlcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSAvLyBwcmV2ZW50IGV2ZW50cyB0cmlnZ2VyZWQgYnkgdG91Y2hcbiAgICAgICAgLm9uKCdzZWxlY3RzdGFydC56Zi5zbGlkZXIgdG91Y2htb3ZlLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgJGhhbmRsZS5vZmYoJ2tleWRvd24uemYuc2xpZGVyJykub24oJ2tleWRvd24uemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF8kaGFuZGxlID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGlkeCA9IF90aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQgPyBfdGhpcy5oYW5kbGVzLmluZGV4KF8kaGFuZGxlKSA6IDAsXG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHBhcnNlRmxvYXQoX3RoaXMuaW5wdXRzLmVxKGlkeCkudmFsKCkpLFxuICAgICAgICAgICAgbmV3VmFsdWU7IC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcblxuXG4gICAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnU2xpZGVyJywge1xuICAgICAgICAgIGRlY3JlYXNlOiBmdW5jdGlvbiBkZWNyZWFzZSgpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgLSBfdGhpcy5vcHRpb25zLnN0ZXA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmNyZWFzZTogZnVuY3Rpb24gaW5jcmVhc2UoKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVjcmVhc2VfZmFzdDogZnVuY3Rpb24gZGVjcmVhc2VfZmFzdCgpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgLSBfdGhpcy5vcHRpb25zLnN0ZXAgKiAxMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluY3JlYXNlX2Zhc3Q6IGZ1bmN0aW9uIGluY3JlYXNlX2Zhc3QoKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtaW46IGZ1bmN0aW9uIG1pbigpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gX3RoaXMub3B0aW9ucy5zdGFydDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1heDogZnVuY3Rpb24gbWF4KCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfdGhpcy5vcHRpb25zLmVuZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQoKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHNldCBoYW5kbGUgcG9zIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWQgc3BlY2lhbGx5XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIF90aGlzLl9zZXRIYW5kbGVQb3MoXyRoYW5kbGUsIG5ld1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvKmlmIChuZXdWYWx1ZSkgeyAvLyBpZiBwcmVzc2VkIGtleSBoYXMgc3BlY2lhbCBmdW5jdGlvbiwgdXBkYXRlIHZhbHVlXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIF90aGlzLl9zZXRIYW5kbGVQb3MoXyRoYW5kbGUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfSovXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIHNsaWRlciBwbHVnaW4uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuaGFuZGxlcy5vZmYoJy56Zi5zbGlkZXInKTtcbiAgICAgIHRoaXMuaW5wdXRzLm9mZignLnpmLnNsaWRlcicpO1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5zbGlkZXInKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbGlkZXI7XG59KFBsdWdpbik7XG5cblNsaWRlci5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIE1pbmltdW0gdmFsdWUgZm9yIHRoZSBzbGlkZXIgc2NhbGUuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgc3RhcnQ6IDAsXG5cbiAgLyoqXG4gICAqIE1heGltdW0gdmFsdWUgZm9yIHRoZSBzbGlkZXIgc2NhbGUuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMTAwXG4gICAqL1xuICBlbmQ6IDEwMCxcblxuICAvKipcbiAgICogTWluaW11bSB2YWx1ZSBjaGFuZ2UgcGVyIGNoYW5nZSBldmVudC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBzdGVwOiAxLFxuXG4gIC8qKlxuICAgKiBWYWx1ZSBhdCB3aGljaCB0aGUgaGFuZGxlL2lucHV0ICoobGVmdCBoYW5kbGUvZmlyc3QgaW5wdXQpKiBzaG91bGQgYmUgc2V0IHRvIG9uIGluaXRpYWxpemF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGluaXRpYWxTdGFydDogMCxcblxuICAvKipcbiAgICogVmFsdWUgYXQgd2hpY2ggdGhlIHJpZ2h0IGhhbmRsZS9zZWNvbmQgaW5wdXQgc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMDBcbiAgICovXG4gIGluaXRpYWxFbmQ6IDEwMCxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSBpbnB1dCB0byBiZSBsb2NhdGVkIG91dHNpZGUgdGhlIGNvbnRhaW5lciBhbmQgdmlzaWJsZS4gU2V0IHRvIGJ5IHRoZSBKU1xuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYmluZGluZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgdXNlciB0byBjbGljay90YXAgb24gdGhlIHNsaWRlciBiYXIgdG8gc2VsZWN0IGEgdmFsdWUuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGNsaWNrU2VsZWN0OiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBhbmQgdXNlIHRoZSBgdmVydGljYWxgIGNsYXNzIHRvIGNoYW5nZSBhbGlnbm1lbnQgdG8gdmVydGljYWwuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB2ZXJ0aWNhbDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgdXNlciB0byBkcmFnIHRoZSBzbGlkZXIgaGFuZGxlKHMpIHRvIHNlbGVjdCBhIHZhbHVlLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBkcmFnZ2FibGU6IHRydWUsXG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBzbGlkZXIgYW5kIHByZXZlbnRzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGJlaW5nIGFwcGxpZWQuIERvdWJsZSBjaGVja2VkIGJ5IEpTIHdpdGggYGRpc2FibGVkQ2xhc3NgLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIHVzZSBvZiB0d28gaGFuZGxlcy4gRG91YmxlIGNoZWNrZWQgYnkgdGhlIEpTLiBDaGFuZ2VzIHNvbWUgbG9naWMgaGFuZGxpbmcuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkb3VibGVTaWRlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZS5cbiAgICovXG4gIC8vIHN0ZXBzOiAxMDAsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGUgcGx1Z2luIHNob3VsZCBnbyB0byBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDJcbiAgICovXG4gIGRlY2ltYWw6IDIsXG5cbiAgLyoqXG4gICAqIFRpbWUgZGVsYXkgZm9yIGRyYWdnZWQgZWxlbWVudHMuXG4gICAqL1xuICAvLyBkcmFnRGVsYXk6IDAsXG5cbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCB0byBhbmltYXRlIHRoZSBtb3ZlbWVudCBvZiBhIHNsaWRlciBoYW5kbGUgaWYgdXNlciBjbGlja3MvdGFwcyBvbiB0aGUgYmFyLiBOZWVkcyB0byBiZSBtYW51YWxseSBzZXQgaWYgdXBkYXRpbmcgdGhlIHRyYW5zaXRpb24gdGltZSBpbiB0aGUgU2FzcyBzZXR0aW5ncy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAyMDBcbiAgICovXG4gIG1vdmVUaW1lOiAyMDAsXG4gIC8vdXBkYXRlIHRoaXMgaWYgY2hhbmdpbmcgdGhlIHRyYW5zaXRpb24gdGltZSBpbiB0aGUgc2Fzc1xuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIGRpc2FibGVkIHNsaWRlcnMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2Rpc2FibGVkJ1xuICAgKi9cbiAgZGlzYWJsZWRDbGFzczogJ2Rpc2FibGVkJyxcblxuICAvKipcbiAgICogV2lsbCBpbnZlcnQgdGhlIGRlZmF1bHQgbGF5b3V0IGZvciBhIHZlcnRpY2FsPHNwYW4gZGF0YS10b29sdGlwIHRpdGxlPVwid2hvIHdvdWxkIGRvIHRoaXM/Pz9cIj4gPC9zcGFuPnNsaWRlci5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGludmVydFZlcnRpY2FsOiBmYWxzZSxcblxuICAvKipcbiAgICogTWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgYGNoYW5nZWQuemYtc2xpZGVyYCBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdmFsdWUgY2hhbmdlLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDUwMFxuICAgKi9cbiAgY2hhbmdlZERlbGF5OiA1MDAsXG5cbiAgLyoqXG4gICogQmFzZXZhbHVlIGZvciBub24tbGluZWFyIHNsaWRlcnNcbiAgKiBAb3B0aW9uXG4gICogQHR5cGUge251bWJlcn1cbiAgKiBAZGVmYXVsdCA1XG4gICovXG4gIG5vbkxpbmVhckJhc2U6IDUsXG5cbiAgLyoqXG4gICogQmFzZXZhbHVlIGZvciBub24tbGluZWFyIHNsaWRlcnMsIHBvc3NpYmxlIHZhbHVlcyBhcmU6IGAnbGluZWFyJ2AsIGAncG93J2AgJiBgJ2xvZydgLiBQb3cgYW5kIExvZyB1c2UgdGhlIG5vbkxpbmVhckJhc2Ugc2V0dGluZy5cbiAgKiBAb3B0aW9uXG4gICogQHR5cGUge3N0cmluZ31cbiAgKiBAZGVmYXVsdCAnbGluZWFyJ1xuICAqL1xuICBwb3NpdGlvblZhbHVlRnVuY3Rpb246ICdsaW5lYXInXG59O1xuXG5mdW5jdGlvbiBwZXJjZW50KGZyYWMsIG51bSkge1xuICByZXR1cm4gZnJhYyAvIG51bTtcbn1cblxuZnVuY3Rpb24gYWJzUG9zaXRpb24oJGhhbmRsZSwgZGlyLCBjbGlja1BvcywgcGFyYW0pIHtcbiAgcmV0dXJuIE1hdGguYWJzKCRoYW5kbGUucG9zaXRpb24oKVtkaXJdICsgJGhhbmRsZVtwYXJhbV0oKSAvIDIgLSBjbGlja1Bvcyk7XG59XG5cbmZ1bmN0aW9uIGJhc2VMb2coYmFzZSwgdmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubG9nKHZhbHVlKSAvIE1hdGgubG9nKGJhc2UpO1xufVxuXG4vKipcbiAqIFN0aWNreSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uc3RpY2t5XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqL1xuXG52YXIgU3RpY2t5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhTdGlja3ksIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIFN0aWNreSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RpY2t5KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoU3RpY2t5KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdGlja3ksIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHN0aWNreSB0aGluZy5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBTdGlja3lcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBzdGlja3kuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIG9iamVjdCBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgZWxlbWVudCBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgU3RpY2t5LmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdTdGlja3knOyAvLyBpZTkgYmFjayBjb21wYXRcbiAgICAgIC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxuXG4gICAgICBUcmlnZ2Vycy5pbml0KCQpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBzdGlja3kgZWxlbWVudCBieSBhZGRpbmcgY2xhc3NlcywgZ2V0dGluZy9zZXR0aW5nIGRpbWVuc2lvbnMsIGJyZWFrcG9pbnRzIGFuZCBhdHRyaWJ1dGVzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgTWVkaWFRdWVyeS5faW5pdCgpO1xuXG4gICAgICB2YXIgJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdGlja3ktY29udGFpbmVyXScpLFxuICAgICAgICAgIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBHZXRZb0RpZ2l0cyg2LCAnc3RpY2t5JyksXG4gICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoJHBhcmVudC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJHBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud2FzV3JhcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcyk7XG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcykuYXR0cih7XG4gICAgICAgICdkYXRhLXJlc2l6ZSc6IGlkLFxuICAgICAgICAnZGF0YS1tdXRhdGUnOiBpZFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5jaG9yICE9PSAnJykge1xuICAgICAgICAkKCcjJyArIF90aGlzLm9wdGlvbnMuYW5jaG9yKS5hdHRyKHtcbiAgICAgICAgICAnZGF0YS1tdXRhdGUnOiBpZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGxDb3VudCA9IHRoaXMub3B0aW9ucy5jaGVja0V2ZXJ5O1xuICAgICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XG4gICAgICB0aGlzLm9uTG9hZExpc3RlbmVyID0gb25Mb2FkKCQod2luZG93KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvL1dlIGNhbGN1bGF0ZSB0aGUgY29udGFpbmVyIGhlaWdodCB0byBoYXZlIGNvcnJlY3QgdmFsdWVzIGZvciBhbmNob3IgcG9pbnRzIG9mZnNldCBjYWxjdWxhdGlvbi5cbiAgICAgICAgX3RoaXMuY29udGFpbmVySGVpZ2h0ID0gX3RoaXMuJGVsZW1lbnQuY3NzKFwiZGlzcGxheVwiKSA9PSBcIm5vbmVcIiA/IDAgOiBfdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG5cbiAgICAgICAgX3RoaXMuJGNvbnRhaW5lci5jc3MoJ2hlaWdodCcsIF90aGlzLmNvbnRhaW5lckhlaWdodCk7XG5cbiAgICAgICAgX3RoaXMuZWxlbUhlaWdodCA9IF90aGlzLmNvbnRhaW5lckhlaWdodDtcblxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hbmNob3IgIT09ICcnKSB7XG4gICAgICAgICAgX3RoaXMuJGFuY2hvciA9ICQoJyMnICsgX3RoaXMub3B0aW9ucy5hbmNob3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9wYXJzZVBvaW50cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc2Nyb2xsID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuXG4gICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHNjcm9sbCk7IC8vVW5zdGljayB0aGUgZWxlbWVudCB3aWxsIGVuc3VyZSB0aGF0IHByb3BlciBjbGFzc2VzIGFyZSBzZXQuXG5cblxuICAgICAgICAgIGlmICghX3RoaXMuaXNTdHVjaykge1xuICAgICAgICAgICAgX3RoaXMuX3JlbW92ZVN0aWNreShzY3JvbGwgPj0gX3RoaXMudG9wUG9pbnQgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX3RoaXMuX2V2ZW50cyhpZC5zcGxpdCgnLScpLnJldmVyc2UoKS5qb2luKCctJykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHVzaW5nIG11bHRpcGxlIGVsZW1lbnRzIGFzIGFuY2hvcnMsIGNhbGN1bGF0ZXMgdGhlIHRvcCBhbmQgYm90dG9tIHBpeGVsIHZhbHVlcyB0aGUgc3RpY2t5IHRoaW5nIHNob3VsZCBzdGljayBhbmQgdW5zdGljayBvbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnNlUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZVBvaW50cygpIHtcbiAgICAgIHZhciB0b3AgPSB0aGlzLm9wdGlvbnMudG9wQW5jaG9yID09IFwiXCIgPyAxIDogdGhpcy5vcHRpb25zLnRvcEFuY2hvcixcbiAgICAgICAgICBidG0gPSB0aGlzLm9wdGlvbnMuYnRtQW5jaG9yID09IFwiXCIgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IDogdGhpcy5vcHRpb25zLmJ0bUFuY2hvcixcbiAgICAgICAgICBwdHMgPSBbdG9wLCBidG1dLFxuICAgICAgICAgIGJyZWFrcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHRzLmxlbmd0aDsgaSA8IGxlbiAmJiBwdHNbaV07IGkrKykge1xuICAgICAgICB2YXIgcHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwdHNbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcHQgPSBwdHNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBsYWNlID0gcHRzW2ldLnNwbGl0KCc6JyksXG4gICAgICAgICAgICAgIGFuY2hvciA9ICQoXCIjXCIuY29uY2F0KHBsYWNlWzBdKSk7XG4gICAgICAgICAgcHQgPSBhbmNob3Iub2Zmc2V0KCkudG9wO1xuXG4gICAgICAgICAgaWYgKHBsYWNlWzFdICYmIHBsYWNlWzFdLnRvTG93ZXJDYXNlKCkgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBwdCArPSBhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrc1tpXSA9IHB0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvaW50cyA9IGJyZWFrcztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIHNjcm9sbGluZyBlbGVtZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gcHNldWRvLXJhbmRvbSBpZCBmb3IgdW5pcXVlIHNjcm9sbCBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cyhpZCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBzY3JvbGxMaXN0ZW5lciA9IHRoaXMuc2Nyb2xsTGlzdGVuZXIgPSBcInNjcm9sbC56Zi5cIi5jb25jYXQoaWQpO1xuXG4gICAgICBpZiAodGhpcy5pc09uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FuU3RpY2spIHtcbiAgICAgICAgdGhpcy5pc09uID0gdHJ1ZTtcbiAgICAgICAgJCh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcikub24oc2Nyb2xsTGlzdGVuZXIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKF90aGlzLnNjcm9sbENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxDb3VudCA9IF90aGlzLm9wdGlvbnMuY2hlY2tFdmVyeTtcblxuICAgICAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ291bnQtLTtcblxuICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKS5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uIChlLCBlbCkge1xuICAgICAgICBfdGhpcy5fZXZlbnRzSGFuZGxlcihpZCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoZSwgZWwpIHtcbiAgICAgICAgX3RoaXMuX2V2ZW50c0hhbmRsZXIoaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLiRhbmNob3IpIHtcbiAgICAgICAgdGhpcy4kYW5jaG9yLm9uKCdtdXRhdGVtZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24gKGUsIGVsKSB7XG4gICAgICAgICAgX3RoaXMuX2V2ZW50c0hhbmRsZXIoaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgZXZlbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gcHNldWRvLXJhbmRvbSBpZCBmb3IgdW5pcXVlIHNjcm9sbCBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHNIYW5kbGVyKGlkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIHNjcm9sbExpc3RlbmVyID0gdGhpcy5zY3JvbGxMaXN0ZW5lciA9IFwic2Nyb2xsLnpmLlwiLmNvbmNhdChpZCk7XG5cbiAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9jYWxjKGZhbHNlKTtcblxuICAgICAgICBpZiAoX3RoaXMuY2FuU3RpY2spIHtcbiAgICAgICAgICBpZiAoIV90aGlzLmlzT24pIHtcbiAgICAgICAgICAgIF90aGlzLl9ldmVudHMoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5pc09uKSB7XG4gICAgICAgICAgX3RoaXMuX3BhdXNlTGlzdGVuZXJzKHNjcm9sbExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlcnMgZm9yIHNjcm9sbCBhbmQgY2hhbmdlIGV2ZW50cyBvbiBhbmNob3IuXG4gICAgICogQGZpcmVzIFN0aWNreSNwYXVzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzY3JvbGxMaXN0ZW5lciAtIHVuaXF1ZSwgbmFtZXNwYWNlZCBzY3JvbGwgbGlzdGVuZXIgYXR0YWNoZWQgdG8gYHdpbmRvd2BcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wYXVzZUxpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGF1c2VMaXN0ZW5lcnMoc2Nyb2xsTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xuICAgICAgJCh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcik7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBpcyBwYXVzZWQgZHVlIHRvIHJlc2l6ZSBldmVudCBzaHJpbmtpbmcgdGhlIHZpZXcuXG4gICAgICAgKiBAZXZlbnQgU3RpY2t5I3BhdXNlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncGF1c2UuemYuc3RpY2t5Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBldmVyeSBgc2Nyb2xsYCBldmVudCBhbmQgb24gYF9pbml0YFxuICAgICAqIGZpcmVzIGZ1bmN0aW9ucyBiYXNlZCBvbiBib29sZWFucyBhbmQgY2FjaGVkIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tTaXplcyAtIHRydWUgaWYgcGx1Z2luIHNob3VsZCByZWNhbGN1bGF0ZSBzaXplcyBhbmQgYnJlYWtwb2ludHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbCAtIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHBhc3NlZCBmcm9tIHNjcm9sbCBldmVudCBjYiBmdW5jdGlvbi4gSWYgbm90IHBhc3NlZCwgZGVmYXVsdHMgdG8gYHdpbmRvdy5wYWdlWU9mZnNldGAuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsYyhjaGVja1NpemVzLCBzY3JvbGwpIHtcbiAgICAgIGlmIChjaGVja1NpemVzKSB7XG4gICAgICAgIHRoaXMuX3NldFNpemVzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xuICAgICAgICBpZiAodGhpcy5pc1N0dWNrKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNjcm9sbCkge1xuICAgICAgICBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JvbGwgPj0gdGhpcy50b3BQb2ludCkge1xuICAgICAgICBpZiAoc2Nyb2xsIDw9IHRoaXMuYm90dG9tUG9pbnQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNTdHVjaykge1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RpY2t5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pc1N0dWNrKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHN0dWNrLlxuICAgICAqIEFkZHMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXG4gICAgICogQGZpcmVzIFN0aWNreSNzdHVja3RvXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRTdGlja3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0aWNreSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgc3RpY2tUbyA9IHRoaXMub3B0aW9ucy5zdGlja1RvLFxuICAgICAgICAgIG1yZ24gPSBzdGlja1RvID09PSAndG9wJyA/ICdtYXJnaW5Ub3AnIDogJ21hcmdpbkJvdHRvbScsXG4gICAgICAgICAgbm90U3R1Y2tUbyA9IHN0aWNrVG8gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJyxcbiAgICAgICAgICBjc3MgPSB7fTtcblxuICAgICAgY3NzW21yZ25dID0gXCJcIi5jb25jYXQodGhpcy5vcHRpb25zW21yZ25dLCBcImVtXCIpO1xuICAgICAgY3NzW3N0aWNrVG9dID0gMDtcbiAgICAgIGNzc1tub3RTdHVja1RvXSA9ICdhdXRvJztcbiAgICAgIHRoaXMuaXNTdHVjayA9IHRydWU7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiaXMtYW5jaG9yZWQgaXMtYXQtXCIuY29uY2F0KG5vdFN0dWNrVG8pKS5hZGRDbGFzcyhcImlzLXN0dWNrIGlzLWF0LVwiLmNvbmNhdChzdGlja1RvKSkuY3NzKGNzcylcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBgcG9zaXRpb246IGZpeGVkO2BcbiAgICAgICAqIE5hbWVzcGFjZWQgdG8gYHRvcGAgb3IgYGJvdHRvbWAsIGUuZy4gYHN0aWNreS56Zi5zdHVja3RvOnRvcGBcbiAgICAgICAqIEBldmVudCBTdGlja3kjc3R1Y2t0b1xuICAgICAgICovXG4gICAgICAudHJpZ2dlcihcInN0aWNreS56Zi5zdHVja3RvOlwiLmNvbmNhdChzdGlja1RvKSk7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKFwidHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIE1TVHJhbnNpdGlvbkVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9zZXRTaXplcygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHVuc3R1Y2suXG4gICAgICogUmVtb3ZlcyBgcG9zaXRpb246IGZpeGVkO2AsIGFuZCBoZWxwZXIgY2xhc3Nlcy5cbiAgICAgKiBBZGRzIG90aGVyIGhlbHBlciBjbGFzc2VzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNUb3AgLSB0ZWxscyB0aGUgZnVuY3Rpb24gaWYgdGhlICRlbGVtZW50IHNob3VsZCBhbmNob3IgdG8gdGhlIHRvcCBvciBib3R0b20gb2YgaXRzICRhbmNob3IgZWxlbWVudC5cbiAgICAgKiBAZmlyZXMgU3RpY2t5I3Vuc3R1Y2tmcm9tXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVTdGlja3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVN0aWNreShpc1RvcCkge1xuICAgICAgdmFyIHN0aWNrVG8gPSB0aGlzLm9wdGlvbnMuc3RpY2tUbyxcbiAgICAgICAgICBzdGlja1RvVG9wID0gc3RpY2tUbyA9PT0gJ3RvcCcsXG4gICAgICAgICAgY3NzID0ge30sXG4gICAgICAgICAgYW5jaG9yUHQgPSAodGhpcy5wb2ludHMgPyB0aGlzLnBvaW50c1sxXSAtIHRoaXMucG9pbnRzWzBdIDogdGhpcy5hbmNob3JIZWlnaHQpIC0gdGhpcy5lbGVtSGVpZ2h0LFxuICAgICAgICAgIG1yZ24gPSBzdGlja1RvVG9wID8gJ21hcmdpblRvcCcgOiAnbWFyZ2luQm90dG9tJyxcbiAgICAgICAgICB0b3BPckJvdHRvbSA9IGlzVG9wID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIGNzc1ttcmduXSA9IDA7XG4gICAgICBjc3NbJ2JvdHRvbSddID0gJ2F1dG8nO1xuXG4gICAgICBpZiAoaXNUb3ApIHtcbiAgICAgICAgY3NzWyd0b3AnXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjc3NbJ3RvcCddID0gYW5jaG9yUHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNTdHVjayA9IGZhbHNlO1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImlzLXN0dWNrIGlzLWF0LVwiLmNvbmNhdChzdGlja1RvKSkuYWRkQ2xhc3MoXCJpcy1hbmNob3JlZCBpcy1hdC1cIi5jb25jYXQodG9wT3JCb3R0b20pKS5jc3MoY3NzKVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSAkZWxlbWVudCBoYXMgYmVjb21lIGFuY2hvcmVkLlxuICAgICAgICogTmFtZXNwYWNlZCB0byBgdG9wYCBvciBgYm90dG9tYCwgZS5nLiBgc3RpY2t5LnpmLnVuc3R1Y2tmcm9tOmJvdHRvbWBcbiAgICAgICAqIEBldmVudCBTdGlja3kjdW5zdHVja2Zyb21cbiAgICAgICAqL1xuICAgICAgLnRyaWdnZXIoXCJzdGlja3kuemYudW5zdHVja2Zyb206XCIuY29uY2F0KHRvcE9yQm90dG9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlICRlbGVtZW50IGFuZCAkY29udGFpbmVyIHNpemVzIGZvciBwbHVnaW4uXG4gICAgICogQ2FsbHMgYF9zZXRCcmVha1BvaW50c2AuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIG9uIGNvbXBsZXRpb24gb2YgYF9zZXRCcmVha1BvaW50c2AuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRTaXplc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2l6ZXMoY2IpIHtcbiAgICAgIHRoaXMuY2FuU3RpY2sgPSBNZWRpYVF1ZXJ5LmlzKHRoaXMub3B0aW9ucy5zdGlja3lPbik7XG5cbiAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xuICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RWxlbVdpZHRoID0gdGhpcy4kY29udGFpbmVyWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLFxuICAgICAgICAgIGNvbXAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pLFxuICAgICAgICAgIHBkbmdsID0gcGFyc2VJbnQoY29tcFsncGFkZGluZy1sZWZ0J10sIDEwKSxcbiAgICAgICAgICBwZG5nciA9IHBhcnNlSW50KGNvbXBbJ3BhZGRpbmctcmlnaHQnXSwgMTApO1xuXG4gICAgICBpZiAodGhpcy4kYW5jaG9yICYmIHRoaXMuJGFuY2hvci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hbmNob3JIZWlnaHQgPSB0aGlzLiRhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyc2VQb2ludHMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgICAnbWF4LXdpZHRoJzogXCJcIi5jb25jYXQobmV3RWxlbVdpZHRoIC0gcGRuZ2wgLSBwZG5nciwgXCJweFwiKVxuICAgICAgfSk7XG4gICAgICB2YXIgbmV3Q29udGFpbmVySGVpZ2h0ID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgdGhpcy5jb250YWluZXJIZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLiRlbGVtZW50LmNzcyhcImRpc3BsYXlcIikgPT0gXCJub25lXCIpIHtcbiAgICAgICAgbmV3Q29udGFpbmVySGVpZ2h0ID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSBuZXdDb250YWluZXJIZWlnaHQ7XG4gICAgICB0aGlzLiRjb250YWluZXIuY3NzKHtcbiAgICAgICAgaGVpZ2h0OiBuZXdDb250YWluZXJIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbGVtSGVpZ2h0ID0gbmV3Q29udGFpbmVySGVpZ2h0O1xuXG4gICAgICBpZiAoIXRoaXMuaXNTdHVjaykge1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtYXQtYm90dG9tJykpIHtcbiAgICAgICAgICB2YXIgYW5jaG9yUHQgPSAodGhpcy5wb2ludHMgPyB0aGlzLnBvaW50c1sxXSAtIHRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS50b3AgOiB0aGlzLmFuY2hvckhlaWdodCkgLSB0aGlzLmVsZW1IZWlnaHQ7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5jc3MoJ3RvcCcsIGFuY2hvclB0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRCcmVha1BvaW50cyhuZXdDb250YWluZXJIZWlnaHQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1cHBlciBhbmQgbG93ZXIgYnJlYWtwb2ludHMgZm9yIHRoZSBlbGVtZW50IHRvIGJlY29tZSBzdGlja3kvdW5zdGlja3kuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVsZW1IZWlnaHQgLSBweCB2YWx1ZSBmb3Igc3RpY2t5LiRlbGVtZW50IGhlaWdodCwgY2FsY3VsYXRlZCBieSBgX3NldFNpemVzYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjb21wbGV0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0QnJlYWtQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEJyZWFrUG9pbnRzKGVsZW1IZWlnaHQsIGNiKSB7XG4gICAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtVG9wID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Ub3ApLFxuICAgICAgICAgIG1CdG0gPSBlbUNhbGModGhpcy5vcHRpb25zLm1hcmdpbkJvdHRvbSksXG4gICAgICAgICAgdG9wUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzBdIDogdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxcbiAgICAgICAgICBib3R0b21Qb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gOiB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0LFxuICAgICAgICAgIC8vIHRvcFBvaW50ID0gdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCB8fCB0aGlzLnBvaW50c1swXSxcbiAgICAgIC8vIGJvdHRvbVBvaW50ID0gdG9wUG9pbnQgKyB0aGlzLmFuY2hvckhlaWdodCB8fCB0aGlzLnBvaW50c1sxXSxcbiAgICAgIHdpbkhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGlja1RvID09PSAndG9wJykge1xuICAgICAgICB0b3BQb2ludCAtPSBtVG9wO1xuICAgICAgICBib3R0b21Qb2ludCAtPSBlbGVtSGVpZ2h0ICsgbVRvcDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0aWNrVG8gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHRvcFBvaW50IC09IHdpbkhlaWdodCAtIChlbGVtSGVpZ2h0ICsgbUJ0bSk7XG4gICAgICAgIGJvdHRvbVBvaW50IC09IHdpbkhlaWdodCAtIG1CdG07XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9wUG9pbnQgPSB0b3BQb2ludDtcbiAgICAgIHRoaXMuYm90dG9tUG9pbnQgPSBib3R0b21Qb2ludDtcblxuICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgY3VycmVudCBzdGlja3kgZWxlbWVudC5cbiAgICAgKiBSZXNldHMgdGhlIGVsZW1lbnQgdG8gdGhlIHRvcCBwb3NpdGlvbiBmaXJzdC5cbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycywgSlMtYWRkZWQgY3NzIHByb3BlcnRpZXMgYW5kIGNsYXNzZXMsIGFuZCB1bndyYXBzIHRoZSAkZWxlbWVudCBpZiB0aGUgSlMgYWRkZWQgdGhlICRjb250YWluZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcblxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcIlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MsIFwiIGlzLWFuY2hvcmVkIGlzLWF0LXRvcFwiKSkuY3NzKHtcbiAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgYm90dG9tOiAnJyxcbiAgICAgICAgJ21heC13aWR0aCc6ICcnXG4gICAgICB9KS5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKS5vZmYoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcblxuICAgICAgaWYgKHRoaXMuJGFuY2hvciAmJiB0aGlzLiRhbmNob3IubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuJGFuY2hvci5vZmYoJ2NoYW5nZS56Zi5zdGlja3knKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsTGlzdGVuZXIpICQod2luZG93KS5vZmYodGhpcy5zY3JvbGxMaXN0ZW5lcik7XG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikgJCh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcblxuICAgICAgaWYgKHRoaXMud2FzV3JhcHBlZCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LnVud3JhcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcykuY3NzKHtcbiAgICAgICAgICBoZWlnaHQ6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGlja3k7XG59KFBsdWdpbik7XG5cblN0aWNreS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEN1c3RvbWl6YWJsZSBjb250YWluZXIgdGVtcGxhdGUuIEFkZCB5b3VyIG93biBjbGFzc2VzIGZvciBzdHlsaW5nIGFuZCBzaXppbmcuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJyZsdDtkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyJmd0OyZsdDsvZGl2Jmd0OydcbiAgICovXG4gIGNvbnRhaW5lcjogJzxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PicsXG5cbiAgLyoqXG4gICAqIExvY2F0aW9uIGluIHRoZSB2aWV3IHRoZSBlbGVtZW50IHN0aWNrcyB0by4gQ2FuIGJlIGAndG9wJ2Agb3IgYCdib3R0b20nYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAndG9wJ1xuICAgKi9cbiAgc3RpY2tUbzogJ3RvcCcsXG5cbiAgLyoqXG4gICAqIElmIGFuY2hvcmVkIHRvIGEgc2luZ2xlIGVsZW1lbnQsIHRoZSBpZCBvZiB0aGF0IGVsZW1lbnQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIGFuY2hvcjogJycsXG5cbiAgLyoqXG4gICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIHRvcCBhbmNob3IuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIHRvcEFuY2hvcjogJycsXG5cbiAgLyoqXG4gICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIGJvdHRvbSBhbmNob3IuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIGJ0bUFuY2hvcjogJycsXG5cbiAgLyoqXG4gICAqIE1hcmdpbiwgaW4gYGVtYCdzIHRvIGFwcGx5IHRvIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBtYXJnaW5Ub3A6IDEsXG5cbiAgLyoqXG4gICAqIE1hcmdpbiwgaW4gYGVtYCdzIHRvIGFwcGx5IHRvIHRoZSBib3R0b20gb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBtYXJnaW5Cb3R0b206IDEsXG5cbiAgLyoqXG4gICAqIEJyZWFrcG9pbnQgc3RyaW5nIHRoYXQgaXMgdGhlIG1pbmltdW0gc2NyZWVuIHNpemUgYW4gZWxlbWVudCBzaG91bGQgYmVjb21lIHN0aWNreS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnbWVkaXVtJ1xuICAgKi9cbiAgc3RpY2t5T246ICdtZWRpdW0nLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHN0aWNreSBlbGVtZW50LCBhbmQgcmVtb3ZlZCBvbiBkZXN0cnVjdGlvbi4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5YC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnc3RpY2t5J1xuICAgKi9cbiAgc3RpY2t5Q2xhc3M6ICdzdGlja3knLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHN0aWNreSBjb250YWluZXIuIEZvdW5kYXRpb24gZGVmYXVsdHMgdG8gYHN0aWNreS1jb250YWluZXJgLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdzdGlja3ktY29udGFpbmVyJ1xuICAgKi9cbiAgY29udGFpbmVyQ2xhc3M6ICdzdGlja3ktY29udGFpbmVyJyxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHNjcm9sbCBldmVudHMgYmV0d2VlbiB0aGUgcGx1Z2luJ3MgcmVjYWxjdWxhdGluZyBzdGlja3kgcG9pbnRzLiBTZXR0aW5nIGl0IHRvIGAwYCB3aWxsIGNhdXNlIGl0IHRvIHJlY2FsYyBldmVyeSBzY3JvbGwgZXZlbnQsIHNldHRpbmcgaXQgdG8gYC0xYCB3aWxsIHByZXZlbnQgcmVjYWxjIG9uIHNjcm9sbC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAtMVxuICAgKi9cbiAgY2hlY2tFdmVyeTogLTFcbn07XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgZW0gdmFsdWVzXG4gKiBAcGFyYW0gTnVtYmVyIHtlbX0gLSBudW1iZXIgb2YgZW0ncyB0byBjYWxjdWxhdGUgaW50byBwaXhlbHNcbiAqL1xuXG5mdW5jdGlvbiBlbUNhbGMoZW0pIHtcbiAgcmV0dXJuIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHksIG51bGwpLmZvbnRTaXplLCAxMCkgKiBlbTtcbn1cblxuLyoqXG4gKiBUYWJzIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi50YWJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmltYWdlTG9hZGVyIGlmIHRhYnMgY29udGFpbiBpbWFnZXNcbiAqL1xuXG52YXIgVGFicyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoVGFicywgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gVGFicygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFicyk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFRhYnMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRhYnMsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0YWJzLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFRhYnNcbiAgICAgKiBAZmlyZXMgVGFicyNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byB0YWJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRhYnMuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RhYnMnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICBLZXlib2FyZC5yZWdpc3RlcignVGFicycsIHtcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxuICAgICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3ByZXZpb3VzJyxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnbmV4dCcsXG4gICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJyAvLyAnVEFCJzogJ25leHQnLFxuICAgICAgICAvLyAnU0hJRlRfVEFCJzogJ3ByZXZpb3VzJ1xuXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYnMgYnkgc2hvd2luZyBhbmQgZm9jdXNpbmcgKGlmIGF1dG9Gb2N1cz10cnVlKSB0aGUgcHJlc2V0IGFjdGl2ZSB0YWIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2lzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgICdyb2xlJzogJ3RhYmxpc3QnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJHRhYlRpdGxlcyA9IHRoaXMuJGVsZW1lbnQuZmluZChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtDbGFzcykpO1xuICAgICAgdGhpcy4kdGFiQ29udGVudCA9ICQoXCJbZGF0YS10YWJzLWNvbnRlbnQ9XFxcIlwiLmNvbmNhdCh0aGlzLiRlbGVtZW50WzBdLmlkLCBcIlxcXCJdXCIpKTtcbiAgICAgIHRoaXMuJHRhYlRpdGxlcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRlbGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAgICRsaW5rID0gJGVsZW0uZmluZCgnYScpLFxuICAgICAgICAgICAgaXNBY3RpdmUgPSAkZWxlbS5oYXNDbGFzcyhcIlwiLmNvbmNhdChfdGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpLFxuICAgICAgICAgICAgaGFzaCA9ICRsaW5rLmF0dHIoJ2RhdGEtdGFicy10YXJnZXQnKSB8fCAkbGlua1swXS5oYXNoLnNsaWNlKDEpLFxuICAgICAgICAgICAgbGlua0lkID0gJGxpbmtbMF0uaWQgPyAkbGlua1swXS5pZCA6IFwiXCIuY29uY2F0KGhhc2gsIFwiLWxhYmVsXCIpLFxuICAgICAgICAgICAgJHRhYkNvbnRlbnQgPSAkKFwiI1wiLmNvbmNhdChoYXNoKSk7XG4gICAgICAgICRlbGVtLmF0dHIoe1xuICAgICAgICAgICdyb2xlJzogJ3ByZXNlbnRhdGlvbidcbiAgICAgICAgfSk7XG4gICAgICAgICRsaW5rLmF0dHIoe1xuICAgICAgICAgICdyb2xlJzogJ3RhYicsXG4gICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBoYXNoLFxuICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogaXNBY3RpdmUsXG4gICAgICAgICAgJ2lkJzogbGlua0lkLFxuICAgICAgICAgICd0YWJpbmRleCc6IGlzQWN0aXZlID8gJzAnIDogJy0xJ1xuICAgICAgICB9KTtcbiAgICAgICAgJHRhYkNvbnRlbnQuYXR0cih7XG4gICAgICAgICAgJ3JvbGUnOiAndGFicGFuZWwnLFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWRcbiAgICAgICAgfSk7IC8vIFNhdmUgdXAgdGhlIGluaXRpYWwgaGFzaCB0byByZXR1cm4gdG8gaXQgbGF0ZXIgd2hlbiBnb2luZyBiYWNrIGluIGhpc3RvcnlcblxuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICBfdGhpcy5faW5pdGlhbEFuY2hvciA9IFwiI1wiLmNvbmNhdChoYXNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgICAkdGFiQ29udGVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBY3RpdmUgJiYgX3RoaXMub3B0aW9ucy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICBfdGhpcy5vbkxvYWRMaXN0ZW5lciA9IG9uTG9hZCgkKHdpbmRvdyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wOiAkZWxlbS5vZmZzZXQoKS50b3BcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2VEZWxheSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAkbGluay5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KSB7XG4gICAgICAgIHZhciAkaW1hZ2VzID0gdGhpcy4kdGFiQ29udGVudC5maW5kKCdpbWcnKTtcblxuICAgICAgICBpZiAoJGltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBvbkltYWdlc0xvYWRlZCgkaW1hZ2VzLCB0aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0SGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3VycmVudCBjb250ZXh0LWJvdW5kIGZ1bmN0aW9uIHRvIG9wZW4gdGFicyBvbiBwYWdlIGxvYWQgb3IgaGlzdG9yeSBoYXNoY2hhbmdlXG5cblxuICAgICAgdGhpcy5fY2hlY2tEZWVwTGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFuY2hvciA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXG4gICAgICAgIGlmICghYW5jaG9yLmxlbmd0aCkge1xuICAgICAgICAgIC8vIElmIHdlIGFyZSBzdGlsbCBpbml0aWFsaXppbmcgYW5kIHRoZXJlIGlzIG5vIGFuY2hvciwgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgaWYgKF90aGlzMi5faXNJbml0aWFsaXppbmcpIHJldHVybjsgLy8gT3RoZXJ3aXNlLCBtb3ZlIHRvIHRoZSBpbml0aWFsIGFuY2hvclxuXG4gICAgICAgICAgaWYgKF90aGlzMi5faW5pdGlhbEFuY2hvcikgYW5jaG9yID0gX3RoaXMyLl9pbml0aWFsQW5jaG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICRhbmNob3IgPSBhbmNob3IgJiYgJChhbmNob3IpO1xuXG4gICAgICAgIHZhciAkbGluayA9IGFuY2hvciAmJiBfdGhpczIuJGVsZW1lbnQuZmluZCgnW2hyZWYkPVwiJyArIGFuY2hvciArICdcIl0nKTsgLy8gV2hldGhlciB0aGUgYW5jaG9yIGVsZW1lbnQgdGhhdCBoYXMgYmVlbiBmb3VuZCBpcyBwYXJ0IG9mIHRoaXMgZWxlbWVudFxuXG5cbiAgICAgICAgdmFyIGlzT3duQW5jaG9yID0gISEoJGFuY2hvci5sZW5ndGggJiYgJGxpbmsubGVuZ3RoKTsgLy8gSWYgdGhlcmUgaXMgYW4gYW5jaG9yIGZvciB0aGUgaGFzaCwgc2VsZWN0IGl0XG5cbiAgICAgICAgaWYgKCRhbmNob3IgJiYgJGFuY2hvci5sZW5ndGggJiYgJGxpbmsgJiYgJGxpbmsubGVuZ3RoKSB7XG4gICAgICAgICAgX3RoaXMyLnNlbGVjdFRhYigkYW5jaG9yLCB0cnVlKTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIGNvbGxhcHNlIGV2ZXJ5dGhpbmdcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpczIuX2NvbGxhcHNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc093bkFuY2hvcikge1xuICAgICAgICAgIC8vIFJvbGwgdXAgYSBsaXR0bGUgdG8gc2hvdyB0aGUgdGl0bGVzXG4gICAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmRlZXBMaW5rU211ZGdlKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMyLiRlbGVtZW50Lm9mZnNldCgpO1xuXG4gICAgICAgICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgIHNjcm9sbFRvcDogb2Zmc2V0LnRvcFxuICAgICAgICAgICAgfSwgX3RoaXMyLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2VEZWxheSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgZGVlcGxpbmtlZCBhdCBwYWdlbG9hZFxuICAgICAgICAgICAqIEBldmVudCBUYWJzI2RlZXBsaW5rXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdkZWVwbGluay56Zi50YWJzJywgWyRsaW5rLCAkYW5jaG9yXSk7XG4gICAgICAgIH1cbiAgICAgIH07IC8vdXNlIGJyb3dzZXIgdG8gb3BlbiBhIHRhYiwgaWYgaXQgZXhpc3RzIGluIHRoaXMgdGFic2V0XG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICB0aGlzLl9jaGVja0RlZXBMaW5rKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgICB0aGlzLl9pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHRoaXMuX2FkZEtleUhhbmRsZXIoKTtcblxuICAgICAgdGhpcy5fYWRkQ2xpY2tIYW5kbGVyKCk7XG5cbiAgICAgIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyID0gdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcyk7XG4gICAgICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICAkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBjbGljayBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQ2xpY2tIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDbGlja0hhbmRsZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYudGFicycpLm9uKCdjbGljay56Zi50YWJzJywgXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkKHRoaXMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGtleWJvYXJkIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRLZXlIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRLZXlIYW5kbGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kdGFiVGl0bGVzLm9mZigna2V5ZG93bi56Zi50YWJzJykub24oJ2tleWRvd24uemYudGFicycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSA5KSByZXR1cm47XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyksXG4gICAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQsXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQ7XG4gICAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgaWYgKCQodGhpcykuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy53cmFwT25LZXlzKSB7XG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9IGkgPT09IDAgPyAkZWxlbWVudHMubGFzdCgpIDogJGVsZW1lbnRzLmVxKGkgLSAxKTtcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gaSA9PT0gJGVsZW1lbnRzLmxlbmd0aCAtIDEgPyAkZWxlbWVudHMuZmlyc3QoKSA6ICRlbGVtZW50cy5lcShpICsgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKTtcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkgKyAxLCAkZWxlbWVudHMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuXG4gICAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnVGFicycsIHtcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICAgICAgJGVsZW1lbnQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5mb2N1cygpO1xuXG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCRlbGVtZW50KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudC5maW5kKCdbcm9sZT1cInRhYlwiXScpLmZvY3VzKCk7XG5cbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJHByZXZFbGVtZW50KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5mb2N1cygpO1xuXG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCRuZXh0RWxlbWVudCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiBoYW5kbGVkKCkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB0YWIgYCR0YXJnZXRDb250ZW50YCBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC4gQ29sbGFwc2VzIGFjdGl2ZSB0YWIuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gb3Blbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpc3RvcnlIYW5kbGVkIC0gYnJvd3NlciBoYXMgYWxyZWFkeSBoYW5kbGVkIGEgaGlzdG9yeSB1cGRhdGVcbiAgICAgKiBAZmlyZXMgVGFicyNjaGFuZ2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVUYWJDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVRhYkNoYW5nZSgkdGFyZ2V0LCBoaXN0b3J5SGFuZGxlZCkge1xuICAgICAgLy8gV2l0aCBgYWN0aXZlQ29sbGFwc2VgLCBpZiB0aGUgdGFyZ2V0IGlzIHRoZSBhY3RpdmUgVGFiLCBjb2xsYXBzZSBpdC5cbiAgICAgIGlmICgkdGFyZ2V0Lmhhc0NsYXNzKFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MpKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFjdGl2ZUNvbGxhcHNlKSB7XG4gICAgICAgICAgdGhpcy5fY29sbGFwc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyICRvbGRUYWIgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MsIFwiLlwiKS5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpLFxuICAgICAgICAgICR0YWJMaW5rID0gJHRhcmdldC5maW5kKCdbcm9sZT1cInRhYlwiXScpLFxuICAgICAgICAgIHRhcmdldCA9ICR0YWJMaW5rLmF0dHIoJ2RhdGEtdGFicy10YXJnZXQnKSxcbiAgICAgICAgICBhbmNob3IgPSB0YXJnZXQgJiYgdGFyZ2V0Lmxlbmd0aCA/IFwiI1wiLmNvbmNhdCh0YXJnZXQpIDogJHRhYkxpbmtbMF0uaGFzaCxcbiAgICAgICAgICAkdGFyZ2V0Q29udGVudCA9IHRoaXMuJHRhYkNvbnRlbnQuZmluZChhbmNob3IpOyAvL2Nsb3NlIG9sZCB0YWJcblxuICAgICAgdGhpcy5fY29sbGFwc2VUYWIoJG9sZFRhYik7IC8vb3BlbiBuZXcgdGFiXG5cblxuICAgICAgdGhpcy5fb3BlblRhYigkdGFyZ2V0KTsgLy9laXRoZXIgcmVwbGFjZSBvciB1cGRhdGUgYnJvd3NlciBoaXN0b3J5XG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluayAmJiAhaGlzdG9yeUhhbmRsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVIaXN0b3J5KSB7XG4gICAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBhbmNob3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIHN1Y2Nlc3NmdWxseSBjaGFuZ2VkIHRhYnMuXG4gICAgICAgKiBAZXZlbnQgVGFicyNjaGFuZ2VcbiAgICAgICAqL1xuXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlLnpmLnRhYnMnLCBbJHRhcmdldCwgJHRhcmdldENvbnRlbnRdKTsgLy9maXJlIHRvIGNoaWxkcmVuIGEgbXV0YXRpb24gZXZlbnRcblxuICAgICAgJHRhcmdldENvbnRlbnQuZmluZChcIltkYXRhLW11dGF0ZV1cIikudHJpZ2dlcihcIm11dGF0ZW1lLnpmLnRyaWdnZXJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB0YWIgYCR0YXJnZXRDb250ZW50YCBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFRhYiB0byBvcGVuLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX29wZW5UYWJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5UYWIoJHRhcmdldCkge1xuICAgICAgdmFyICR0YWJMaW5rID0gJHRhcmdldC5maW5kKCdbcm9sZT1cInRhYlwiXScpLFxuICAgICAgICAgIGhhc2ggPSAkdGFiTGluay5hdHRyKCdkYXRhLXRhYnMtdGFyZ2V0JykgfHwgJHRhYkxpbmtbMF0uaGFzaC5zbGljZSgxKSxcbiAgICAgICAgICAkdGFyZ2V0Q29udGVudCA9IHRoaXMuJHRhYkNvbnRlbnQuZmluZChcIiNcIi5jb25jYXQoaGFzaCkpO1xuICAgICAgJHRhcmdldC5hZGRDbGFzcyhcIlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSk7XG4gICAgICAkdGFiTGluay5hdHRyKHtcbiAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiAndHJ1ZScsXG4gICAgICAgICd0YWJpbmRleCc6ICcwJ1xuICAgICAgfSk7XG4gICAgICAkdGFyZ2V0Q29udGVudC5hZGRDbGFzcyhcIlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMucGFuZWxBY3RpdmVDbGFzcykpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBgJHRhcmdldENvbnRlbnRgIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gVGFiIHRvIGNvbGxhcHNlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbGxhcHNlVGFiXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb2xsYXBzZVRhYigkdGFyZ2V0KSB7XG4gICAgICB2YXIgJHRhcmdldF9hbmNob3IgPSAkdGFyZ2V0LnJlbW92ZUNsYXNzKFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MpKS5maW5kKCdbcm9sZT1cInRhYlwiXScpLmF0dHIoe1xuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6ICdmYWxzZScsXG4gICAgICAgICd0YWJpbmRleCc6IC0xXG4gICAgICB9KTtcbiAgICAgICQoXCIjXCIuY29uY2F0KCR0YXJnZXRfYW5jaG9yLmF0dHIoJ2FyaWEtY29udHJvbHMnKSkpLnJlbW92ZUNsYXNzKFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy5wYW5lbEFjdGl2ZUNsYXNzKSkuYXR0cih7XG4gICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyB0aGUgYWN0aXZlIFRhYi5cbiAgICAgKiBAZmlyZXMgVGFicyNjb2xsYXBzZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbGxhcHNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb2xsYXBzZSgpIHtcbiAgICAgIHZhciAkYWN0aXZlVGFiID0gdGhpcy4kZWxlbWVudC5maW5kKFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0NsYXNzLCBcIi5cIikuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MpKTtcblxuICAgICAgaWYgKCRhY3RpdmVUYWIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2NvbGxhcHNlVGFiKCRhY3RpdmVUYWIpO1xuICAgICAgICAvKipcbiAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIHN1Y2Nlc3NmdWxseSBjb2xsYXBzZWQgdGFicy5cbiAgICAgICAgKiBAZXZlbnQgVGFicyNjb2xsYXBzZVxuICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjb2xsYXBzZS56Zi50YWJzJywgWyRhY3RpdmVUYWJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCBmb3Igc2VsZWN0aW5nIGEgY29udGVudCBwYW5lIHRvIGRpc3BsYXkuXG4gICAgICogQHBhcmFtIHtqUXVlcnkgfCBTdHJpbmd9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gZGlzcGxheS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpc3RvcnlIYW5kbGVkIC0gYnJvd3NlciBoYXMgYWxyZWFkeSBoYW5kbGVkIGEgaGlzdG9yeSB1cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdFRhYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RUYWIoZWxlbSwgaGlzdG9yeUhhbmRsZWQpIHtcbiAgICAgIHZhciBpZFN0cjtcblxuICAgICAgaWYgKF90eXBlb2YoZWxlbSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlkU3RyID0gZWxlbVswXS5pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkU3RyID0gZWxlbTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkU3RyLmluZGV4T2YoJyMnKSA8IDApIHtcbiAgICAgICAgaWRTdHIgPSBcIiNcIi5jb25jYXQoaWRTdHIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgJHRhcmdldCA9IHRoaXMuJHRhYlRpdGxlcy5oYXMoXCJbaHJlZiQ9XFxcIlwiLmNvbmNhdChpZFN0ciwgXCJcXFwiXVwiKSk7XG5cbiAgICAgIHRoaXMuX2hhbmRsZVRhYkNoYW5nZSgkdGFyZ2V0LCBoaXN0b3J5SGFuZGxlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRIZWlnaHRcIixcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiBlYWNoIHBhbmVsIHRvIHRoZSBoZWlnaHQgb2YgdGhlIHRhbGxlc3QgcGFuZWwuXG4gICAgICogSWYgZW5hYmxlZCBpbiBvcHRpb25zLCBnZXRzIGNhbGxlZCBvbiBtZWRpYSBxdWVyeSBjaGFuZ2UuXG4gICAgICogSWYgbG9hZGluZyBjb250ZW50IHZpYSBleHRlcm5hbCBzb3VyY2UsIGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgb3Igd2l0aCBfcmVmbG93LlxuICAgICAqIElmIGVuYWJsZWQgd2l0aCBgZGF0YS1tYXRjaC1oZWlnaHQ9XCJ0cnVlXCJgLCB0YWJzIHNldHMgdG8gZXF1YWwgaGVpZ2h0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEhlaWdodCgpIHtcbiAgICAgIHZhciBtYXggPSAwLFxuICAgICAgICAgIF90aGlzID0gdGhpczsgLy8gTG9jayBkb3duIHRoZSBgdGhpc2AgdmFsdWUgZm9yIHRoZSByb290IHRhYnMgb2JqZWN0XG5cblxuICAgICAgdGhpcy4kdGFiQ29udGVudC5maW5kKFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykpLmNzcygnaGVpZ2h0JywgJycpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFuZWwgPSAkKHRoaXMpLFxuICAgICAgICAgICAgaXNBY3RpdmUgPSBwYW5lbC5oYXNDbGFzcyhcIlwiLmNvbmNhdChfdGhpcy5vcHRpb25zLnBhbmVsQWN0aXZlQ2xhc3MpKTsgLy8gZ2V0IHRoZSBvcHRpb25zIGZyb20gdGhlIHBhcmVudCBpbnN0ZWFkIG9mIHRyeWluZyB0byBnZXQgdGhlbSBmcm9tIHRoZSBjaGlsZFxuXG4gICAgICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgICBwYW5lbC5jc3Moe1xuICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICdkaXNwbGF5JzogJ2Jsb2NrJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblxuICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgICAgcGFuZWwuY3NzKHtcbiAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJycsXG4gICAgICAgICAgICAnZGlzcGxheSc6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXggPSB0ZW1wID4gbWF4ID8gdGVtcCA6IG1heDtcbiAgICAgIH0pLmNzcygnaGVpZ2h0JywgXCJcIi5jb25jYXQobWF4LCBcInB4XCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgdGFicy5cbiAgICAgKiBAZmlyZXMgVGFicyNkZXN0cm95ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0NsYXNzKSkub2ZmKCcuemYudGFicycpLmhpZGUoKS5lbmQoKS5maW5kKFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykpLmhpZGUoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAkKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZignaGFzaGNoYW5nZScsIHRoaXMuX2NoZWNrRGVlcExpbmspO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikge1xuICAgICAgICAkKHdpbmRvdykub2ZmKHRoaXMub25Mb2FkTGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUYWJzO1xufShQbHVnaW4pO1xuXG5UYWJzLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogTGluayB0aGUgbG9jYXRpb24gaGFzaCB0byB0aGUgYWN0aXZlIHBhbmUuXG4gICAqIFNldCB0aGUgbG9jYXRpb24gaGFzaCB3aGVuIHRoZSBhY3RpdmUgcGFuZSBjaGFuZ2VzLCBhbmQgb3BlbiB0aGUgY29ycmVzcG9uZGluZyBwYW5lIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkZWVwTGluazogZmFsc2UsXG5cbiAgLyoqXG4gICAqIElmIGBkZWVwTGlua2AgaXMgZW5hYmxlZCwgYWRqdXN0IHRoZSBkZWVwIGxpbmsgc2Nyb2xsIHRvIG1ha2Ugc3VyZSB0aGUgdG9wIG9mIHRoZSB0YWIgcGFuZWwgaXMgdmlzaWJsZVxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGVlcExpbmtTbXVkZ2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVlcExpbmtTbXVkZ2VgIGlzIGVuYWJsZWQsIGFuaW1hdGlvbiB0aW1lIChtcykgZm9yIHRoZSBkZWVwIGxpbmsgYWRqdXN0bWVudFxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDMwMFxuICAgKi9cbiAgZGVlcExpbmtTbXVkZ2VEZWxheTogMzAwLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVlcExpbmtgIGlzIGVuYWJsZWQsIHVwZGF0ZSB0aGUgYnJvd3NlciBoaXN0b3J5IHdpdGggdGhlIG9wZW4gdGFiXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB1cGRhdGVIaXN0b3J5OiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSB3aW5kb3cgdG8gc2Nyb2xsIHRvIGNvbnRlbnQgb2YgYWN0aXZlIHBhbmUgb24gbG9hZC5cbiAgICogTm90IHJlY29tbWVuZGVkIGlmIG1vcmUgdGhhbiBvbmUgdGFiIHBhbmVsIHBlciBwYWdlLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYXV0b0ZvY3VzOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3dzIGtleWJvYXJkIGlucHV0IHRvICd3cmFwJyBhcm91bmQgdGhlIHRhYiBsaW5rcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgd3JhcE9uS2V5czogdHJ1ZSxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSB0YWIgY29udGVudCBwYW5lcyB0byBtYXRjaCBoZWlnaHRzIGlmIHNldCB0byB0cnVlLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgbWF0Y2hIZWlnaHQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYWN0aXZlIHRhYnMgdG8gY29sbGFwc2Ugd2hlbiBjbGlja2VkLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYWN0aXZlQ29sbGFwc2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIGBsaWAncyBpbiB0YWIgbGluayBsaXN0LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICd0YWJzLXRpdGxlJ1xuICAgKi9cbiAgbGlua0NsYXNzOiAndGFicy10aXRsZScsXG5cbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBgbGlgIGluIHRhYiBsaW5rIGxpc3QuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2lzLWFjdGl2ZSdcbiAgICovXG4gIGxpbmtBY3RpdmVDbGFzczogJ2lzLWFjdGl2ZScsXG5cbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbnRlbnQgY29udGFpbmVycy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAndGFicy1wYW5lbCdcbiAgICovXG4gIHBhbmVsQ2xhc3M6ICd0YWJzLXBhbmVsJyxcblxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYWN0aXZlIGNvbnRlbnQgY29udGFpbmVyLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdpcy1hY3RpdmUnXG4gICAqL1xuICBwYW5lbEFjdGl2ZUNsYXNzOiAnaXMtYWN0aXZlJ1xufTtcblxuLyoqXG4gKiBUb2dnbGVyIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi50b2dnbGVyXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICovXG5cbnZhciBUb2dnbGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhUb2dnbGVyLCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBUb2dnbGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2dnbGVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoVG9nZ2xlcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVG9nZ2xlciwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFRvZ2dsZXIuXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgVG9nZ2xlclxuICAgICAqIEBmaXJlcyBUb2dnbGVyI2luaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvZ2dsZXIuZGVmYXVsdHMsIGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJyc7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdUb2dnbGVyJzsgLy8gaWU5IGJhY2sgY29tcGF0XG4gICAgICAvLyBUcmlnZ2VycyBpbml0IGlzIGlkZW1wb3RlbnQsIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQgaXMgaW5pdGlhbGl6ZWRcblxuICAgICAgVHJpZ2dlcnMuaW5pdCgkKTtcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFRvZ2dsZXIgcGx1Z2luIGJ5IHBhcnNpbmcgdGhlIHRvZ2dsZSBjbGFzcyBmcm9tIGRhdGEtdG9nZ2xlciwgb3IgYW5pbWF0aW9uIGNsYXNzZXMgZnJvbSBkYXRhLWFuaW1hdGUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIGlucHV0OyAvLyBQYXJzZSBhbmltYXRpb24gY2xhc3NlcyBpZiB0aGV5IHdlcmUgc2V0XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgICBpbnB1dCA9IHRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KCcgJyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSW4gPSBpbnB1dFswXTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25PdXQgPSBpbnB1dFsxXSB8fCBudWxsO1xuICAgICAgfSAvLyBPdGhlcndpc2UsIHBhcnNlIHRvZ2dsZSBjbGFzc1xuICAgICAgZWxzZSB7XG4gICAgICAgICAgaW5wdXQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3RvZ2dsZXInKTsgLy8gQWxsb3cgZm9yIGEgLiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcblxuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gaW5wdXRbMF0gPT09ICcuJyA/IGlucHV0LnNsaWNlKDEpIDogaW5wdXQ7XG4gICAgICAgIH0gLy8gQWRkIEFSSUEgYXR0cmlidXRlcyB0byB0cmlnZ2VyczpcblxuXG4gICAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkLFxuICAgICAgICAgICR0cmlnZ2VycyA9ICQoXCJbZGF0YS1vcGVufj1cXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJdLCBbZGF0YS1jbG9zZX49XFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIl0sIFtkYXRhLXRvZ2dsZX49XFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIl1cIikpOyAvLyAtIGFyaWEtZXhwYW5kZWQ6IGFjY29yZGluZyB0byB0aGUgZWxlbWVudCB2aXNpYmlsaXR5LlxuXG4gICAgICAkdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICF0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykpOyAvLyAtIGFyaWEtY29udHJvbHM6IGFkZGluZyB0aGUgZWxlbWVudCBpZCB0byBpdCBpZiBub3QgYWxyZWFkeSBpbiBpdC5cblxuICAgICAgJHRyaWdnZXJzLmVhY2goZnVuY3Rpb24gKGluZGV4LCB0cmlnZ2VyKSB7XG4gICAgICAgIHZhciAkdHJpZ2dlciA9ICQodHJpZ2dlcik7XG4gICAgICAgIHZhciBjb250cm9scyA9ICR0cmlnZ2VyLmF0dHIoJ2FyaWEtY29udHJvbHMnKSB8fCAnJztcbiAgICAgICAgdmFyIGNvbnRhaW5zSWQgPSBuZXcgUmVnRXhwKFwiXFxcXGJcIi5jb25jYXQoUmVnRXhwRXNjYXBlKGlkKSwgXCJcXFxcYlwiKSkudGVzdChjb250cm9scyk7XG4gICAgICAgIGlmICghY29udGFpbnNJZCkgJHRyaWdnZXIuYXR0cignYXJpYS1jb250cm9scycsIGNvbnRyb2xzID8gXCJcIi5jb25jYXQoY29udHJvbHMsIFwiIFwiKS5jb25jYXQoaWQpIDogaWQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIHRvZ2dsZSB0cmlnZ2VyLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigndG9nZ2xlLnpmLnRyaWdnZXInKS5vbigndG9nZ2xlLnpmLnRyaWdnZXInLCB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdGFyZ2V0IGNsYXNzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC4gQW4gZXZlbnQgaXMgZmlyZWQgZnJvbSB0aGUgb3JpZ2luYWwgdHJpZ2dlciBkZXBlbmRpbmcgb24gaWYgdGhlIHJlc3VsdGFudCBzdGF0ZSB3YXMgXCJvblwiIG9yIFwib2ZmXCIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIFRvZ2dsZXIjb25cbiAgICAgKiBAZmlyZXMgVG9nZ2xlciNvZmZcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICB0aGlzW3RoaXMub3B0aW9ucy5hbmltYXRlID8gJ190b2dnbGVBbmltYXRlJyA6ICdfdG9nZ2xlQ2xhc3MnXSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdG9nZ2xlQ2xhc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RvZ2dsZUNsYXNzKCkge1xuICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB2YXIgaXNPbiA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5jbGFzc05hbWUpO1xuXG4gICAgICBpZiAoaXNPbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgaWYgdGhlIHRhcmdldCBlbGVtZW50IGhhcyB0aGUgY2xhc3MgYWZ0ZXIgYSB0b2dnbGUuXG4gICAgICAgICAqIEBldmVudCBUb2dnbGVyI29uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29uLnpmLnRvZ2dsZXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSB0aGUgY2xhc3MgYWZ0ZXIgYSB0b2dnbGUuXG4gICAgICAgICAqIEBldmVudCBUb2dnbGVyI29mZlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvZmYuemYudG9nZ2xlcicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVBUklBKGlzT24pO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90b2dnbGVBbmltYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVBbmltYXRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICBNb3Rpb24uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5fdXBkYXRlQVJJQSh0cnVlKTtcblxuICAgICAgICAgIHRoaXMudHJpZ2dlcignb24uemYudG9nZ2xlcicpO1xuICAgICAgICAgIHRoaXMuZmluZCgnW2RhdGEtbXV0YXRlXScpLnRyaWdnZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBNb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LCB0aGlzLmFuaW1hdGlvbk91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl91cGRhdGVBUklBKGZhbHNlKTtcblxuICAgICAgICAgIHRoaXMudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTtcbiAgICAgICAgICB0aGlzLmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQVJJQVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQVJJQShpc09uKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkO1xuICAgICAgJChcIltkYXRhLW9wZW49XFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXSwgW2RhdGEtY2xvc2U9XFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXVwiKSkuYXR0cih7XG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogaXNPbiA/IHRydWUgOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiBUb2dnbGVyIG9uIHRoZSBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRvZ2dsZXInKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9nZ2xlcjtcbn0oUGx1Z2luKTtcblxuVG9nZ2xlci5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFRlbGxzIHRoZSBwbHVnaW4gaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGFuaW1hdGVkIHdoZW4gdG9nZ2xlZC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFuaW1hdGU6IGZhbHNlXG59O1xuXG4vKipcbiAqIFRvb2x0aXAgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnRvb2x0aXBcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqL1xuXG52YXIgVG9vbHRpcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1Bvc2l0aW9uYWJsZSkge1xuICBfaW5oZXJpdHMoVG9vbHRpcCwgX1Bvc2l0aW9uYWJsZSk7XG5cbiAgZnVuY3Rpb24gVG9vbHRpcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFRvb2x0aXApLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIFRvb2x0aXAuXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgVG9vbHRpcFxuICAgICAqIEBmaXJlcyBUb29sdGlwI2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYXR0YWNoIGEgdG9vbHRpcCB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB0byBleHRlbmQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvb2x0aXAuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Rvb2x0aXAnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0NsaWNrID0gZmFsc2U7IC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxuXG4gICAgICBUcmlnZ2Vycy5pbml0KCQpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwIGJ5IHNldHRpbmcgdGhlIGNyZWF0aW5nIHRoZSB0aXAgZWxlbWVudCwgYWRkaW5nIGl0J3MgdGV4dCwgc2V0dGluZyBwcml2YXRlIHZhcmlhYmxlcyBhbmQgc2V0dGluZyBhdHRyaWJ1dGVzIG9uIHRoZSBhbmNob3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgTWVkaWFRdWVyeS5faW5pdCgpO1xuXG4gICAgICB2YXIgZWxlbUlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JykgfHwgR2V0WW9EaWdpdHMoNiwgJ3Rvb2x0aXAnKTtcbiAgICAgIHRoaXMub3B0aW9ucy50aXBUZXh0ID0gdGhpcy5vcHRpb25zLnRpcFRleHQgfHwgdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScpO1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZSA/ICQodGhpcy5vcHRpb25zLnRlbXBsYXRlKSA6IHRoaXMuX2J1aWxkVGVtcGxhdGUoZWxlbUlkKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0h0bWwpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS5odG1sKHRoaXMub3B0aW9ucy50aXBUZXh0KS5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpLnRleHQodGhpcy5vcHRpb25zLnRpcFRleHQpLmhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ3RpdGxlJzogJycsXG4gICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogZWxlbUlkLFxuICAgICAgICAnZGF0YS15ZXRpLWJveCc6IGVsZW1JZCxcbiAgICAgICAgJ2RhdGEtdG9nZ2xlJzogZWxlbUlkLFxuICAgICAgICAnZGF0YS1yZXNpemUnOiBlbGVtSWRcbiAgICAgIH0pLmFkZENsYXNzKHRoaXMub3B0aW9ucy50cmlnZ2VyQ2xhc3MpO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihUb29sdGlwLnByb3RvdHlwZSksIFwiX2luaXRcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREZWZhdWx0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRQb3NpdGlvbigpIHtcbiAgICAgIC8vIGhhbmRsZSBsZWdhY3kgY2xhc3NuYW1lc1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goL1xcYih0b3B8bGVmdHxyaWdodHxib3R0b20pXFxiL2cpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID8gcG9zaXRpb25bMF0gOiAndG9wJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERlZmF1bHRBbGlnbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRBbGlnbm1lbnQoKSB7XG4gICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRIT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIT2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JyB8fCB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaE9mZnNldCArIHRoaXMub3B0aW9ucy50b29sdGlwV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWT2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMucG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudk9mZnNldCArIHRoaXMub3B0aW9ucy50b29sdGlwSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBidWlsZHMgdGhlIHRvb2x0aXAgZWxlbWVudCwgYWRkcyBhdHRyaWJ1dGVzLCBhbmQgcmV0dXJucyB0aGUgdGVtcGxhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9idWlsZFRlbXBsYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZFRlbXBsYXRlKGlkKSB7XG4gICAgICB2YXIgdGVtcGxhdGVDbGFzc2VzID0gXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcywgXCIgXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMudGVtcGxhdGVDbGFzc2VzKS50cmltKCk7XG4gICAgICB2YXIgJHRlbXBsYXRlID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcyh0ZW1wbGF0ZUNsYXNzZXMpLmF0dHIoe1xuICAgICAgICAncm9sZSc6ICd0b29sdGlwJyxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogZmFsc2UsXG4gICAgICAgICdkYXRhLWlzLWZvY3VzJzogZmFsc2UsXG4gICAgICAgICdpZCc6IGlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAkdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIHBvc2l0aW9uIGNsYXNzIG9mIGFuIGVsZW1lbnQgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiB1bnRpbCB0aGVyZSBhcmUgbm8gbW9yZSBwb3NzaWJsZSBwb3NpdGlvbnMgdG8gYXR0ZW1wdCwgb3IgdGhlIHRvb2x0aXAgZWxlbWVudCBpcyBubyBsb25nZXIgY29sbGlkaW5nLlxuICAgICAqIGlmIHRoZSB0b29sdGlwIGlzIGxhcmdlciB0aGFuIHRoZSBzY3JlZW4gd2lkdGgsIGRlZmF1bHQgdG8gZnVsbCB3aWR0aCAtIGFueSB1c2VyIHNlbGVjdGVkIG1hcmdpblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFBvc2l0aW9uKCkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVG9vbHRpcC5wcm90b3R5cGUpLCBcIl9zZXRQb3NpdGlvblwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMuJGVsZW1lbnQsIHRoaXMudGVtcGxhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXZlYWxzIHRoZSB0b29sdGlwLCBhbmQgZmlyZXMgYW4gZXZlbnQgdG8gY2xvc2UgYW55IG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcbiAgICAgKiBAZmlyZXMgVG9vbHRpcCNjbG9zZW1lXG4gICAgICogQGZpcmVzIFRvb2x0aXAjc2hvd1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93T24gIT09ICdhbGwnICYmICFNZWRpYVF1ZXJ5LmlzKHRoaXMub3B0aW9ucy5zaG93T24pKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1RoZSBzY3JlZW4gaXMgdG9vIHNtYWxsIHRvIGRpc3BsYXkgdGhpcyB0b29sdGlwJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy50ZW1wbGF0ZS5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuc2hvdygpO1xuXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKCd0b3AgYm90dG9tIGxlZnQgcmlnaHQnKS5hZGRDbGFzcyh0aGlzLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MoJ2FsaWduLXRvcCBhbGlnbi1ib3R0b20gYWxpZ24tbGVmdCBhbGlnbi1yaWdodCBhbGlnbi1jZW50ZXInKS5hZGRDbGFzcygnYWxpZ24tJyArIHRoaXMuYWxpZ25tZW50KTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgdG8gY2xvc2UgYWxsIG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcbiAgICAgICAqIEBldmVudCBDbG9zZW1lI3Rvb2x0aXBcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYudG9vbHRpcCcsIHRoaXMudGVtcGxhdGUuYXR0cignaWQnKSk7XG4gICAgICB0aGlzLnRlbXBsYXRlLmF0dHIoe1xuICAgICAgICAnZGF0YS1pcy1hY3RpdmUnOiB0cnVlLFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBfdGhpcy5pc0FjdGl2ZSA9IHRydWU7IC8vIGNvbnNvbGUubG9nKHRoaXMudGVtcGxhdGUpO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlLnN0b3AoKS5oaWRlKCkuY3NzKCd2aXNpYmlsaXR5JywgJycpLmZhZGVJbih0aGlzLm9wdGlvbnMuZmFkZUluRHVyYXRpb24sIGZ1bmN0aW9uICgpIHsvL21heWJlIGRvIHN0dWZmP1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHRvb2x0aXAgaXMgc2hvd25cbiAgICAgICAqIEBldmVudCBUb29sdGlwI3Nob3dcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYudG9vbHRpcCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgY3VycmVudCB0b29sdGlwLCBhbmQgcmVzZXRzIHRoZSBwb3NpdGlvbmluZyBjbGFzcyBpZiBpdCB3YXMgY2hhbmdlZCBkdWUgdG8gY29sbGlzaW9uXG4gICAgICogQGZpcmVzIFRvb2x0aXAjaGlkZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2hpZGluZycsIHRoaXMuJGVsZW1lbnQuZGF0YSgneWV0aS1ib3gnKSk7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlLnN0b3AoKS5hdHRyKHtcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogZmFsc2VcbiAgICAgIH0pLmZhZGVPdXQodGhpcy5vcHRpb25zLmZhZGVPdXREdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc0NsaWNrID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogZmlyZXMgd2hlbiB0aGUgdG9vbHRpcCBpcyBoaWRkZW5cbiAgICAgICAqIEBldmVudCBUb29sdGlwI2hpZGVcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYudG9vbHRpcCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIHRvb2x0aXAgYW5kIGl0cyBhbmNob3JcbiAgICAgKiBUT0RPIGNvbWJpbmUgc29tZSBvZiB0aGUgbGlzdGVuZXJzIGxpa2UgZm9jdXMgYW5kIG1vdXNlZW50ZXIsIGV0Yy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyICR0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgICB2YXIgaXNGb2N1cyA9IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2VlbnRlci56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi50b29sdGlwJywgaWdub3JlTW91c2VkaXNhcHBlYXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG5cbiAgICAgICAgICBpZiAoIWlzRm9jdXMgfHwgX3RoaXMuaXNDbGljayAmJiAhX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcbiAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2Vkb3duLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuaXNDbGljaykgOyBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmlzQ2xpY2sgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoKF90aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyIHx8ICFfdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpKSAmJiAhX3RoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWRvd24uemYudG9vbHRpcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBfdGhpcy5pc0NsaWNrID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVGb3JUb3VjaCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCd0YXAuemYudG9vbHRpcCB0b3VjaGVuZC56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBfdGhpcy5pc0FjdGl2ZSA/IF90aGlzLmhpZGUoKSA6IF90aGlzLnNob3coKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oe1xuICAgICAgICAvLyAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgICAvLyAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuaGlkZS5iaW5kKHRoaXMpXG4gICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5oaWRlLmJpbmQodGhpcylcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kZWxlbWVudC5vbignZm9jdXMuemYudG9vbHRpcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlzRm9jdXMgPSB0cnVlO1xuXG4gICAgICAgIGlmIChfdGhpcy5pc0NsaWNrKSB7XG4gICAgICAgICAgLy8gSWYgd2UncmUgbm90IHNob3dpbmcgb3BlbiBvbiBjbGlja3MsIHdlIG5lZWQgdG8gcHJldGVuZCBhIGNsaWNrLWxhdW5jaGVkIGZvY3VzIGlzbid0XG4gICAgICAgICAgLy8gYSByZWFsIGZvY3VzLCBvdGhlcndpc2Ugb24gaG92ZXIgYW5kIGNvbWUgYmFjayB3ZSBnZXQgYmFkIGJlaGF2aW9yXG4gICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xuICAgICAgICAgICAgaXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0pLm9uKCdmb2N1c291dC56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc0NsaWNrID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgfSkub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgIF90aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYWRkcyBhIHRvZ2dsZSBtZXRob2QsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGF0aWMgc2hvdygpICYgaGlkZSgpIGZ1bmN0aW9uc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIHRvb2x0aXAsIHJlbW92ZXMgdGVtcGxhdGUgZWxlbWVudCBmcm9tIHRoZSB2aWV3LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJywgdGhpcy50ZW1wbGF0ZS50ZXh0KCkpLm9mZignLnpmLnRyaWdnZXIgLnpmLnRvb2x0aXAnKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudHJpZ2dlckNsYXNzKS5yZW1vdmVDbGFzcygndG9wIHJpZ2h0IGxlZnQgYm90dG9tJykucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieSBkYXRhLWRpc2FibGUtaG92ZXIgZGF0YS1yZXNpemUgZGF0YS10b2dnbGUgZGF0YS10b29sdGlwIGRhdGEteWV0aS1ib3gnKTtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRvb2x0aXA7XG59KFBvc2l0aW9uYWJsZSk7XG5cblRvb2x0aXAuZGVmYXVsdHMgPSB7XG4gIGRpc2FibGVGb3JUb3VjaDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCBiZWZvcmUgYSB0b29sdGlwIHNob3VsZCBvcGVuIG9uIGhvdmVyLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDIwMFxuICAgKi9cbiAgaG92ZXJEZWxheTogMjAwLFxuXG4gIC8qKlxuICAgKiBUaW1lLCBpbiBtcywgYSB0b29sdGlwIHNob3VsZCB0YWtlIHRvIGZhZGUgaW50byB2aWV3LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDE1MFxuICAgKi9cbiAgZmFkZUluRHVyYXRpb246IDE1MCxcblxuICAvKipcbiAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIG91dCBvZiB2aWV3LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDE1MFxuICAgKi9cbiAgZmFkZU91dER1cmF0aW9uOiAxNTAsXG5cbiAgLyoqXG4gICAqIERpc2FibGVzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgdGhlIHRvb2x0aXAgaWYgc2V0IHRvIHRydWVcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVIb3ZlcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGFkZHRpb25hbCBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSB0b29sdGlwIHRlbXBsYXRlIG9uIGluaXQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIHRlbXBsYXRlQ2xhc3NlczogJycsXG5cbiAgLyoqXG4gICAqIE5vbi1vcHRpb25hbCBjbGFzcyBhZGRlZCB0byB0b29sdGlwIHRlbXBsYXRlcy4gRm91bmRhdGlvbiBkZWZhdWx0IGlzICd0b29sdGlwJy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAndG9vbHRpcCdcbiAgICovXG4gIHRvb2x0aXBDbGFzczogJ3Rvb2x0aXAnLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSB0b29sdGlwIGFuY2hvciBlbGVtZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdoYXMtdGlwJ1xuICAgKi9cbiAgdHJpZ2dlckNsYXNzOiAnaGFzLXRpcCcsXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gYnJlYWtwb2ludCBzaXplIGF0IHdoaWNoIHRvIG9wZW4gdGhlIHRvb2x0aXAuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ3NtYWxsJ1xuICAgKi9cbiAgc2hvd09uOiAnc21hbGwnLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdGVtcGxhdGUgdG8gYmUgdXNlZCB0byBnZW5lcmF0ZSBtYXJrdXAgZm9yIHRvb2x0aXAuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIHRlbXBsYXRlOiAnJyxcblxuICAvKipcbiAgICogVGV4dCBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXAgdGVtcGxhdGUgb24gb3Blbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgdGlwVGV4dDogJycsXG4gIHRvdWNoQ2xvc2VUZXh0OiAnVGFwIHRvIGNsb3NlLicsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgdG9vbHRpcCB0byByZW1haW4gb3BlbiBpZiB0cmlnZ2VyZWQgd2l0aCBhIGNsaWNrIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBjbGlja09wZW46IHRydWUsXG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIG9mIHRvb2x0aXAuIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG9yIGF1dG8uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2F1dG8nXG4gICAqL1xuICBwb3NpdGlvbjogJ2F1dG8nLFxuXG4gIC8qKlxuICAgKiBBbGlnbm1lbnQgb2YgdG9vbHRpcCByZWxhdGl2ZSB0byBhbmNob3IuIENhbiBiZSBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIGNlbnRlciwgb3IgYXV0by5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnYXV0bydcbiAgICovXG4gIGFsaWdubWVudDogJ2F1dG8nLFxuXG4gIC8qKlxuICAgKiBBbGxvdyBvdmVybGFwIG9mIGNvbnRhaW5lci93aW5kb3cuIElmIGZhbHNlLCB0b29sdGlwIHdpbGwgZmlyc3QgdHJ5IHRvXG4gICAqIHBvc2l0aW9uIGFzIGRlZmluZWQgYnkgZGF0YS1wb3NpdGlvbiBhbmQgZGF0YS1hbGlnbm1lbnQsIGJ1dCByZXBvc2l0aW9uIGlmXG4gICAqIGl0IHdvdWxkIGNhdXNlIGFuIG92ZXJmbG93LiAgQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFsbG93T3ZlcmxhcDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93IG92ZXJsYXAgb2Ygb25seSB0aGUgYm90dG9tIG9mIHRoZSBjb250YWluZXIuIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uXG4gICAqIGJlaGF2aW9yIGZvciBkcm9wZG93bnMsIGFsbG93aW5nIHRoZSBkcm9wZG93biB0byBleHRlbmQgdGhlIGJvdHRvbSBvZiB0aGVcbiAgICogc2NyZWVuIGJ1dCBub3Qgb3RoZXJ3aXNlIGluZmx1ZW5jZSBvciBicmVhayBvdXQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICogTGVzcyBjb21tb24gZm9yIHRvb2x0aXBzLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYWxsb3dCb3R0b21PdmVybGFwOiBmYWxzZSxcblxuICAvKipcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNob3VsZCBwdXNoIGF3YXkgZnJvbSB0aGUgYW5jaG9yIG9uIHRoZSBZIGF4aXMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgdk9mZnNldDogMCxcblxuICAvKipcbiAgICogRGlzdGFuY2UsIGluIHBpeGVscywgdGhlIHRlbXBsYXRlIHNob3VsZCBwdXNoIGF3YXkgZnJvbSB0aGUgYW5jaG9yIG9uIHRoZSBYIGF4aXNcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBoT2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc3BhY2luZyBhdXRvLWFkanVzdCBmb3IgYSB2ZXJ0aWNhbCB0b29sdGlwXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMTRcbiAgICovXG4gIHRvb2x0aXBIZWlnaHQ6IDE0LFxuXG4gIC8qKlxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc3BhY2luZyBhdXRvLWFkanVzdCBmb3IgYSBob3Jpem9udGFsIHRvb2x0aXBcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMlxuICAgKi9cbiAgdG9vbHRpcFdpZHRoOiAxMixcblxuICAvKipcbiAgKiBBbGxvdyBIVE1MIGluIHRvb2x0aXAuIFdhcm5pbmc6IElmIHlvdSBhcmUgbG9hZGluZyB1c2VyLWdlbmVyYXRlZCBjb250ZW50IGludG8gdG9vbHRpcHMsXG4gICogYWxsb3dpbmcgSFRNTCBtYXkgb3BlbiB5b3Vyc2VsZiB1cCB0byBYU1MgYXR0YWNrcy5cbiAgKiBAb3B0aW9uXG4gICogQHR5cGUge2Jvb2xlYW59XG4gICogQGRlZmF1bHQgZmFsc2VcbiAgKi9cbiAgYWxsb3dIdG1sOiBmYWxzZVxufTtcblxudmFyIE1lbnVQbHVnaW5zJDEgPSB7XG4gIHRhYnM6IHtcbiAgICBjc3NDbGFzczogJ3RhYnMnLFxuICAgIHBsdWdpbjogVGFic1xuICB9LFxuICBhY2NvcmRpb246IHtcbiAgICBjc3NDbGFzczogJ2FjY29yZGlvbicsXG4gICAgcGx1Z2luOiBBY2NvcmRpb25cbiAgfVxufTtcbi8qKlxuICogUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVBY2NvcmRpb25UYWJzXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24uYWNjb3JkaW9uXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi50YWJzXG4gKi9cblxudmFyIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhSZXNwb25zaXZlQWNjb3JkaW9uVGFicywgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSByZXNwb25zaXZlIGFjY29yZGlvbiB0YWJzLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzXG4gICAgICogQGZpcmVzIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzI2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIFJlc3BvbnNpdmUgQWNjb3JkaW9uIFRhYnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5ydWxlcyA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS1hY2NvcmRpb24tdGFicycpO1xuICAgICAgdGhpcy5jdXJyZW50TXEgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbnVsbDtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Jlc3BvbnNpdmVBY2NvcmRpb25UYWJzJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignaWQnLCBHZXRZb0RpZ2l0cyg2LCAncmVzcG9uc2l2ZWFjY29yZGlvbnRhYnMnKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNZW51IGJ5IHBhcnNpbmcgdGhlIGNsYXNzZXMgZnJvbSB0aGUgJ2RhdGEtcmVzcG9uc2l2ZS1hY2NvcmRpb24tdGFicycgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIE1lZGlhUXVlcnkuX2luaXQoKTsgLy8gVGhlIGZpcnN0IHRpbWUgYW4gSW50ZXJjaGFuZ2UgcGx1Z2luIGlzIGluaXRpYWxpemVkLCB0aGlzLnJ1bGVzIGlzIGNvbnZlcnRlZCBmcm9tIGEgc3RyaW5nIG9mIFwiY2xhc3Nlc1wiIHRvIGFuIG9iamVjdCBvZiBydWxlc1xuXG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5ydWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHJ1bGVzVHJlZSA9IHt9OyAvLyBQYXJzZSBydWxlcyBmcm9tIFwiY2xhc3Nlc1wiIHB1bGxlZCBmcm9tIGRhdGEgYXR0cmlidXRlXG5cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcy5zcGxpdCgnICcpOyAvLyBJdGVyYXRlIHRocm91Z2ggZXZlcnkgcnVsZSBmb3VuZFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldLnNwbGl0KCctJyk7XG4gICAgICAgICAgdmFyIHJ1bGVTaXplID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVswXSA6ICdzbWFsbCc7XG4gICAgICAgICAgdmFyIHJ1bGVQbHVnaW4gPSBydWxlLmxlbmd0aCA+IDEgPyBydWxlWzFdIDogcnVsZVswXTtcblxuICAgICAgICAgIGlmIChNZW51UGx1Z2lucyQxW3J1bGVQbHVnaW5dICE9PSBudWxsKSB7XG4gICAgICAgICAgICBydWxlc1RyZWVbcnVsZVNpemVdID0gTWVudVBsdWdpbnMkMVtydWxlUGx1Z2luXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXNUcmVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9nZXRBbGxPcHRpb25zKCk7XG5cbiAgICAgIGlmICghJC5pc0VtcHR5T2JqZWN0KHRoaXMucnVsZXMpKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBbGxPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxPcHRpb25zKCkge1xuICAgICAgLy9nZXQgYWxsIGRlZmF1bHRzIGFuZCBvcHRpb25zXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfdGhpcy5hbGxPcHRpb25zID0ge307XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBNZW51UGx1Z2lucyQxKSB7XG4gICAgICAgIGlmIChNZW51UGx1Z2lucyQxLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgb2JqID0gTWVudVBsdWdpbnMkMVtrZXldO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBkdW1teVBsdWdpbiA9ICQoJzx1bD48L3VsPicpO1xuICAgICAgICAgICAgdmFyIHRtcFBsdWdpbiA9IG5ldyBvYmoucGx1Z2luKGR1bW15UGx1Z2luLCBfdGhpcy5vcHRpb25zKTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5S2V5IGluIHRtcFBsdWdpbi5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIGlmICh0bXBQbHVnaW4ub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXlLZXkpICYmIGtleUtleSAhPT0gJ3pmUGx1Z2luJykge1xuICAgICAgICAgICAgICAgIHZhciBvYmpPYmogPSB0bXBQbHVnaW4ub3B0aW9uc1trZXlLZXldO1xuICAgICAgICAgICAgICAgIF90aGlzLmFsbE9wdGlvbnNba2V5S2V5XSA9IG9iak9iajtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bXBQbHVnaW4uZGVzdHJveSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciB0aGUgTWVudS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdGhpcy5fY2hhbmdlZFpmTWVkaWFRdWVyeUhhbmRsZXIgPSB0aGlzLl9jaGVja01lZGlhUXVlcmllcy5iaW5kKHRoaXMpO1xuICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9jaGFuZ2VkWmZNZWRpYVF1ZXJ5SGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBzY3JlZW4gd2lkdGggYWdhaW5zdCBhdmFpbGFibGUgbWVkaWEgcXVlcmllcy4gSWYgdGhlIG1lZGlhIHF1ZXJ5IGhhcyBjaGFuZ2VkLCBhbmQgdGhlIHBsdWdpbiBuZWVkZWQgaGFzIGNoYW5nZWQsIHRoZSBwbHVnaW5zIHdpbGwgc3dhcCBvdXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja01lZGlhUXVlcmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tNZWRpYVF1ZXJpZXMoKSB7XG4gICAgICB2YXIgbWF0Y2hlZE1xLFxuICAgICAgICAgIF90aGlzID0gdGhpczsgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSBhbmQgZmluZCB0aGUgbGFzdCBtYXRjaGluZyBydWxlXG5cblxuICAgICAgJC5lYWNoKHRoaXMucnVsZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKE1lZGlhUXVlcnkuYXRMZWFzdChrZXkpKSB7XG4gICAgICAgICAgbWF0Y2hlZE1xID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gTm8gbWF0Y2g/IE5vIGRpY2VcblxuICAgICAgaWYgKCFtYXRjaGVkTXEpIHJldHVybjsgLy8gUGx1Z2luIGFscmVhZHkgaW5pdGlhbGl6ZWQ/IFdlIGdvb2RcblxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4pIHJldHVybjsgLy8gUmVtb3ZlIGV4aXN0aW5nIHBsdWdpbi1zcGVjaWZpYyBDU1MgY2xhc3Nlc1xuXG4gICAgICAkLmVhY2goTWVudVBsdWdpbnMkMSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModmFsdWUuY3NzQ2xhc3MpO1xuICAgICAgfSk7IC8vIEFkZCB0aGUgQ1NTIGNsYXNzIGZvciB0aGUgbmV3IHBsdWdpblxuXG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5jc3NDbGFzcyk7IC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgbmV3IHBsdWdpblxuXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB7XG4gICAgICAgIC8vZG9uJ3Qga25vdyB3aHkgYnV0IG9uIG5lc3RlZCBlbGVtZW50cyBkYXRhIHpmUGx1Z2luIGdldCdzIGxvc3RcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRQbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nKSAmJiB0aGlzLnN0b3JlemZEYXRhKSB0aGlzLmN1cnJlbnRQbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nLCB0aGlzLnN0b3JlemZEYXRhKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faGFuZGxlTWFya3VwKHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5jc3NDbGFzcyk7XG5cbiAgICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG5ldyB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKHRoaXMuJGVsZW1lbnQsIHt9KTtcbiAgICAgIHRoaXMuc3RvcmV6ZkRhdGEgPSB0aGlzLmN1cnJlbnRQbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZU1hcmt1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTWFya3VwKHRvU2V0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGZyb21TdHJpbmcgPSAnYWNjb3JkaW9uJztcblxuICAgICAgdmFyICRwYW5lbHMgPSAkKCdbZGF0YS10YWJzLWNvbnRlbnQ9JyArIHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICddJyk7XG4gICAgICBpZiAoJHBhbmVscy5sZW5ndGgpIGZyb21TdHJpbmcgPSAndGFicyc7XG5cbiAgICAgIGlmIChmcm9tU3RyaW5nID09PSB0b1NldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGFic1RpdGxlID0gX3RoaXMuYWxsT3B0aW9ucy5saW5rQ2xhc3MgPyBfdGhpcy5hbGxPcHRpb25zLmxpbmtDbGFzcyA6ICd0YWJzLXRpdGxlJztcbiAgICAgIHZhciB0YWJzUGFuZWwgPSBfdGhpcy5hbGxPcHRpb25zLnBhbmVsQ2xhc3MgPyBfdGhpcy5hbGxPcHRpb25zLnBhbmVsQ2xhc3MgOiAndGFicy1wYW5lbCc7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHIoJ3JvbGUnKTtcbiAgICAgIHZhciAkbGlIZWFkcyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy4nICsgdGFic1RpdGxlICsgJyxbZGF0YS1hY2NvcmRpb24taXRlbV0nKS5yZW1vdmVDbGFzcyh0YWJzVGl0bGUpLnJlbW92ZUNsYXNzKCdhY2NvcmRpb24taXRlbScpLnJlbW92ZUF0dHIoJ2RhdGEtYWNjb3JkaW9uLWl0ZW0nKTtcbiAgICAgIHZhciAkbGlIZWFkc0EgPSAkbGlIZWFkcy5jaGlsZHJlbignYScpLnJlbW92ZUNsYXNzKCdhY2NvcmRpb24tdGl0bGUnKTtcblxuICAgICAgaWYgKGZyb21TdHJpbmcgPT09ICd0YWJzJykge1xuICAgICAgICAkcGFuZWxzID0gJHBhbmVscy5jaGlsZHJlbignLicgKyB0YWJzUGFuZWwpLnJlbW92ZUNsYXNzKHRhYnNQYW5lbCkucmVtb3ZlQXR0cigncm9sZScpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJykucmVtb3ZlQXR0cignYXJpYS1sYWJlbGxlZGJ5Jyk7XG4gICAgICAgICRwYW5lbHMuY2hpbGRyZW4oJ2EnKS5yZW1vdmVBdHRyKCdyb2xlJykucmVtb3ZlQXR0cignYXJpYS1jb250cm9scycpLnJlbW92ZUF0dHIoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRwYW5lbHMgPSAkbGlIZWFkcy5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJykucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbi1jb250ZW50Jyk7XG4gICAgICB9XG4gICAgICAkcGFuZWxzLmNzcyh7XG4gICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICB2aXNpYmlsaXR5OiAnJ1xuICAgICAgfSk7XG4gICAgICAkbGlIZWFkcy5jc3Moe1xuICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgdmlzaWJpbGl0eTogJydcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodG9TZXQgPT09ICdhY2NvcmRpb24nKSB7XG4gICAgICAgICRwYW5lbHMuZWFjaChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICQodmFsdWUpLmFwcGVuZFRvKCRsaUhlYWRzLmdldChrZXkpKS5hZGRDbGFzcygnYWNjb3JkaW9uLWNvbnRlbnQnKS5hdHRyKCdkYXRhLXRhYi1jb250ZW50JywgJycpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5jc3Moe1xuICAgICAgICAgICAgaGVpZ2h0OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgICQoJ1tkYXRhLXRhYnMtY29udGVudD0nICsgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICddJykuYWZ0ZXIoJzxkaXYgaWQ9XCJ0YWJzLXBsYWNlaG9sZGVyLScgKyBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpICsgJ1wiPjwvZGl2PicpLmRldGFjaCgpO1xuICAgICAgICAgICRsaUhlYWRzLmFkZENsYXNzKCdhY2NvcmRpb24taXRlbScpLmF0dHIoJ2RhdGEtYWNjb3JkaW9uLWl0ZW0nLCAnJyk7XG4gICAgICAgICAgJGxpSGVhZHNBLmFkZENsYXNzKCdhY2NvcmRpb24tdGl0bGUnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRvU2V0ID09PSAndGFicycpIHtcbiAgICAgICAgdmFyICR0YWJzQ29udGVudCA9ICQoJ1tkYXRhLXRhYnMtY29udGVudD0nICsgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICddJyk7XG4gICAgICAgIHZhciAkcGxhY2Vob2xkZXIgPSAkKCcjdGFicy1wbGFjZWhvbGRlci0nICsgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XG5cbiAgICAgICAgaWYgKCRwbGFjZWhvbGRlci5sZW5ndGgpIHtcbiAgICAgICAgICAkdGFic0NvbnRlbnQgPSAkKCc8ZGl2IGNsYXNzPVwidGFicy1jb250ZW50XCI+PC9kaXY+JykuaW5zZXJ0QWZ0ZXIoJHBsYWNlaG9sZGVyKS5hdHRyKCdkYXRhLXRhYnMtY29udGVudCcsIF90aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xuICAgICAgICAgICRwbGFjZWhvbGRlci5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkdGFic0NvbnRlbnQgPSAkKCc8ZGl2IGNsYXNzPVwidGFicy1jb250ZW50XCI+PC9kaXY+JykuaW5zZXJ0QWZ0ZXIoX3RoaXMuJGVsZW1lbnQpLmF0dHIoJ2RhdGEtdGFicy1jb250ZW50JywgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgJHBhbmVscy5lYWNoKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHRlbXBWYWx1ZSA9ICQodmFsdWUpLmFwcGVuZFRvKCR0YWJzQ29udGVudCkuYWRkQ2xhc3ModGFic1BhbmVsKTtcbiAgICAgICAgICB2YXIgaGFzaCA9ICRsaUhlYWRzQS5nZXQoa2V5KS5oYXNoLnNsaWNlKDEpO1xuICAgICAgICAgIHZhciBpZCA9ICQodmFsdWUpLmF0dHIoJ2lkJykgfHwgR2V0WW9EaWdpdHMoNiwgJ2FjY29yZGlvbicpO1xuXG4gICAgICAgICAgaWYgKGhhc2ggIT09IGlkKSB7XG4gICAgICAgICAgICBpZiAoaGFzaCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgJCh2YWx1ZSkuYXR0cignaWQnLCBoYXNoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgJCh2YWx1ZSkuYXR0cignaWQnLCBoYXNoKTtcbiAgICAgICAgICAgICAgJCgkbGlIZWFkc0EuZ2V0KGtleSkpLmF0dHIoJ2hyZWYnLCAkKCRsaUhlYWRzQS5nZXQoa2V5KSkuYXR0cignaHJlZicpLnJlcGxhY2UoJyMnLCAnJykgKyAnIycgKyBoYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQWN0aXZlID0gJCgkbGlIZWFkcy5nZXQoa2V5KSkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0ZW1wVmFsdWUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRsaUhlYWRzLmFkZENsYXNzKHRhYnNUaXRsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBwbHVnaW4gb24gdGhpcyBlbGVtZW50LCBhcyB3ZWxsIGFzIHRoZSB3aW5kb3cgcmVzaXplIGhhbmRsZXIgdGhhdCBzd2l0Y2hlcyB0aGUgcGx1Z2lucyBvdXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4pIHRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCk7XG4gICAgICAkKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9jaGFuZ2VkWmZNZWRpYVF1ZXJ5SGFuZGxlcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzO1xufShQbHVnaW4pO1xuXG5SZXNwb25zaXZlQWNjb3JkaW9uVGFicy5kZWZhdWx0cyA9IHt9O1xuXG5Gb3VuZGF0aW9uLmFkZFRvSnF1ZXJ5KCQpOyAvLyBBZGQgRm91bmRhdGlvbiBVdGlscyB0byBGb3VuZGF0aW9uIGdsb2JhbCBuYW1lc3BhY2UgZm9yIGJhY2t3YXJkc1xuLy8gY29tcGF0aWJpbGl0eS5cblxuRm91bmRhdGlvbi5ydGwgPSBydGw7XG5Gb3VuZGF0aW9uLkdldFlvRGlnaXRzID0gR2V0WW9EaWdpdHM7XG5Gb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQgPSB0cmFuc2l0aW9uZW5kO1xuRm91bmRhdGlvbi5SZWdFeHBFc2NhcGUgPSBSZWdFeHBFc2NhcGU7XG5Gb3VuZGF0aW9uLm9uTG9hZCA9IG9uTG9hZDtcbkZvdW5kYXRpb24uQm94ID0gQm94O1xuRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCA9IG9uSW1hZ2VzTG9hZGVkO1xuRm91bmRhdGlvbi5LZXlib2FyZCA9IEtleWJvYXJkO1xuRm91bmRhdGlvbi5NZWRpYVF1ZXJ5ID0gTWVkaWFRdWVyeTtcbkZvdW5kYXRpb24uTW90aW9uID0gTW90aW9uO1xuRm91bmRhdGlvbi5Nb3ZlID0gTW92ZTtcbkZvdW5kYXRpb24uTmVzdCA9IE5lc3Q7XG5Gb3VuZGF0aW9uLlRpbWVyID0gVGltZXI7IC8vIFRvdWNoIGFuZCBUcmlnZ2VycyBwcmV2aW91c2x5IHdlcmUgYWxtb3N0IHB1cmVseSBzZWRlIGVmZmVjdCBkcml2ZW4sXG4vLyBzbyBubyBuZWVkIHRvIGFkZCBpdCB0byBGb3VuZGF0aW9uLCBqdXN0IGluaXQgdGhlbS5cblxuVG91Y2guaW5pdCgkKTtcblRyaWdnZXJzLmluaXQoJCwgRm91bmRhdGlvbik7XG5cbk1lZGlhUXVlcnkuX2luaXQoKTtcblxuRm91bmRhdGlvbi5wbHVnaW4oQWJpZGUsICdBYmlkZScpO1xuRm91bmRhdGlvbi5wbHVnaW4oQWNjb3JkaW9uLCAnQWNjb3JkaW9uJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihBY2NvcmRpb25NZW51LCAnQWNjb3JkaW9uTWVudScpO1xuRm91bmRhdGlvbi5wbHVnaW4oRHJpbGxkb3duLCAnRHJpbGxkb3duJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihEcm9wZG93biwgJ0Ryb3Bkb3duJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihEcm9wZG93bk1lbnUsICdEcm9wZG93bk1lbnUnKTtcbkZvdW5kYXRpb24ucGx1Z2luKEVxdWFsaXplciwgJ0VxdWFsaXplcicpO1xuRm91bmRhdGlvbi5wbHVnaW4oSW50ZXJjaGFuZ2UsICdJbnRlcmNoYW5nZScpO1xuRm91bmRhdGlvbi5wbHVnaW4oTWFnZWxsYW4sICdNYWdlbGxhbicpO1xuRm91bmRhdGlvbi5wbHVnaW4oT2ZmQ2FudmFzLCAnT2ZmQ2FudmFzJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihPcmJpdCwgJ09yYml0Jyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlTWVudSwgJ1Jlc3BvbnNpdmVNZW51Jyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlVG9nZ2xlLCAnUmVzcG9uc2l2ZVRvZ2dsZScpO1xuRm91bmRhdGlvbi5wbHVnaW4oUmV2ZWFsLCAnUmV2ZWFsJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihTbGlkZXIsICdTbGlkZXInKTtcbkZvdW5kYXRpb24ucGx1Z2luKFNtb290aFNjcm9sbCwgJ1Ntb290aFNjcm9sbCcpO1xuRm91bmRhdGlvbi5wbHVnaW4oU3RpY2t5LCAnU3RpY2t5Jyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihUYWJzLCAnVGFicycpO1xuRm91bmRhdGlvbi5wbHVnaW4oVG9nZ2xlciwgJ1RvZ2dsZXInKTtcbkZvdW5kYXRpb24ucGx1Z2luKFRvb2x0aXAsICdUb29sdGlwJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlQWNjb3JkaW9uVGFicywgJ1Jlc3BvbnNpdmVBY2NvcmRpb25UYWJzJyk7XG5cbmV4cG9ydCBkZWZhdWx0IEZvdW5kYXRpb247XG5leHBvcnQgeyBmb3VuZGF0aW9uX2NvcmVfdXRpbHMgYXMgQ29yZVV0aWxzLCBGb3VuZGF0aW9uIGFzIENvcmUsIEJveCwgb25JbWFnZXNMb2FkZWQsIEtleWJvYXJkLCBNZWRpYVF1ZXJ5LCBNb3Rpb24sIE1vdmUsIE5lc3QsIFRpbWVyLCBUb3VjaCwgVHJpZ2dlcnMsIEFiaWRlLCBBY2NvcmRpb24sIEFjY29yZGlvbk1lbnUsIERyaWxsZG93biwgRHJvcGRvd24sIERyb3Bkb3duTWVudSwgRXF1YWxpemVyLCBJbnRlcmNoYW5nZSwgTWFnZWxsYW4sIE9mZkNhbnZhcywgT3JiaXQsIFJlc3BvbnNpdmVNZW51LCBSZXNwb25zaXZlVG9nZ2xlLCBSZXZlYWwsIFNsaWRlciwgU21vb3RoU2Nyb2xsLCBTdGlja3ksIFRhYnMsIFRvZ2dsZXIsIFRvb2x0aXAsIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLCBGb3VuZGF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3VuZGF0aW9uLmVzbS5qcy5tYXBcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvZm91bmRhdGlvbi5lc20uanMiXSwic291cmNlUm9vdCI6IiJ9